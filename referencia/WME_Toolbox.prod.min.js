!function () {
    var WMETBversion = '1.7.1'; var sec = {}; var sc = ["kJAzLvTmyJoBZDek5xh8TaE49uUZvJCG8xuiZ53EnRYI7qanhuEZ69CtWfmQelSCBqA3/tGItHPS5BIwGZUJRUpvgC5mc63D4kQF5NiQt0zBQJ387HKKgjy70LHJnevrltmWh9cPTxAe+oKKSO4MGRAi5vdXJG4sg7ysLatfsVWiS+Li5AVmSfVb8e4w4x4extqrA0I0NnWnWSX+kRiyyykwhW0G7YzjM2YkPRyNG4aPO2b+QccwjUNpvBwEwM7o1EV8g4rKLmpoaLZ34BpZwlsdCZmYLL5DQx0rB7FsScAlbv+BQAvFKGciOEfbcvk9gijbUXS7+SLgEY5ZWv/qOllYeGjjY90AvpjODk9TxYlWu+a7+jC9ZoYievPr/dM996/VzQ5m/qJhyWFOaCMXiGtcTmyE6dMxiSUVYtHEFWynjEKs02PLj8XXRI8ctGqZqng/LK1qIRJROjXUGn1kvnp78QDnwkHAY9dp5FsKCZexzR9djTI4vnkZFFARNdCEGXDFN2HDAlqp2/5bkJaFmKarpcXI6LhUuQPULzt18hUykRJb7XVvgLRTZvSbuGeTzJI5tfcqSkkRPuaCz58EAw9qg5p9ZoUaTcXSCsz7OQkFLxr1Ccn3sOSh7zRvcvsBKhSC8/b8sgNU3/i+qA7BUjei4qjEyC+XDVjyX4vI/0UN8MU9g8/g5mEJS1or6QXwPSWx9MdX4ueRI9A4KyuyES34B+FcYK1MYQVfCyky377QiWqoTzd4lfEmmwJ33p0LI7Yql0uYqUf/GVT3aLEauyvWwDfJeAlNN/X8+d61yBfTbZQoYA1EvtWcEPwiHCgxwMSath4BPCIUrL43MNilArZb25mtwKkEZwAmv/xBLfwi98caJ0gNAyxo+mDrlar78qNwxt8Z2IU3C6E65ZYEV68tGMBfjebg5m4lXF//1pJN+lEaeOeKDAWYISIQQnOvBE7Lv1+J/8trSUDxPEGXSlU4Th+Pxb2Vr0q4f0kDsg7yMIfAosQap/5/IcSBzvwv2l+/azNHmllzBV7mBfijU5aKPoi+W5u9qfkqDqSjjnh4KIttjSZjxXHn9hiTx1hDGle23IJYpD3hTT0CTLumqW78IU8dwcVTQwtWklK9u7QxTEEPiJfdq6vLz3Uc6AVIFWRaolZOFUG0nc9iTwlw2Zf9nYlLXDz/HBNBEkcup878NyQfblFICtxYTDMwcLOc7oMZg4+VHyOGNkMhifv+VkUn53X//C6CsyKksc6VFOvBCicPHNWuQnOlbHEbgdo3JeewesbVsn8ZG0cAa1vLFt5oMEb2jyA1HYYAnM0wR/0CoUddBmgfqBCxFVuXNvpKVcC1Z9BUdoPIMh+Ly1bGlXAspr2nVGIYLSZ2h2qyUtQj706K/WDHgHTJn/tfTOhv019S59s3KQUnB5DARD5P+My7QU78fmC5WZtrWhTC5x2g6LEQkKSgrmA9VUjyf3ekvgXLjGStbarpqJoF9IVze3QtcrwOvG5qru2K5ne+k8VlBbEbhvqL5SZRtMkD9knFrK/ol59qjUDnxRdLiBU0OdZBYWJ/h/zTIDgH50DLvgXo+RdWlMTD8qh5U4BaTvOcGM8Wz4eqKBHTqOH+D7/onRHyKDvFdHuoa0Fkz+xMbKOuh39nnb0X9BJCg4HakiRXGo3nSJ21dURP8gNz72QKjq0ERq39Bz8lTCI54I4Q+C69Mul1ugQ8qGIXtR+ipWzU5Y85OMmomTLy4s3m2KwkLTMkyfJ61TXp3sisjOwvyb22PJLCULtQf3hQ7K8gRWs3risvKyQ2GxbP+pGRKSyKteSNcAg+yafvEJ/qs2N70lvE6xzMGIVnV0PrBsogfkLhXQOv68+DgDxDfNfDKd0yu1LF/yN5KJ6YgajrLJyCVcQuvl6eFZIziydfEfilpxu7kGWSnhpgi5Mw8UF4YuP9arE4hSC+yrTqwuJTU2C4J20FRglxu2NIUuHv/sZvCnrQEkyzjYRrZONQ+2ClALSdUUk7LNiqZBRx6MhuH3DYeC3YW8T7EKr8G3rF7Zrm+tSWH39dx9VsqzUUOtCxIfxXg41fm69ZfxRRh1rk4nMsfhRN1JULKl0j0b6wfXCmZMMXLYows1D8L3zAAAktMWSaMgv/UKpiwLcw26KeuvLPavIqD+tlZd1P+nnKhxIertRIf6BhHqMuFn2CDCgOqVe8ddoC4nD2/oADxv0DItHdpKYip1+YpxW8Wvlohp6szfZhTeaPy1lvCxtSRtVSdnbW8t6gPD9sEEc4HOV4WN6i19YjSQwC1H8tgozTFtdoIBRAgwnzIFhykSqH4rDgsoNaGn42MRXFgfRrDeZC5LnBbGy0qTgJllR9Agwx7pXOx14ci2cNvhHNjRnKHpT0RphgIQINQdqBvEj6oxXu7Dp7yvbBKsacc/Ecywxu8eVf4F78UeuS3Mll5o0/jb+cflqK+eYtCb8D9kZeWwkfwF+G3Xsjqam4sYoXKhorpPNNMZAupyQVb7DatWvnoEAHS+JWbuJM4ZxtX7KSeqkWUiYNpZYWolRnYBRHkhsNlOeV2grfLfoav5MBK+RuFO6a/VA16Cr6eJJBx3EhlaDLeR+ElcgeIJhbj5To2PoelcFe1O8Y8pkqKvLJYK9h8bZo0S3mklmtIpE5S/DlFjzzEIk7b997GDpxssjrPeujKkndwxjbp9dIgAMgi1ur/5U5as/AoLh40ZVWuHnV045PVvZ+1Sy1/rBqIvnvquMW4aRLFalijlTPHLt1s4kaItFZhiHk8+Y9s1aUcoh0FmJMTPndinEMlHqE1ok5l4HN96N5zUIWHtlyHH68fXPX2cymLIgQEuBDcIOkNCOgDc1gmMl6Xua+rdNVImh1j0u+RbZOca7kSJ78XvYQ4gxZKDFy/gbj4jL7CfoL/1YwNvdLpUvCBN6QZ0v/nOfZRAS+vIXyZqobj4t3zyAOwgBC1CkcA0pyV054Kcxz0IuuMWZTFbjtcfsnOG5zR9QK6+/o5q1FtFwzLSheIyQc+4p6QkQmJhtSjYajPpq1w5SwicCK07fp2TE1e+RlsooOe9NIQrFh0+FN/XjA/ouiXoXwfBAFUTKauG1XjQ6TmzYIAocjBamKoJIj92J4Ip075OvCVXiDg1VyiQpuNxp8RT8ORch6Xum2h4d5RsyF9Fr6iWMrSiO1/JWgGMAX1FqAl5Z1DaNeLHRBKDU5zRZzmJLrWBn/3BrXPBwNOMKFAMwJTZGNVLv8xnuNbx5DLRV3CQiajxhL6lTi923/HEyWYUUDDkvrHb0BJRRfmG44QA1uMY35PANE2oGOlgqXTnQq6v7Wj6sbWD9AD4BPi+RaHOVuw33KqbfXeetSvzcW1FVNfs+gvbLP60yfyKIb7JISCnNTYb4sv9lrnN10+ftrSojHSLVPxzN8gtVfvVLmcvygBQk7iDr5iBB3vi3H6h0OXkG0TR8GyEdpa7h5INK2jEX5BCoDLnqnCOQef+I34szFJM7R8yEzjlvkR7+yztMcmSh1rkA1wDzTzCVlAyQ4a2Cq6/7zf48Iy4YHsX8u5BT2Gg0Z+Tm3GwIw09+M60Igk+UL9J90KTw6dlsKxc++yFnqNGyIOXT+t1UlAb7tZbyUDSyQv9xQRMNSHtknut7BWdj/+oS2D4qJknCMy+aZONckBBlpMmHBhPaNqe7JCRIL/IefvuozkMjQRJh77qx/KfAVTzmHfY1qT9ubZr7gHvu9W6CYihuuy+ZswCAc2+Q00zhsdFR0LF5Xf6xm9atxgqW42CMOmhgjnw4bCKEE76M7jAO850sA/2rP1m3dbduxXYiPAYGn5N873uRPoWaxUGBCUFtf2O0qiTufzMPvf1kh8E46nGCG5ya5Q1gIPF08tRIYWqo+6cGl95uwCt4ZR1UoIwtPGu64qBA6DKvcz9lGmGAi5MtlYMytiJxN148Cb7pJKB3/eku/VXO9z6ut4e4uPfDAsU0qQqpcOBoGB95WR/0+kLfvPQek8immM4sXXoSxU8D057OkAxxnH0btOT8yw8V5+mBv0tIFsaJeT4ta0mv90hEoKg3bq62AwamXV92PrPB2Z3nRcMn2nbfnv0liC5LuL0Qlc0H+ewZMR5JQA397GmpAFeaLmI0/ZyCI9jhhtrfzHGCfn+3Q5Snzz0IZvzr+vsLQPtgm9w5CC+7oHBsuP5wPccXVH7J5OFjjXxeFKixRxDy2u+c3nwBJ1BfFFMwiHFLvO+8TxFT7FKek6IXpuxd7I2cYKEaWoNOTFUSJvkGmIdf/x5TjAguPrHYQlB7+nwhCUbWpKY2ohCJG0El/pGK97UaqWMCrEOCQgPRquQVm4jV6dla3Je4MldHCuSrA2aUgnQGvweAfBEv3JUZ2FnH7Hq29ivomCDA3F9yxftLnRe8l7zp3pGm3McngYyPGDKD/+Lak8jwhW4sBFnGPNnEOf81B5lGtDVYHNmqtil2fSed3JbJJ53XomwwU486/010eT9IfRn+LLS4FHcceBUwMiesjAq9Ym01K9v/I0d5th2cRmI1Ft2l+losT+Po565iS2rNtyvyJUjQDE0YUBUqOl5hz+rQ2M8bKbcJiBRNnMnx9qgjPTXzv/juwRH0643oQHHbTbuC56CgxqnYNc3H41WV2ZmpzprUWELA7iLdkxis9aAXKbaTkTwP/pKzzn2ANy8ftKy4YV32PshoMxjABBlwtBa60OkmyNX+OpHhnCmvVEHqyF7iYbyeycaz0dhSD1OldVzKsLhv/W3wvUp2KD4BUwSsxdshiUj+sxS8ALCTy8jEK+UBwgVGqQ8OnkvH6Cc3vyil9/zEadaEC3qAOZ8kllR7lJoOn47Uh4z3ksNmmgt2CZemiB5VFW7fxfMzSifV8KeQkfK37rK5DawN3RNi5XFAK7FdXXMGJNQgLv01HdlJPENnPaFVO20tOcHntkBBa+q5TnsT1mAyMCg0U4NS96hX9CDqjuK0urmJaUjHPIPjqwNZUJuvH8/Bl1OqM6D66wQR0qPipkfNBVM3B3BL2xAKZgMYMWbhRJPHG5p/d0/vHQhbRFJ2NJpa5tW5yqX2AJkVlzZhGMXhgVNDLpTYzmhlr5WQaFtNK8zFH19ENUqV6yvEnklZtkoguBtEP8Bb9QGQkZ2uc0gwKOiU3FYYqK4XoGmgBqKJExqJ6D/kHGr/UcMH2BYUAaBwnqCAuhZjnH6TdbZapavbGLvxj+S72l1ElJAfYYhuHYhmHNjdqeNHcNpNoYkpS6KvrOKFEj7G1GaFesNDsH/ObkvCdAZsEKfdwQBeAfNGYxDRXFOPOb5WhT8O0XLoaPBkS310SKTm8z+k9icqwFdC25YPArhZ5g5C6e14XdvwlvAY+n25FiIQHxvGNp69jmZ3H/Q7QcKd1pDu6z1dTkuAIVQPcDtKLHID9wVR1e0hTa8A8SkuvEllBrHadF5gKq4Cq2L2pJtaXootSTq4jH4YN18NtEo/vtzplF8rMdUZ13v05Atk1vHspHN4rbu8QbKSQNYvtfJOd9tbGBE2Ipqyhe/+znWxYpjmFrpgw07U54dz3oxzDe/CAMbfIACI1QKN6wtEE4NSU1IQ/p7NZ5xjFJtoprhbqyG2+uxqiNaJFcQelGLCQTHZ3unr8gJMX+QvRgPAowd7lDBi9mjSDz8vGDmAM+XlLrZYEruqnvnSKRDUTLPSRI4bS/EeBjy5mUSaEVPiaFOnDjs6AY861B6hU3lqSmBSGBRlj6wE6bqYMfT1zIUHo7sQTmA4+lWSTW6Q0FVFMGJZHcmcKnVYCPsjURI1EyjIIDEE9X1AQ83yn7pbdbNihctABXFa3TeI9Me38kZLvwaZG9Io3QC3dc9gNvUG9gDYqDhO9Yc0kQEbYZ8EjiYyYS9PCcbzCZdrlyPy9xiZ/BE7zhw+9c6FiJek49jRi+K1AMjWIEd4ykAUsqQ11y5AbXOZS1rm46ksLJnULBMhcLc2fQO34jdpCUEFkPXAL8vFxpkyduQ8ZebAtQQ3mmuwbiuLIany9nZQAmQuzQt8ilENynfKWo98XlwKut+9H7CqxpWWAnZgb+p6EhYKxw6c5Q8rBkTnrBGAoornqDC243kg9Hjwu4kWQB7ylvYeAX5RyzuoLFGvaRdlo7KubOd36wv/bRWBS3OOHE3oWXb/Z5Cz2xjQctOjnokG/wuqeG3lyaLTHI+Y6x77i2xAJkvPPleYkPI63q2R54s6HLCPbXQNc3n0XXcAEf9wffxt0OwBT/JyfFjxFVDCKQ82XbeXZv3mb5/GkSU8Ptu5OIuHnhK8qy7nE/Jm+VynbNr7Soezar8dB5sAy1KfHWyMFAaMT5hHg1z/e4HTgQzCWbZMRU2jI69lcU1H1LZRt9w9D5EKPbRay0RPs8hZfhAIprrKavOKIg9s6nlT/5o22E9HUatTJJstuYAJaAH/knULITXUPHF68IXWbcjs6EGPusBg3y5BVx2mQ7fVz77iaf8hGqEyNmPFhUP0xcoO7AlHDATEZ4HYl+tDezZ1DN2DCPx7AXumWJCXTgb0IiOVnhf8gNMZtjV4NMDXqL1O6P3m8JOn+RoEzKY6Dfz6y5sgBuWMzU9Nj5a+7ZGaBK9wve1/ueWAVw6olyVCR0kqwHNuOc+0yfqljpDP0J0bRG5mCTQ61x+PCDAc6r6U6BUg/0DPu/gHmQPAwaqF+DHgyvO3S7zd/XuFuIQV5cH2iICxFZTjoh6QZQ477YcQfgF1cK39ixf2CG6IOpt9BodqMeZjdf9wMPNFhQsVpp7tBOTGOCpxgTjjgMpGZGQKMyG0Z3TmTp/pcGuskE5myLLDbFq6c6xGOqD4fcwLj9KzxFx/E0PrhDcRVnOaU9Hnu8gFRv5FvSxPjTjxP8/dm/4/rmL3G7DM++v3sow50vKP0aUA+h36n2M8vdJahiPttZCJEcVeImmJm4/NbKQ5objIl2gU8ylT1RD9xqCY6ueeBwqN/cfPS7js4bv1Z4bDzD737xK0oAWtQdpbgRfBnXO4726tSgs31Qd9EFJfG+IYRM/d69Es7c7fCm8d8+HTM8t0//09jRqcMDSI+0B+hGouWCtjeA5kzekmyrGRv/WYpWypolvsJXjV8b8WMZoKr+7moEZHBIW47pssjtEksDWXDBWwxoigpnoM2lmJUZQmsrQwC00fjrxq4IYwY13V5OUdVmEQ8XWgcCS2sbnd6w8in445m1E2CKuzNVCVIji5D3utj4CZ+EEZcangfG7Cx1eW8FVu4uCZIOhtp/nop/LZSpUBH8rVHSl4lC3C8TnrDy53emvsh2TwBbC4Wc4E7fY5EwDYmwcEWK8FxcRoeWy8ivOKHFuKquS8u7YbGMhrI6fiiZGx3lfukzRVL263fKnAiST4gQhLZCp8cGIul9YbmbMM1exvChVsYXkn7UgJVTj2pfH3UiAYfWSCRPYgRRaumd0YtJGeLbTFUc+9vHrJOAW+IG+CVmGHLH+T2i4czw3J/EOQr82ktp/fr7JTKGpAr7y56jRzo3wKc18AUW0hrMUQ/x1AMrXzDIlV5vEjl7x/YxeSG1yDdztef9uVwx3ybiNRL89+3mmbu1jEAXhEXd+UHMooyJ4dpnKUIxCu2wKhMuG1panQzYbJwwqN3h7Sl6oFx8Kg5JC2mxv3kz/qZ3zz6S5J062vGigF1lQhWM4AfcK40TJpN30AuUBPiSeQI++ZFBJ50BxSkLBm1XT51H6puaf23EIMqjjZpcdOLmiy69ELTcGJ1dWShAnnJ/+LHWWLtWPUG6yAjqmCbujmHdvGZImlefmBfbcWCntvsfcjbtoZu/71RMe9c4bTPAhh49Qa8o5CjDkidB+h7WQk8e1099P9K8hz56d+GaJ6F1JNWlfk6SqUYirxiACMjQDz3PrMhdp3eQeOA6weYN3YLyey00UPzZIvMO6O7CQktPwTqGUUl3Tchw+7Q7alNVhz/LQNi8rfiad6iqL3vpmyscKpVbfbBt7o/e5gztYgfk9C0rqp67K0vhzJPONGBQFW/TsPUh/pRag5Otcfa1qsx4usYAjlbltsIE1aEgoBLa8Di1zqcsTZ8p8Opx7uywboPR8PU7ymcQM2yyuU3KYFvISw8d/RQ+hiMXBUSsY5+8rBbYPUEpXt1mUcHiV40kh3s8ZjEdoPxJd9zcoeJbB96tqnYmxE4n5KAKQvstoctUoXzUdC4zzbXuFRlEWJh0f0lWazo8AZqNI6VADrrTBshnO/HBJo8U2NJId6CNxSVi89fXpsukzkUdv+/PVczyaFOSvGx1HtcH5OMctbRdxvYYfekCt8Js1SLOi0T/nzFoNQSNaAe5Wns/pD1tRFf7XdV3NJCvBGYG3SYdwl7JpbFGNdwKYJCLNZU06H668qilwZ/4psX+2D4k4AmbE89FpXaGoP6g43hl1RpfWEdcFzT+xu/W5V6szJvoGdR+F1y1obMP76HKC6sAmItb1UlYnYFgkO3ycJ++06ner3tXdn7UEtxxroYJQ33idQKn+80ZrKY/JGhf9ySRyFlaX9ivf7IJKQlBFpk/hQ1ikFfPSM4zZBQCeI6OJ4NkycRxRR2aMhttuAhGvpmOcjllYAsdf0lEBnGGxbycZxvRu4Vzugvg6QxqlfVPcihLQ+FXqS3T6u5V6fF18SctqPcptVPtPm5gRQ9W3xUR9fAGkesXeQ1O5rSQquIW1oXPKMtWFFInh2q/rw9dL2abycogy6xyQkaQYGc7vdMSWUefgqfV9W6U/q01G3E1cbp1w8V5DIgkoq/oiD4wo7Be4zVCkJlCNZCA3H+m4r6P4NfAODiVSOChODCvK83GB4N6HnlttX4C20pb7Ae7VEA5HVApsIFO3L10qhVd0YGt5960NG3YRJP4L/85fBZ4wF4w/I9PRAHbubWFmtjVbwq/fSHQu8y8TwOd0C5QhzBiN0pyQ5d2KZTEb38Cpon1IZh9vOBxsLP4KxyKLRp/HDMtoVkAY0vnpJisy7UKMr4FU5K+/sDAyhdF0xtV9qrQjvnRWI1GtuhVokjpFUCFfjIatvRomh7TBdB8CnT0W59xtAM4Y8yeW3Ab7tGZjj7/oqsc/j+B65A/RHcAjVDcrboV2H0K/s2R0uMg1aiFHRnfaLj8OU7CcjtoNdK9K0J4N0/DG6pb0bvT8Ln1wZ15u2qDqTVu+odFHKBtirSKIbZyPm8Yq1eGZXkDABbf6jeJ/GK+vI5Gttu87aafGp7sSJHoj6C7fW9Q0Z+yYEx51i2o43R+i7u3p6GHGFowbam9khkDXGWf/YR7YbTUbsOvrdtkK//kYsjxSqdo5+wSzvh0xtNsJpUydBY+0Vaocd2l6ftbWeetE0gOjBbVhit5PUwqTkF77dRixh9QA0I3IpC1H2sXPxvFeySeljffqIjWY48Otio8g8srlEshvsuPLMZykLpOf4w1lMn8g2FC4lN7vclof+8IGKh8XgUADmfpEGU8R5vKSahcQLHAMzFNRYTQ5wmJ2mSwI+d+/iwn/y5bs7s2uxdXoIqXObkjvgkLa9dO5T4tVZQHw38MqaXyxp4wbiYoehy4pjy515B2zaKh2mA7Ap2sUbp2IOCrnz+EFyEiT/aUTifnV3kJsqkEXLa1cFnFZn7ZDWZC5CMFRO6TnANqhrTqFL0LwxQEeM+odgxnW9/1t8YTZFgap0FSbrwQZqYzf0yx3xgEmIhsIoF2Zu5W43Yfxj/l1CRJa212v7vm57Jjn9Ho/9TFkXsZLQ25HaArMlAA8qnGCYWOo5v6e4kTomgJOZIwxfb0TCeJrBEu7PLUPeE8Y3rLWBUbx5xbG8fee3ttd1ebU6kRsfc73EEVTCMGx259L6evq14C6Fv+iPaVmbdvQY6Q1VUBMEaCyhwvBDJqUgqtF3WdcRvdQ==", "WGM1H7duge3gbrAtG/sPo2keukNsyfr8u/7tviW6SV6buDAlouvCJ1P6cXmuFVHfHbLiR0pu/w0Fv9db1JKnZnr6rSe+8x9X9P0BC94jO1Ce7pkqe5gKnTdye72GXgPqPtteDRb23DNORW/JnidjccPLSaygdnT8Z9WYijy2ApA+Zcuy8Q8txybxYRKpUd8Ub0gtHRvrnUXczVFqqrpqtAsfpx2MoG+9CB2xLuPbyYGI687RvdM5MO+6J7tFCJ2K5mcyDGHLua+yLW3pAXzeq1H7SXXASXy0b/OwsxD2pOpc2uQQG2lqcvM/s8wwFyysnoO1ELgIP181BDACq9uWAS3sC5H6s+GzVZQbk5knniDrEpPqL9aGD041656x8bwgLMsQgEA6hsQ8EmRWYt06/VoQV9AFfV+osM1+kLFUIflGCi4eZH9+RwQa3vuUvIOR5hogzBMyyITXssALT+pypz8s9YA=", "gx1Jkvzz2OXDgKVaTq0Dbk4EktbH04ie9UbO2p7HI0L+rpreS8KMJtQZijB9TTAFD7r4cKTOt1dzYT4j1AYUqaSAxcoxyW9EByC7bA5WClZMp/zr9Q1b/8ZApKvnwohgcU2Hlp0PrfCPwdD1oCzSUOSQ3WXuofucTQObe/stMxG8MdzZcNhVrrE/4pbyhsRvHvdXmusc8FW9fNOUCAYYtuOWKkUAqfOVWkJqKRgp974WqO7/Ln91VzPDEPR/SRfgJvMvDaRBQS7GN4FLLqLM1XvsYwxWCIx9k4v8b71N1FU61LqFvFw4/TSR8CnMfBL3YKvht1ckCL1D47sjT7SgpzaY5f9CZrGOyjodLxjuiy2AvfAkIJpfdX/uexo+xdawmg8b0kOrAAHWwykeuAZ8CfkqvBehZDi7n7agjHYzOV5hLTu6ClUoI+u+15Ep0KnjJNdfs4xMkkxVhjhzv3TvmkfsB3DbyAshb4PjQuNsLxYkVPuNBIlVQEKk3oxad2aa7z+EWDS/cyElcIplH45jzJu8x12NDWIB3m0tjim4goTtDBgIJGuGPXgQxwrs7NSh7ZIM+JXsuJEnD2TZc5jQqm6D3kE+y1Scqq1a5EjK0DAH56oHvmMTjxFaonVZrZ75gGRs6EtjOe7hPk9oobWSBCoR/Pv3hLuW68UY9PFhJ+wAT+oijPpgZiOw8DRHyJlHNICSuqNuQqxtIg6MDm3YpQ==", "gpHeuxxRzP647ZCTOFXcPORXbRIWfOcveMrsVR5+jegSbwpuoOlJw5CtTJTxZbHabwYn3+MMlInKNgmaR2Bf80iafmXiIag1aEAmZjS1rY2rfawgyaC1ySbl0AaERJ9PXVdAQk2gfliOYv6b3/EVAUNVoNwRsp7xK+FSQwGA6mwHpOsvc1lAMFvzP3OCVyME1tScR1b2Ia7cSYZCzW9Hul5nM2s1Rxxgp9cPIa0sJ+i9P60x0zYLGhLjDIELcl5rO/Gx0PRthpD8sCHMGVKz2qBXFeYeUkdmOMcNdY6UVIZnMfZ5AdfaI/lEkQ6pbodsVVqpYUj0RPlhBC0VG8fEgsEFC5pWcPwNj72uRusmWh8zO16BO8vROlfqHvY2sxoyM7a4//D3sDBq77Tu6VKV+xehVsJeYLIRB2IprvjFxIBtFLdTYd/vBFrhOlqz2WV6pKg7/SCnQCoaqIaFLuk10D1yHl8=", "4PlpCjtmwCcId9zat+Aj3jYljNF7LHQChrtcAVJ79xHg/vZ7qNfrqczG6aOxvC04leM38YbnTggfwW8QlGqXuWiGG9+firQvL/WgdPLAHJk3Eadx6sCjtQ+O2vn7shfL7kbc8esPOIpSzIZZnk0z4pYY2+BKrjRPBkd0BxuzV9OAiGU5X3XhukRT0Rnxln0VOd4QcVNg0cnLHuXlimb/MtvkKX+Sj2M5mUvldPPBaIsnPJYqIhMpzOyao+N86DR9g/OBprVVt5BA2DU0iPoSam4OfJvoIamB4yVXSt6Xu5kdIZdfhUDOscrDL/NBr3ENwAsnFpCtHzmpyVWVzMyTalBSpQqtraj8qIvXuxKHAJW5Qr5qn8ThMnsq4hIIVoN3R9SLCRihzU0hyoYzW9LTUN8pXm/uThhW8oww6rWZxsyoiOL3zaTqnmk+gI8AFjUH3zhyPHaRFgSoB3UoXvjRMMhE88fcelxeXDRSlAWErlWP5ZgW+GPVZ/MGAexbtpLxCuSlGkW8vnVpKEaSPJRH2utMhv9JLggkm6OVOVlzahDsJculdi+CMazmT6LcZsgDBj4Cbbp+Z5fwhs8xo/FKbFbdL8Px0XZEMtM/oGwQdXcSoOPNG2kU2mi1i68NHgaoyvzKGN9dUfhTnD8bmECmYIEPO8On4QQrJP2zJXNn2DRBSnn1xhwB8CYuaWKFLpcwsg8zFhzGK8DJSBppuAva4jD4cWHbLivGnojUYsExMwftq+qZxvdhorILQ/FFFWa2MWRO9WZynm4N99MsX5zuZSR7TcgeD4/YEOqMEpVRWxBCzAf+Vwn2q5hF6LrnQlQowd+KZAkk4Kj9mX/LceOq+e3uLUxH3W9mTaskl83++qdsskysDODyF6zPqHYghPmthZQ30Ki/SZMvg//RkO8vA68hQvQqsUTwLUNaZY2dFkpE/60da/Pn1kjG/mFDRSFZACsRsaNbM3AkFiy4tVZrjx+eds5WBAVev+MsTeSkRn/YL+OanXITDtFdJ+wCK25WwfS46LIUI656Mwop/N0R9rJq2rByqIQIUWeWfUl3wRT/iQdqI4czSzj5wVNgoGtnM8/CIIL2B86goiQ4RTsUF8OXAORlLs3rn0fwwRr/QbGgiPCDZKOkWoxKx1VMwj/T+jQYJ9ML79uPg4TDfKkynHgiG8sEKTscgCtn6x9uUJoOY+86JRGBCmWw+SmP2XPY8vpVgerdx/ZIIxxF9+shJCSPniZR/mQPRSqjK1MPpIi3mHpMglNNI+x7zvThe/F2KCyvDgCB9xE2DoQEXitoArJUEiTt3M4wSK/ypifqg8XoET6G1KfDd0a3Bx2k2hXcqD0NS00ZdgeakjmiN0bvEjXEdPuxYVBFN1b0RAJUT6Puqd4Y+AKOFxzHz57TLl0V8DqYa0MAeApK2g4JwbnIri1RvjOqAGqFGo3WCkqljKLYEYHhkLTyf+5dd9xjtZ0oscDRQ5jHDLkq6sPAEWzEPUOfQ4xWXb2lqkZstRmYJ/4RBTuYVEn5JHR6fJkBTZIalh6T/YqAK5zLHRjeVTfKbhpexJRG8Sn7exMAa1uFQlGM14qszDThEFhEWl44PV9kr7Q5OFPi6bs6ApdC0hNdUO3du+ee0Cp7DPjpG78uUHCYOztPHFtVCyB8zeT80bhIbWl5/BNGPMyox4niyhnipEssH1TP/3/AJ38k/T2Ibfpeg2vtYrSh1Z2h4tpzC2eSsIfDaBIHK2EFT6QOc658pXNLPrpGt2/QMKwLl34/q3rHr/6rCsvUnSYJgp/YSN/uGbUyBCdktjFWXCt1vZ93c2sXqMBcK37l7EMKlbD5HGIoJR2+L2OYcH044UYd0n8K6CTUcg0BrmdJIboINrojBrMkyrNMU6u+Jj36IFUgdjTpeTJ4eqQ7pDrXpF2Jadgy73K+AcDJAKoghl0bNrU/v5tMurLvZutMR6UaUlKjXRuOP4QLnZv5oA1Eigwhzz3jOqlV0Zx22XYaKYsNIwWJt5s6Cu1VYXaQ5WhPrOTZbcRPWUIxIQxgt6Y0ChsndvkUjXlCP3ULdgMsldIqV1ssHqjwCqPm2yQ6j5nD3QQx7l35V3G2RdCb1yhH6jBnpI0saVvRtibhMUUX9Q92GKqmbFnBnWH5snmblLalufL2l+e4lelAEp9ps3ISPhUbVlK1++AqG6WxLgSJlMrB9fsAEC2aDX27evEsFdqsa3rIpOTn0WvgpVCGpE2p4qfUhocUNeCeEOr/vNQXx215cVYFvrvnwwdXKMRHCiTA1bJyADsOR4ZaxpYNpoT4skoZZaP+fD4kaQydZeqcfkx73+B0+hxhhT1pSP86DmgeIXJ9FFc+3emPCYgjGV2cIU3VMq1GzrqEmPyV0uDdTR77sCWx9LDsbTQzMKIvqJ74KrCadW61awdQuqwNOOlKn8I0l/Duigqe7vIAc3/JHQBxOkUl6Li0FYmC/DAeiHKuINzPPTeVZpH9XSjcmntegHwG5CfL8BYfZii4znru7Jk/CFlpMM+Fk9nM6BdAWZhQk41BuujBqLnKBgzJ97q0IU1DWXI5wmT1QLTMitWVPC/nT2CsbEQyXqWSVV5bq26A7OdaPSGU+0ek/m2jkltPizno0+GM2VeIjrILDUEdYiIkBQ64BGUSShGDO76ep5nJRAzUqjl7RqMciVuFxmZacrnuznn+hbhBxJ3LjaqyAH0AkGEoWS/xa9lL72RIlrwpN2qDvd47xvzNPTguhV+cde1f3IY53fWPH0Ys+xicYxQkYUzAcX72jE70f86xLI4vOP2oeW57Ix4oyZhPY1jXkRma9aU8vv0OpUTmQj/MgTtM/XbReEZ6IKCQVGsX5EOlb6wFjQ1nChUlTZUSyvLJkdEvY2esL5pOe1Ws7mnFoOiNftISdmE3wpDacwYmAuDdH4FJo+zrwB4QaRfpIvi00Tj8dBnph3pL16kejSHijEZXNPDiAruz3/oAlpNNN2aAftd8kH4qHKFn7Y8dmF+wMcMN7adRbQjqF+pgWZkYaMwIOgs+2Vf/3/pm5PRn7LvC2qqCXw3Gtfbn8rR/fv6Ub6U83xNrtURagb90u1AJEvumAA56Be9ET5Vw3DHbWkEu4pEaKT+vdvQoyrMiQkdgaRAiF722r3mbl7E0ocaiEpQj6izmQQN7TiOt5iYknVFHbuL6XZevCIaQNKlW1nlrJVP6cMTSWzZZ3vtnJmt9kHvGFVuA8T3ePhsWI0nZh857edM2e6KRqmoq+Jdxr6BkpekVRp/ggvmZj8q5DYW50oWgslKpVR1bw3EEmjktJHCmytNO6jKsdkUUfWCNkLO9f9xYSWgVMF0iHIFZRh86bDeK7LRlfrJeUguE8cbfXkjlxriXNgDvHhlQMnthXwjPAD1Q8bMdlASINMQ6bnEadHKBU5KiQkiJ1IZ3wn3CScIFEA/DGtcJ18kyykgICb7hAEwmjtaIKQrmGxm/Ix4X7h/9c4PFcl9IyF9NvXpmGuYKJHa0TRem0AX21sBpfQujxquRPb1EkUDHVEJWzFfZhlPTfzf3BodZ7H7GZCHnN4a5WCHObT4ivmlapjFXDbPFqgh2fyDTXQIuuwcCSSqPKqTwfFjSEV0RU6LiUxSq7RwKrVPwu4LTR2lFAjoEXaFf+VZ0e6Qc2RaIyc9NCFNs1IlyWJaYcIMkuEwDrgH6mmuqmosRSodWUiIAFY891X0LgwkR0sKO92AimCvvSo6ulDyXGCYa3CGURt4jFAfjmkyWgzsZ77j65ZM0Sd+jC4nrM1hjDgei4DnbQe2esEg1JilsJn851QqlCLws5s/FmlDIffFA2LjB9wkgeP+xT65J36qPbi3BGvWouqHrsoVEmlFgL+Yai+MJfHXntrp8tJrDcANLeOH6bL+3igeAwz+JplcwRP0aOTTlzvg7RAAGXrKUPnKX3kjrLMxlwqc8yaFvaXRR21hI9Yq+fRvcs1Q3RqaAumXqMs9qlAnw1NOhiIONFMhn7BYuWep5/QXQAMjTfYbmp9gsqcMeUsEr2M8ZOqMnK0Co8IKPuC4eMvtcZx1dPiW/RZhfoqP/FTcZrINCCJVUePzVTLKIycDbadLV/zAwXTi7BwU2EOjN3GycqlYt2aMUuJkcwGMQ/D5wWziLCT4LqU+KVYddQ6UPuVNjPulatNRnDFbroUmXJTReSZ64Sp+a65qT6Fk2+zUNuF43yNXs121OEoq/AL5ZNg0NtJ2RiJpm+Uj7sLiSgR056gm84m5LiaB0jvDkYWPbt+2YJhuSD5Ijcjjkgw8lBcExMVK4Jb2UM8awJt4ZZJNRzJJwI1rMIm6cRCktkAFTUz+y9Y/2XdqgOThrdWULJ9rgGRhwv+A9wEjDCpJGFYsREA5/m1NoVkFInLjntJKpDS8bXZQM4WmUF/56AaYi+VVdp16GzUGJ2yLox//SXbMAa1fiQLIB6huqF1CEuixPYuMnMpyHxIaNqIisZESpqfpeTl+l+wP7rmuq5eJeCiuRD06fr1EU/Bzza5Cnl7anX7B2fITT67nFb0sf4pMG7PUm3Ykrxjlxpn/NbETvJ+Sof7TpfpOfGQ+OSz/FLAjQic/QegfwXymAhCJI1sTNkDuB5QwbpV0M64wbTUUus3ByCiKK2ifIlTaGiG0jXKrW6dkQFNTSh+kLJk0UUSxk9a1x/Vnwg6awOBjR0IrLOp+XSdPk+0K7LGv2NK0r7j7o9nELDGYx+w3Z5Uy27Oo/OTMsJu+vqrf9TaBeOcW+WLtsW4papw4TkXNdIhYn2DhS2GYp29slFdFvg61EFGqpbvKtZLSwWKHOCRJox9lZDWxShllV81fkHL1JvG5oVFyevMGel876Scqw2KrCM2+jnxYt94F5tb20y16b6O8M8A8fHwhCU7trjNxuAVBr+2pYPOj7xxOADX+oEIZuGxgsqyvsSCmhCEnUFtHhY+ZI2lgnnCVweqPJY7AJCPiOAQYXzBY95TQ6GfN8lTbgdh9r1stVI7Pyv0HVNltKaaNQ8LopW8RTB+CFp0B79a4r7d4DcyQ42hsptyliq7OorXyQ6SUPpgSIM0xNwzfF077yOWgPIoJ6UGfBbc0OQrmRjcrHmP5GZ7Gaf1ta7fQ6RVvNUi24RZ0qz+YsQX9wlmH7QH30t7h11qsHO4AyAPdLetZB1I+zTtupk4Mp/zVRLA7FLwMdgVFlIqEiOfjqgcjlgve/AgPRZvj+R0eOBGaKhmNTOrMJoXKV2VnWo1v4yvWrxuHz2HsT73nPjGMCQPFYAMG7K4nHtyskWX7qh7asrwLK7E0IxrVVXNrCzSIM33XZ8w84/IFZmZMZXNUgHJxmYZ/eplH7LJIIko0wXt6a4ZrnSpGUrKKc1kO1sekxYklRCCxBZkEQTK1DhaNA9aoM5KsU5CKl7f23ICg6SWuUjGIC36aK8s9T1shzLbWVA4CgN+sXIQ18/3zrBvS2pEb05oFZU2nIkGbypXwt7O9g8Ut31H1mT0W/2UOzTkJokNTUfqq9gI9nAauubAmMa3SNkr9JTsKJvdkb5wfYTLsTuxIn/2EjEL1tja9WMfOoMKNXeNuDVQrQzWaFapHZvsvmFpkg2XYO/q/7lyK8gPng5lhV/r877kBqe5Awos+UrQpX+CJipmp+LKm/r7PFgenfjp8vs5oIP/EK2t8FF/Zzzl58s7tO7UIRHQXVqFpG0QwGcwWNgwzlrDsk7nhsX2d3cbAJzraaLoeD85njraSysHfBLWZ1XawsMBBipTSE0r2A5ifiMkmqWCUqbf3HYim/p9PEanqcKfia8Lhy3pLosKDOlkPU6nA231hrVwhCP3UYo1it6mbAmvPGpNDA3jQOLmLvJoYlRHw64izeMO/84VvZRVSyAAaLcEkZJaT/9XIyItah/aFMBc6Uk2Q5fz4zB1/798ImL71Jp+i9JWOIwZ49QTpkca8CWUil7SR8OH0jLS3a22Xzu24dEJ1Z6Lga7DvXHqsvMC7kLE56rH6C2Uv0WYQvIyvk08/itOVcU0gPrdbhIgCE12F+Iq9BdDy2GrVKcqhmnZ6BvDK9KqX2IZIvkkmqFx1j2+gV3luYFTlAjAMdckiKMh2I/g6dDLBWPKCFdCaaStq7IOoqCRLd6G6jOxPB3jWNuLGHJ+a3miP/P1Z+9hi/ITLKHE3VwwT28++5aEtRqrWeKvPn6VhNgf5JC5MIWEPvryihKazK988iHhKs17aG86vDWGF7p6vdWkfCTa0xkXpUEnrzJACnNkrGxaxxJHwIGjA440iT/C6wQVqN9mkCL/3w25XrMrRx/VjzgtgRkntfTqiYZbiravC+qrU1VCg0PhZSAy7N0hJFfQexuG8Ecs5LHA0fS0GU1oA6HBcuzYQ5p7NaNecaZ9fTKIX3SvKtsdmaRmLbbmxH9Ap2yzqKrkboV31Rb/5G7c4l8udNTvwiGzzaBpQtBJVwoZju+8FskUtRnz4YuZK5jOmisogKNeyUS3T9lZhYMZXYUm5zRbZsRJE8bA0nbqB/AP8uxr7EBTd78gAQIwVXWZgdI6RMzkQXk/APMdoduB405lHMs3hn7Gi/rPCehm1ybGxD+70akRfPN8qDKbVhH+BzQdFVA6b3ne0yPYRZsqioaDFfUpkxhIYvocvPZqZn8bbNP5J20PPTy9YNeb2+venXtL8ko/pRYIGOB8OmpdUMIH/2K1mqk2xCXq0/xv8V5Zj+1bzvisS++5iEgRqlFtPAMmNMvblLcWtIFJ+p28KsXlRQ0SS2qfSmCk9MfnIg1sjvLms9pCxSHwK7ZVGhEmKcoD32sQEIk8qvLIDPJeTqPwZK8XRbeK1DCCjxretzfMJGjpYwA9pA5WGeqCNxNgBigAq+lPtl5ZkvBNL9wCbYx50hRyYSUYYeVb1pwzbXV12KXs2Ah6ZHX8opIVW8Fvfo18fdJvEDSLIgBMhrheTuNyfu8CWLjtsncVUCFNNHHHSbvTFFKBmfO/oNV2C4jWXEy6LMQZGTIqRO3r38g8nXPF5yhlAo1gpkCkLXCARUhfrNeUGkuzcv5naeEBLf8s3kKuFY1Bm/CkZOHiF6xA018W8BZyH8SGtVLPGQNXR+c3BBUqBtPl6eXusgb48O2z85uBBz7B34CzrkQ3vVZeOySBDF3Qeduw0L2/9eQXfqLBxOqr7rHWDxVzjhcqqV1NKzbdEQX88pfQM/oth4RWv6LaTG8mFOXYADsVQVdcPBBkm68OJtGNz1QOAL5cgrIFDiCSOjJ5hLZRzUwYpRRIZYQxYBLP+yStEFIWiPKGxPIPWpzfEikZrylMwjiixW7BHQEUi1lBNm3JsIiEhyyoQMv+DH5w9213be9+MIgTRucMC+s7C2dqKNo2OSUSnx4Fwds4enjkPZJdYM0cLNJKNQhTzJ9yJyZ0Xv1Hy0nl+5eEILIZKtc+LRzHAwM+BqxTDf0HAbruRtKETnQgxIAMKHwcifjCEFEsk2giHY4Q8K9FL1/yQBVQk+X9q8TDyoUmzUtrYQmaRem8RGa6R8o/6UeswbxTzhmiZfoG/3wRK/aOCy1ClciHN0jPVNpk93p0oNZu08rxi8rMLV1YHfOdhpY17MTQkLTlI5ovZIjn88EwOSpKvY1pgVUhq5QRf5xXQYEfSeN5Z+FCrecae4fTMpQlaI2xxqKT88iP8pdbBL3F+FVRjVgvS2IPhHtLTxjCJHsfn89SzmrM86JDzyhiDJ/VstUoXfyJ3JUjHMNQdLPsfm+9XuZ4yKn/is2AVRW3VpRs8U28h5OQIcV5WdjVAwcP01+VlYTP5nszxjVID7b6KjKW9PrYKg6mFU5MMOjtyuNrgxQQwODVdAUVvynLIGMVmTK5Wd8f6+U4IA7q7rkB/oDsDmwesuzzQGYoM+ZFHKLG4YA4y5eNGT0n99ygcgUOUckOuXzdln+h/pJjXZ9388CUTNO560c3KXv5IIGyRq89dxUwfw/0UqLOESuWIqrnOIq7bCSybDaSCrWnG/oPc3D0qCqdZ2tW8Jax3vIVEuNbt4SEJJsq/KYn/7ddkNgd2QlAT+CxW/aCnA/r2hpqRlH/Oq1t9eS+utPGFdhut9Fv6yplM2rBRZgDAYdwWb+DGDQDzNCUoMm5xwQD2KtVnS0rIFsXfPcjKdkYRWx9cesOJ1wpnYz3Gzmh/nVAF3Ww03ItcCbl7XzUbA0s9+66uv3948cSdz6hd9k/i6yfTgO1sRfqtkIcPZlozzWnp7L/+k4hUvKBTyDOm/FssKAlpskG1cTsuPOvxzAcJpnyP3dvQiEig1WO7R5fQeckgzfxIAg5KV4NgGKDDdK9FdjZO4wsMbYvMij4cdJiWmqRgI/3VNRsO7RYXIa/PgTlfY3IAT6LWh5qpiZJk5NTXapTrpvav51t6OT4ihu/IuspV039X5HOG96cSBt+b6Eesg5HzAj3Tjs9WtS1ldXWXX1Fqz9NurMwSEBhofPmygkhg0slPYXhOux3OXDqESv2OHEflzvUPETvhW+jh81kKoKwVnshvTR6+2Yg3jWOkl+IGWtURjUXSzAjPXHGl2uFYGYFvF7FU//kucTLwuil86IBnNgqLz+pgmEh411h88dGuCCChmvcpfhPPU0fEDHW0aAkmUd62VFoFNQ6jfMSijG+ni4hpgztHi7+zaj2PyRCSN3PzwvS9SPWXAIOp/N3PBn3t5hUSDadDuq9ZL0M4+xMWq746wG8CxlA4b302F6ETJ7dvOFnWOKPmPCnyuBlPkp4lziN5mptzJTfN6S7WLX1gxJkXOyUNmUbuiiT9VaOFpznPtgkj9Y/jQwsbxq1LUtIcqWCckrASj5+wyx6I/iXcFFGtxFena4z9tqFSiA6jrRkpIX806YfektI/VKRFGp24KIqSu9qWrAPjE6NaKwiXZYdfyVSFNQ2gqrjjbWmmpNLdP58LoMgpyywnArO78KJm53CSCOryobVowiKJFB/37u6Rx4alqs9Xj0GSc4k78O8wmkrO1xPaQyceJbxnO75bToOoB369QLLLgCDIAMjzla9ZrfPDAFzWaM5OO14c6/h6OqylgkLIVszY12T/heauAKFp+2WXZL2d+/XqigV1oBlK5KdH6NkHFlXZbUk5nQ9RXB0OY+4VPDLaID3ptwc3aoaOByaJl1t9X65EkTOaDII88JO1W33/1j6xjIAuNJAGlrj+QOlqatU9LzzGNKF4yjkG22rqtYQJSsB+mcj7y9H5RrhKO3weVwXTpznhMIOJmxxrrX3M+Q0vprEk1JZCYwTvHTn26FMVUxMz0/MSlTrPSJp7XK66ZdWJPbVdjD3uAWLcT0Xv+mTEe7tIgzz2+5lXQ+QlymE8lz6jOvRKL8eR64V30IubePhN7UBktqOZZlYSpa+mxq92+zia19S+nMkK/+6eZQsybbPsrJTJlw4eOR2V/KHplGJpD09bFLPocx9cqX/Qe6cu4biBOAlDEHnSBBDVc6S3Sl3mPFj+p62n6LDoXjNAu3ZegbeDIYpSQwy5D1kzBNz+TuH88XiwV0AcnaD6jRA17fUzFHef339h9IkfWqIP60EztVdErALR/YWILO+ldHDgPQT6uB9AbpN2S76kI84L5ofIwVElB8onSYUT3eEwTcNbTzRlLOlKtMUURZJSHGV/4WNm/MbvF/6t/0mDtGjYUAJxW3SKy5H/6EsZbV+5JkouFX0QK3L4HRzCI3E+bAm89sSDcKOeCWR6l+IN5i8vHiaoPK/fNQs6NQDxmxgiOErDSXrU+7ICOGlGQKwkr5Cr/Qyiii5iSvWPnJEiuxZpxKnJ2xtFLHkkVUMTPYR4f5x7/Pc1c0GPkcZdFKVKPOg3COBm+60NVuZltWV90jOA4KInWHho/HGLTyirtvI2yBvTzW/5nESAdHt70kB/Egz10T0D9paTQ25CYvcBaI9t/sQja7r2KsArzxxagkUHo2lT+QCEgAiXLXRRcmc25IiH0ANhJcRcYW3z5q8Oc2dV8emWi/EdpjqKFwZ84S+bL5fnIAsJWQl2F1Wxy8zwPy2ZMc4QJV+MhQUVRHLhfp4V4LqzMtVWBNIhHnI8s13lpVYaL1pL8YuKcdCsQzLWu7EjgcKkBbmwNaMsRhF6sjsLWzFnLQ7P+Ix1dvrz6o9GVtmwz0j0iYTvdIeoGjuCq27qiSoPBjGMteIqYu6e8EwblyqMvz5XulqWevrB7SOsFWxLEpKAVEWynrZAh5fW1AQtuHl7TeI+foFC+/oD2xJKvmXW2pIl3hgEcoB9rnw3VlbtQWp8qQdpbioNmUfKD5DvK1S5D+g5KJCEufhiKWkXOSe/0nqGOKT9pdaSnHbamGo2zGF3+l88renZx22ymhPyGFvaK0um9Z+raxfmNONiZlOvvPik++fP/q43eCJaWr6JQ80CtA7LSA/282Ef0zAMUbontfJmdyu3ipFsFURok2lw9LMDKaTy67ZzC6rRj3XOvNvwrUjXdItet6FmR9s+IwIFHWwTNrnLRk2KY9qmw+iupF3uErXEJXYsuelM5qxv1DB0WrfAdeKW7EaX7VHxCoeUjv5LfwZj4vdwwpVih/lSLLhX+yOBtl7pdJXF6njYUQMV96pWchIorNL6GQzf3o1+YpsI07OvIdKKWsvdI+qxhEDHaFlSPfBoPEB8lo2AUESq5PBj+ACwuk2za2oyMgp9PgCYDsKCC7oolLuUxrBYEpvGzrUTlacrMT6Uh3S82MDMPi1xTzBPkApBfbk/AHC/pmt9t8U1OXxRS8V/7HKzmUkSpeS7DsoxfxLxTCGp5Ar5336aLjYQEqfgSzfYnyIvhcorFIq13Zh6emyk/A5P6Z1GskASu9588Zqz2lTxnyMOmqHLp4TPgwQzyLxq4iumQ9M8QvliBmZuPLEyyoewQhTYRNIF/F5yR/Rb2pXhJ2TuLEVGNVvmvGMijF50MZigB0Clej1lfAcSzIOkiJsMp+4qkfNSZnq4I5huC/azZiTKWe6MZgmUd/VmDiEJYN5QGlcwlQATuxr3YiyOMJwCKneuAAjnvl72e9E7wY6nyL4GJ8r+AcMvo/X8giTWQk7D/MrG5bA3G7TbRdQsTks6BuDlL6tQgDWE8UN7MFiF4xNYXlJqXpoq+NEzpMj9ERq8c+b3ZfiCThoK9Rdn23piDO++XzHo+DH8vPp3CDm3+mtNvMyUpg9cXYa2799kohX2XPiJ5GbfwMrVJSpHuZU7ClpyKjWEDIxVX7IbLF8lVAicuUBD6GOOif8COOmedYIlhU4MzFOxtAetz0EdaXn24nMvhX2RKONLLx/XhFAT3cRUioAEAX65daCzliM91H3lqV8ORF4P7/2OHyyKhSeYwJI6+VEeBwra+kHLeSS7qy707wbPH4Aj4Faj/Tx5VTCSQRfreN+TOFlbUU8BjCXakArxZUwsMLMAC9EdlCMLYh5fYB6/VS9o8xizABOJ4UPwDehFZpDkv5AcUohtZBQytsl5ece//1mUSYWYVIl1gqYGRvOfT7zYsjAwRUAz0ddbAF2FLzRG+wvqERCRKz5fZQBQ6XanJ48Bkfg/4l+X/vbmBXDTKY4CqzN+Cmmn/td/tQt79y2scm8NIeuXJtjNOkcxq6W6mec/+HeXL4oNx4GZvmuRFgq2+SBHEg7M345LocwIRQM7QUegtAtwa7blXhcBVJqfkXipJc1shjOKvNABeaPerRUSedp6mgmb6zgVdaZwW6Kc+XtZvQuA4oVBmnAKI2yfBStF7f6Tf14aJFtzF5dYFse0vZcN6VJGNorN8+5nC5ivl7ytE+aFjEtNSooKPomOOOR0kn3Dxu/V0msouNZNvpEnNEGHeJ9AuSzInqlnk4qNQ67tUuYEvxNTcAZa634QWQdBvk9W/xO9ZN0BPmjVI9YYU1isQnIL6i1HUkz5uWWPKb5rxEZEa5JIbC2UnZGY0Yq7JCz2RXFTBWBlSBRTq5gHlSB+wVMYb+F1TdRBmsfnEHxeqN5Pd5rv3P2R7TtI32xjD/cZ4Ken0Utzfa+mR5X+l0vIgGbXhZOqkCHi7DMhua0n0TKGPaveepd/XDetnmayFbYJ+GqiFT728cZd0owf4BXnOtr4/9ru/pNELQ3bUJrjtqlpTOq3Q8AEcte2ZWS1PeMHS1tVUxeCQ45Tq55Hy6Uk9kKD2n/G4+7//h0wvzkSEYAr4Zpu3x8+AAOlIJq3/qHFDeFd9JhDkKFF3ut4+sWQI6CgN/ez9oJIZoTO5ni8+Am5Ozapou173RVyDIQbA3mQ2tFWGCGnhgXm423jkN3XjnpSbcVFUgLfxMsw/ESo682L9yAK3CpbrMf5qGXckw8IYrkUTBjA76xhP93GhS2SNGHYLyvTYDIl/j4iF3Xhwi4FvlfSXsasmmvT2wSdy0uL6oGyY3W9XUsJPvUdQ/Z0znFytFRDnamg5j1TkZuKi8Ze4SHLui/9vkF6wLbx9p1SQYxjsAgcGMk7p/sB/GYKc9lYgTQC/P/3BQpz+KzIS16ifP0Y6iA8poeNmtwtVNXorC3edvA8JBb94Rjw2yK2TIaaVQEYBF7SKHKZRnR5N0/bP90Bor6m+L5jCeeQzIwJa/wVtpCXDTziR3slPPh675GEEd+dymRDb3NrFlqgJc9dq1LrHmMfWX8TTS3O4jnJ608hIC51/nV8biKDl4rU8h/cTfEdn4Fplc0xNOBKMZ4UMG9aLjLbjcBqGRygR5+R9FcWuHE2x5Fqk+3+CBOVI3GeKPUTXZwK5LxKXVkcnhxXO7ensXZ8ewOXjP+IQhrLR2BiWO8hWC+JbtP0GkjhahbIcI+VrAlhKwpsvibSQFRvgMFTOFm5BgsPGkTM8NQrL61PyH0rkD3i0ckuo54OZwvvmBXeuqyvmF13dKs2ESEari3Ic658209JadqJo6Pg9F2dKtBet3Vy+xrSHcWGHGKiFM3ZT627EQJetNYnv6QyLAOdQzgRLgWlcQq/fCqAbdollf8DwAZDLq4RhjrxinhH+ZgXrl6ONUDWo3xnh0Zp14Vt39rdXG34y5CjMnc9bA4mCx86q8oykfhfz9OMwtQ4WDyTontWTyZgTMZdgSYqvZpFSdznSP6SiMDAc98YlDQXI/bJoSa7p1fCnUbAE+ZxZS8S5lL+CUxnu5IZJynSyIjVHwClEDwx6LptcaQ95Hesxn4FCiQ++9k6k40GmxyywbDoZUNwj6hSbds8XYzIkVYMpt4bd2SuSgnrBDNhdgTg45d1BtLIEbguQ39bGfPf9XsGxvND2aBiayrxSuKlpMmndZuVjoRgtLxAQRCsBwoKpRXfoEqlWKMoUuCZnf09H2tcYsWw2xF4uvsHLU4Fq7Ch7oMAExwYdYnoh2i+Q7iDVQJwNpXAH5QcZSH9Vgy+km8iu4tPyOaxhTEJ9h3j1yitjdkYqFHFa6V1k8ppOaZeHKlgdjkB+m4i6THYcYCNmuTBPSsDalVfSvNWAPzB3Km2/SYgjrvjFQ8382zeTvPG2UgHlbhg3kPaSzPJOHbn0s5/BSR6fPlxs9dzOeL6tCCJjXMo2Xor/tJAWfcl81l/9eQ9zWDiq38PJK1Cw1TBUtrr+VwwJiB77swhr0MeLK5/f/AY+L4nL5fTFLuSffM5X+6jVwu7X5VgZCQnkw/9kiw/a40xZjnzhO/PUw7kglb2H6q6pYv5CFc0ELNMHtmEKY1wbFv3OqCX9PNn0DRaoF5M2IlN4tMQrk2r2kGL983sHHNNH7cHeUdgESb7ess2gBUbx5owvfcwudtbLwWFcMM+RSwtnWk7LjbICCENI5htMtsivnQjHmypNd7q5yK6Ada0nf+dxUbHTMQxXDewK5DlxBv/oT8iacfTO882CfyCoyPVhOorOV0UN4xfMeaSsKZk2Z9y6wmGKeuN8OVlNC2S3VRHMXNYwGH2KuH03wzLD8lXyjFBJMlGF12+a2SQJUR8oON3h0ejpURtX4n9k/CxR1+RH/CvNTEIAxUb/KZhVZFo+PsBh8IWb1cQZf2oARHwf+eICe4yJf7jVadzDIADuorqUY/h5gQk0loMqM8GEVc3NtC/S9McUSpNwh/OIdvOElnW+PDB8UbTZfpokSBIsiX3ro1QfigBIde0+znCYZb6fTRPi8387DRjXVtkTX7gJvF5HFCspD3IejLKbnLi/7BE0/vQwkYI2FvcnQJxinQJwB8HN/P+y9w06eDP6piitTnZ65Pw+L09mPxlYrZXBalPN9sAU8+QrQWKkuLgIQKLQ/XOK19NaAVVTbhYmClaz7DlED0y0yMpzYykBQcDQxvbGxrQpsMl7DVWra05K9S7cMoQiLZbYfaROhJwHnxqFwFhK1wsKadWK1E5g7StugKqFjKU2/y/PK+x/wcbq3NfwJP1J0oYSUbgIOOQ/XXl5F/c8573vaGmvax2sMyWesjkG36iLxKQtG8Gmr7Ef+bJIV7d6JeYWLP3of0vR52+F0ZCN/rhUiF9FrAHB1dCBxichve22N4fmXbJZ2VzZ0TzIZXUtxp1hx7T4eB+1FbJnM84dyMudRg+flRhJZHSRAppzZTdRGxo3OyA65RPDGi/5bAEHUnLTgDrIrs6Et0MxtvNuxf9qAiGzdo10g2kixz0yIA3CeE6Xf9pAtIF98RW18OUggLXjFvp1h6bZ5AYUTovbuk24p1OYg4uCWdQasew/AfTYPFWJC54i/qKOaPR+ElSEIHn2blWdi/yGniahDTOTYRR+KEsMo2rXCajyWC/zJqAt0QcQ+yxqQwje2YDz0/3YVS0eOfcj9sU+38oOmbLQm33srXiMXmDaW2T/jup0RMZ4wSkwAA1UBzzCHd4rkzuNRjDTVgFw2iGzZ81GJssg2+xLVeAFxcszpijfRDxdEVXFjlZilJxKVJdMpj/RWY8NjfZ/9M3wIPSBDpXUBZ4Jzbb4IPEcLtgIVgsNL1BnP3TXp93yCheLWJgzPkJ1otJK/vYqet5zLu8C/QwZ6TLHM6kK0+8OILAM74aJZ8XdnJ8Rdu8eezEXQGx/IlBFpGaGKF4CoXENG9TSCm1nms2g3MbHJmtpZmjgCJWFnP3f1FHohIP7IFManGMRWVLnHKGSBqeAp81WJPNXIVKvFXDYBW16ebFF4YhmIls+/Zj3TnNtH9sjQ6EoRap5v4VQMRez4j8Yme467mhTY8m8VAsLWDRn3Se9G25pEs7DYyXzvbNO1SWqvnWc8T1Hkt+r7chiCH8UQoDA8ZN+nN2MP6OIYul/3hqDiGofee80Qsa/3RKbfHtZtI4MnbYnunhcx66RBlBgEKmbdY5RjTWGlyiWZCMMbR6cC1A/ICV51DQiNatf9M92N1Ix/gj/bkgyo4sasah5FVx1PJ7YjaLHt19TQuNk4vtxEn49pFzF3wM5mEQtgwhVLBNGUiuSS9nPVKIQYEt5RnbNpJFwO6j4dexo54AfkcVY4TBaBayjdD19rpWAZHXKZXVXjAUvpv8KofwHE4Eqvbd0mZ+bSXx+qQ24OFmhOtFdRJvAp8N8g9s2iEq42f8fct4AGDWB39mU8UFkmk7DsFE9NfoSXffXkFXH2jYXTv/R7ZMYGtWiEmW65w7gp2RFlrXGx2fU/OFy2NZkQxAvoz3/n15jgh786TBA76yDHOxlLu44uZcSaE3w40SrGoOZgfvJIXH4wnWJyL5DXnJavhPQ9G4fFeGMN0sXYADPUdJImiGHloOki6KPeCo++melIgdDBLONLVg7pSUUoB2MPBMpU1oj/dy41EEqxMw9ZOd63h3hhsfCLLJR6yYuogTMl3CUYEldmTzRr9HJEessadd6nMzNZGnn7FDUg9DKJtG0StqLNgQFF7PiEg2dkIa6OjNIFqULCCs1Mh1tNm0cv+PSLZ+U9G79B/9WFQLCpfMsO63eDh1FCeWTjAXV6DuE+8pbXz4AdznUZ0vQ2IsNW/Xg1XldQK0wPGYtjvE6VTIX6TuH+F2XZRAzl7+Xzk7DHBa/xeu8kcRYQWgH8qkHqqZF0byJh8X45qiVn6afFyKUtzCyyXHmxVD6kQzzonM3Fi+c80Ufzdt4DoxxxNv7h7iax87l3QQNsI3WBYru7r9tTqFbrn6qci8URRkCW4nONdx0sNO0436U1yxIvTBifW4Ar0XDDuk+w1qYxlntXn69Z3uA6olAYaBpyOlvGYfTiHc47vJ+EYjbowo/6llmMJjX8cXTwnziSdG1j+R2gtCRCR6js3QJ4DwDrAt6DYAlHteJ3/88jHprzY64BjxSolJjEQp3Re+V+mdyzJdKZxHMVralY0nNsqgOrSlNtHiM/ZzSdb2JXr5MFEjRapoUrH4If9k2cTR0ioI5nQSdFJaKuSarKOKgKG0CEQmpRL6ru6CPnaLSG1U2TwtYqAydajYHon2+YAK4Xm3ZB6ZazhIBQ32smWcHXBscCZS0tRXkHKPapHOnnc4FHBf8boqzwFOtuhIoHT24lSZpz6ZpyZOFWrcDD6VV0i0YBFmXlXDiZxie/SYoyaC8hmYvqW6XrmA2crbNNL/2kwnxXL3VPDqMShGSnHVED1yKzoDJVHRMb8JC1+9YOXIOD6+1SwiRU/77bTsZ6x5W5EUcKo44KXipPy7CNHkN7egZL8xEC58z7h/vDZ0tnGV9hY863WElhbUMlvAWMCyDIEWwC3pvLj13SkIhsZnADb+JpiPfTZU83Dw2/SCgOKkteL6fEbkOA4kZDsxGRDMVPBmfCqZD3SIA/FBQOm6UW6qmZUC9mw4maWZt3WogPCaTsswfEHEQvKTPZgUb1CSb3qHxDSCqCMnCappaptZuxVfGiSrg9uUByLWZETOaP3gRzj5kRhzMZsLSEkOXmln+Zfj8j6R+UHzxbzBri3X5z0xe+SFnH6MH8KubNDNRm71MrqoBmAeNO7y9cxCaqCx0vmN1FcAib5ajWa7J3ZgQw4aFcjfk2/Xyp6eJnD0+IsVg9cBzZ+O399ccrZmhjqK+oc//efdBXbPhq202GwRrT5hT6cA3PhklBQOM7zDjdjmx3EMZHzeZUj8rCGNKCx77lAroDH5Fj0GzZ2VsYMb0uDS2aTRSvNzIGNxy/gSoIObuqTZNrVvOOHg+UT3xfVUhd2Yj2OSoTKeoasF2xz/dPdozFSfU9mTpzruv8V8i4RvR1y6Jpyp0V7mQKu0+dDOrDVuJX9klAIWKYwdwM0H9FJX2/Lt8r3d+vuvFRs/T2m5EyVApWkEfu9I5Z/EjWaXDKykGn1x+Fckf/0iwVx7vgjGDcCpq2mpYn67oF43uM5O7kepaNTmn4sdhX2MbJL+hFpUQ2joP3jOwm+5Nr//wNZZorEC/DxKDz+AjAjkBgzNLg/E521qi0pAU5OND5u3uprZlZj8Mh+zYruiz/hN3ndSBGu+v8xp7dE9NRpoOBUYRsCIrFzKbxVB9lY89MtlYjU0ZW49yZ5M61puqziu5VX/+5nipV9VKoqc+P4b4igw92dz8Brwv3+a79oVNMe6b7/e2mPWB5HvxPp+Q6QH9xhSN4SjllTcsHuP5UvRnz03mnW40/steKXQuvbC+fVhFCEkXw8ppxUrrzMML5MHljiFZCQ9ddUHb6NyZfnYe3O07MifD2w5wr8F7edfTisR/H5VPp5IirY5qkldZ3G7RbovSfRoDJDxHF0KPDJIXcbHWZDJCURFJWgBTsNdjJFLXtkaQtqPXkRHeNL4NzJucAbSNMKjz4+hhI9mYnLBuYUfYXlc9vDNSy6OdRvH7FxvRePpMz9On0czOkip+nDy4TQYh/41SoT7aUA0WoScMASEtdFrKdvdJby+tESutYpC/+oz0sL5QNTfyZ54Nx5G08ehghF4bQNcCwlICBGYjHgGy4ASGq9XtRFUr0ems4xg5Mur65sTddu6nLDBi7b8FyFKMB5viSpFuCIlEW63/SqFu7TdnMqAOxBBlZUAVGUWiIP6Kn1HSouHjERxTRfjg9XvYgF9lw4xl9xQVnKkQ5vJfplgd90Jx/P1kGN2n7lmGUgu9OnLiPZhjQB7MhAKS+hf+RQPh5PGUpjijk8T1qvpj5KIzPhTlRNoagrlYZbeQEgC+lHaZhiCnplM29XFVdFQHapjbVf0EfHcL7vUMPvzncLEnS9Ct5pOVtChF2fFwuOBglcGMY+VjwXONDsHAop+599Kpw/9UBJtX5kjK+5T3ZHYCgfA7DVJuJU7nDMM0HD1RNWRoc4DhvpYIkBqX/gO5P5PwAtXVdbAVh6sxhJMNetiFqZDJaZacMyHzVk884ifwCrG1AIDFTTgdkyV9UZB9o6CkbA5Z3Ib56pZEjhoYQMi/ANu148A6xNCzEdiMby4ws21Ml+rmrOvof2ejk5jZD8zsMlShO+qM3ncKMKqcjG/cK4K6irfvQI2TjdN/3SnJ9IDUAujEpzrw670K45glwjP9KZi1LAqXHYH/njQIwwvl+fcklOpdU3LM/Uu0JAGY/YpBn6yVTAxTxm3CUFg9LprTjYdaQBljfMxAoLDYZ/FWfKDtorxozaFBWgt/UNQGduwZ5eBVTa7E2NIZQANf8C9G/q7+XGcd+B91IKzO4h6FkbS1t8XJpacDZRRjvld5wB0EIcmOK5XTfWdBbDpYoy947HfPQAuY6wBGT/gpX1exNdCefwSEs9PLdpGrpwY/TKd4KQNHoWP89FwncWUTO0JR3zVXfPuiTij/dIqgfJphfVLlRkTv3/8jvOqRfyYZV40+3OCodXygENtmHekU8lZRBKTC4Yhn60k5d9RFuvl8j/mkeh5KU/IFi2liEEVVry61DuYkJfSxHsTsZSHtz13pYvVC5x743VQSUIdr5BMS2dKwI8YwqMcQLwuDCKFUHqkBg/kbMN0aR3zVpWYjU32v0m40Lr8/BfwsPYe3I45WqvyO1+7Qt73O7+c5bCz8VMbPrJptJTVseepYe5CjinwYm60BJI6LhMTiMJPjwNPNVrN3kiG/TLoyO3kb7+SMKXihNrNcQvKW00QKaSh3Z/hlm9v+DnepKrzl5ggx27OhJ77cbdNb3YqV1fgjnHNbHqpCPzEDOrBRpWJxGk/DnKInnvbgrc9hMVoKOp1ufkeTieYP3068EEdzs6ksL+oLVADFUceZl0HclKVySIDxKX2GEDZXC3/noCQoE5BPQSvgWhRaBnXrxQEsVOHknXvkw+OrIsOCYLTqbxm/blpPPGrSk7sINTJf+wH6xDcuT8f0aeRCCNxCj+SRcQ4ESUMiL1P8vVrXM80d/n+Dm3etwwyhki8dMm62pBWJ", "sN4I62ZmwCEHSRCJ0rlemtzYcehjYg8loNclLFLGOZe5OjuYOX81vm1hKwyW9rDHxjAarV+ue2ggsOOpcmVqEBXVWCzmAAJtsdvOirN1r5/SbN7qYfMc6ZbRC0eoTYonLTjRibqNT+CUIpdIFUvB1kGCmtjYwB80q8SP7M0CRGmz3iXYFeT3fJvYxFy+iisoYNeRoFzKA5vs0wt633UJ4wuEkOy0vI+z/D8ok131RHZDSXkctUfrn4xeMQLFTq/1c0Zhg8OPcM3zwFFeF/ygOXAeboajHO9oBnPKPYMjn2rCw3vqKZZEi9rPKO7uah7XUaItA5VI0U3QpeUnDtEwKs4RTP9YibCvCcxGrdgYDubTfZta41cEoSubqLYlnUgo+K5vZF3j69h22hm/WJAXpLIQ3jcv0fe3Do3Xd9J+Gn2guT5gnJK4kP/xxrVJr3iGYbFLvPNgp4S1SpiYH6ZA0ZZ77QDCn0ez8s79vJ0vrBjZm6Pz2QucGO+HyKDjmC20X5XDm36gBCjp+E9c5G+E4ARdXiM7/L4owsE4ehWA/gIDrJQyjlM5TaPJbacCXkKmMc78EfyTeGIR3Z13cK4UoHc7iG437pBzNZY3BBrYdSV+inyXHcAyZsfbpy6tW7vfksdV+Ly0ZPLR/jnD57xOIi1Iu+n4AiXZYOuAHpXGlc36jhyqFC5idpW3OnEjSHpajgvo1RkjbSHkjnDCnYFQ4C4+yRRyfsJx4ap/Kjn9bKFUQK1OISjdXn/oEZaulF6aDtABOJxaQFGViDpfqkuP4Dut/pW2kLbOYe2/Dm/SqUTIy9Ql2Xz42dtMtT89ztskBeGsY8k2cCcc/4+giSv7g/WcI/LIXK680lyIi8CctAGhJkUHyp+q24ZIGvq0Zh1lz8s/56T8FAvts8W7WlN1ghyBT3SSgIgKqN50fe5SAX29HguZjZ92P+URQKk52wfu5Q57jLQfiC46xpLM+cc6QgkybdpBKYkbFd4+BwX2yqPN8RFrZGzZHujHfaCAeyxtKMMC/q3k5wBWFS0RqZjJWXTLBwNFReyYN/Si7JF3AjMAvXxEBppeO/nIe9eAFTtE1Pzq9jzANwCEJFVGOp6aT8dtOu0IAeA8aaJ6hugY8KRBWrVw6ik3KsNQ2segopFJRiG5Tp9YCsmXz0YnVvuTqe+TTLHbSJpD6tEQItLYSBkjxtvYb0gUoKFosyjkkOER8aIiKN+muHczG9Lz/ggcEsyr+st5KymzmvyC373EshiYAYcLnpVXTs/2DXLVq1zz+hlbwqT6QkdtkBtY95AjTYJAOx3NXWN7Y6wLkGiB4Ra6Aqjq7T3X57chFOzODSiIxc35gmbrCAK4iBuqm8xDX+iVb+0PO3aFuhKe4SAraSmOwG5lklmEkmp4hIvL7vcrpoobx5zfrDPI1Z2XwDHmJ6XhMFTiqZHesj16TSTwcZLAiaWMyJ7mo68MrQ8IxSWc69D29t25QiTN169PGfjkGqVKyIlGf+tu+HUMPJ/vPhwYTPVWpN5Jv4qouvcOzDFX0Ij+O+ejp3QILMI1LnIaJCbzq+/yttlAGnTqOGCYCJY9hZ05rbaTP/3kJMiWSaO/KElZa6C9MpmsC9L5s6RLK/giZ6jSIr8u3cwx7G5SP+SOyOHQUTzZrFqATGfhKKL2n5nWObZnx4g9BVRDWTQlbT0S6WRgm25PZeGJlVaugWrZchECy7aeyDoKzlHz9g8ao/XHCUhSMBD3IWHOX3v3K4DiGgm/+neBKEYYKWuiutkdKMUR/xiXR4zhDKzb8hqNkwOFa+dFdE4f6TXeHLr1J/hVhFUGwHLyknfkHqEjASSPRpPwP7oBQo4cTJe/+U0ccMwGboHwhawE5c4alXDBD7G69PuXheC2cKbszYS6SwWooUUp3Y0cxeZMQyUQDxh9hQN3qmSq+cCo1PIOQLZLzvT6kbNff6F6nw/Iill9i9x/9xeHdlC7GqZdSOq0cS76idhN2P1RkpsiJicMpWnK1YCtRyNtRTRfPuiD1of87+HCG7Tq6GQ98SdXukQkgJdYRvrOeOziI+8KxfTKr0QpLP8ZRiIFQnWaYR8GbWRoms3+MWMS6qFDUivbFZrvRUidAAvLy40H2tFsmXNRDNCnEqfxV+NcYyOVyjysO4HjyiX/lcAcermVuxkiEWQuzTLl2BKpqErowUTPg14CWZHVmsci8eHYir/3lxRWUCZnGPSqeLtifBxlBw+v7kNxQGcRityAp9rtdACnXzJlqrWgsitoYFUNkaFy4DbWtOB9IAZhDs8yNAPDdeSwq6KfGWf7Nn6VL9T/v2UA5MmOPrrNDRbK6DCZ1ppJy39H4xJ1IA4NOuGEhJcBe5qhpmbARwGizSLRxs4T3fIKgv7ZkJiulVVFTxC0TvMEIvaGrTSfsVTqVtL6kc7JxvpdRKRcCQLFfPbCQxF4TyHcr6/jO0Dr5KGo97YVnSiLe1duqoT+ZXeur0sMyalZaW6Vdmtx+4YBDNspDWryHAKjb/orPfDuDVBrbeI8lAdZS6EukXs9ADGgWUion2uU+ZIcELg2WdSyZTuBfJ8BquC0nwIMUiM7sP4TGGSjCHABVgu5gF3IxfoCuAlxDLQ6Mts4U//kHaCeDewhrMdeH/4D4w8coR0KsMo9drx0kvWWVedK35Ky1trQjPmRiPrkwHYHaKKWXjPjymM743JhSKTH/xMXJbqnl/+dVFMFKHOwUAgKNGsFJz1/XzXVOaefx40EoeyRuOB6aQyrFUUWxsxqM4I7el4732tFRSMX2LgEawRHxfAMypM/yPp/NvYTeko6oRYe3NvRA78MeTb26oIzrz9sy26ZjULS+uxmfC/fz8AUbNWQLeEBCGIHprNAamIvvG+Ohf5Fi6sbAt1KrQ7QnD8DRcVtnKD0XqOWaAXlJ/ChDYCkPm8q4UFrP4p681Q2Bc8r/byzC2tHleSTv8KuGksXnEeRZNhRTldyeswfsRky3rsps3GI7BoFIAHExI8VF+4Zec/lI9W8jveTXhPgH6cGGFuL2Jqpjn4wa7bSX/i6NAF1v8topqnwK6vKF1vO/j2Ovjo3eM/ZBcAw2ZCGN6Tl6z7B55/HrITZThPfNbP2EjP1LE69lQyQBEuM8OhMMM3xYFeY+F/RDPDDSzL2pVGawBBZ38tv6l5MRHgAkWDiK5vtmOYwowm9H4mk3JOIWPL5uOwb6PNoWIFmWlExwQlkQmDCgAjqNkDh6k2OP7qPOzw/c2UPcUvvGx5yXX0f8XGiVB9JzpprdCGvfRvrn/hNdYJz17Ib/FFl7Qo+BtGVFl//UhLrfPK9B164CIi22tA4isA0YZ+927AS71WxCmDTMjWNCe3OOmcHOdWi4h5vV884IDgJiBDCSEsMWtgmZ7y2oeA9fgXfZuV7+uEdx/kolRN2WgROv61Kl3QqFcKQNFm/wVbs0PZwcuEsTvdMf8gcbzRwnti7cHR1/kL9zqBfv8vJuuDfITbUhvHuR+jj7oN7Y0EYQ1M++snlsAbrRKToxwVAMRAv0INmhj/+EyJvXXqrrIerpTHzbm++g2wX2bnTrQyyYEB0Eu8p9OtM0GJW6LpmTTnIo25eKgYSNOPnXgZJNuyXmD3ZrcSxHWrCDm9mdDjTBkilwinrCQK977EWVDy7KbB9izHjXs4exxVgyYu6oZaDOLjTLk9SZCY0vN8hbkoa0Aj0Wy7/Km+uOfT7n91JFxTOkOyRWxiOjUkXzMXAro334+mIA1vSp98Dep03EV65YA7QOApMPi+/RcGnVubVJcjogW4dZe4FtbLCsY88VfqQQTsKQkEXYW45Ugv69lTuO0M+ARmfkXpdfL4X4WgRgkVnS7ktZ7Kbif+K9nufSZJ6yJS255fnWBN856FAgp/eft7saTA0gpKEicTRYlFb1hu0ysMYpT5rhqzkMuVSNx1sNXWQz/oHquQ+4FwNK9nuLLkeDOViCIYsbl6ZyvCOVKlFpscJYe9FzuTKJtItcKqObD02mOSw/l+0LlCbLzIBJYMLvIcDvFjFYzAsRA0mW5uDw+6F/kuF0Yb1DS9+BF+d42ZO2iTQd3S65BkX+39+xO5rp24ojGwrsoBZYPXqYKeKp7dFVOXwqC7yftDuZz4MD5LE0+2aisOp7X1yP2F3jU4WcdECRk5dfxnq8ms334AUhepe3Z+G2djn4Rnb6B/7HgRtL5plqzMGeC3nbTYcKoD7WrfkyvI9/IYiQKabl7Gu+w+bL/hq2jea3U+XpBQzPE9TA8HQRNZvgHcm8Uz+gp0OBaueDSgE2UnPLjXIRiljH6Xh4xcVs9WPEXOnSuUGm/gmNopZni8jgTQ5oS5+84oTgAxPSUcjwoUH8ievtptytRvuHA+04++vexfLNrbfxdX/8UgnCe9uwPcR5yrdeueoiKILG0FskGeLcwz5jSKgcAgWTCYfslUHxt9bo0mQBYQMBDElZ/F2PfF/4xCNhV5DM+cdtoUnO7wJm7q6sIgrc6shPAZAqeMkYQExFKfXAPHodAjJB9KhTfGuHIeuGu3iBo9c1amS4I9rX5XmE6PEE0U+AjGYmAUCAjR/a8/hIf26ecB8vMidsZbdbwdvfuQbeZpH/2zOOnpjkG5Uvjl7efUnevdQyneQ+jkiM+yYAeGYcHIXkj+Axj2sgeWb8Boh+nukQCYXOeq+UAt2JdG4oXbESsOT6N0ho54/4M3NiN6clTb0VxVRzE+m2/zFCo4jgwkoQXHs3TtM53XX7tRDiqU97gXAE7geypebjoGfjiIMTJBWcoSXNMEjWkb4n5Z3I6VLZc4lqDYIlBXmKWLbjCHqMjy7lloqgFuBvYUou/77isBvk3LDkW1NpniXb7F2B93a4m5kLMsVcDhS/+rCHgScgFCQ9MU5wjARM8sqKYRyz01l7B1ZJSyDSG+M8UNTGj9J9dwTvAzbOy/P1gUmeT0D2ZVLSVplgmNYhEZcz3OUPz10XB6lOyyFbUnfPPKNEIJhGB60hNhzCYYT//V98y+xAwgOmIDh6hsRlIekGAhXCPfm3eXhSrs5eChaRdiO0JbJexw1r83+P7erfiBGCWikt7YSJJNI46GGdiser01sJ9CNYibZBBb4OANfYyNCG3xdF4mCKo5BAnnT0xiDpNo0c3mvvhpfVhga8PgfzNHPGN+je9XuEFOzyD4/1cDbydmQmCRgF5TxWL1bcpwkOs9q/hCVOAXyj+3fexnK8xnb9Frov1jcbCp0aaubHkVV/kPxCyakFnDbI+Gk0wS+CgEirD3H9sbdXvtTPiyYMkhHzmoVQtamYdQM7tJJEit38em7s2IpjvY39yzp1KbHdKCNxPn3+pzK+hGVxA/UtiKp0V8Nha/UA4K5esgcHBT2oEcZg3rKd0L5/vV8CNTQDyKpQDQY2alBMJYL+Muf/jyhsHymYhtBz+HkHY/5arxMGqwdAyGU6lGOX1g/bJmL2nn8oIx777S5HO2z1cE5b9VICOS1I8waMZ24xgtc5AfxGFdJN8MhgFlXM/RQwTOhcixiBlibcY5xR+juRoTx5j+XEp3KWgYOvm6JG4F2VaBc1fDNq7Ne4hV9V4VxW1ORc3W9KABZKkUzKJw0Kp72NmO8rkufXpDSt/XuGM6A/ifvlAl7jOmPN88JUi2yXbErRfSeoi2e0TaMMm+3MB5fFEV2yiewx7mfYVW+k+QQGk9uZ9/KMDbBgoYEznCGnZl2oY/ZAJnUrTTyjiyVrNXTrUMqG0TCWXjy+vL1Z90gMD4iPbyS2bBgJlCBOd12wUZ9SIBlFlHP2LQG7HTpVLtHoyfoTmQeSku2rCDQ+t2Q/UQ8ETjCtDOjzvifUE+jtYO654U89+puiYOAOuf9tf5i5U9BWI1bNSXomv1o2rKnlW248p3tb3sj1yKvnugaKEWo/HH2lGVM/SlxD+JtkHGvseMNMg6jCA1V74akyuoIGP39di3rWPzy30DlW9HPwjygXm8Lel8AUEiatMzhsBXn8/KvrCWXigaQlGTr8yOuM9xu0vRxwOq92COkvCUChcLXOPon1mDd0H0LSSdoLcAL2S43fhPepjvTCya3t6jPZdWXpZkYKvQsbj+BEG16iHqbFQRR6kKh/2AlLwZGryv2o5qxVXa0CEm21RsJjMTCqrgxf1/F0tJtjDHJlocf1GdhUWS3x+CTCo+MRaUt/dqhqz8QRp6iKrGmvh3BrMrGhgjIk4u5tM4vPVIcfmF/39CtafUtSSzYvOfPVjgUQQOicY0loJcZW5vVMIJlIH4U4uGUQeEBdfwr9uV5sah2zXn72h/eMK99MI7LKIQCPHdZ9WT7cc+ZgMaSNdHd3S+GDlpHAtZqkU9cgy0h7XLc5zqhTGt+F4PWMVhAy30MW+z/kUdUYz1PvYRtrKLfEK08SM/2TJvRXzZLCWA9WXq9Vwm1/1CvWnAkcdAzVchcpKuYsw1CwQKc3EEswNmT8ekCKaGukJTFb5aOWHyJuBU5o2nwfHnaJ2h5rO83hYIC9SUMBNNCs+8UfHcV30Wv04IZUo48OZ6DIOY6CpG1D7VvE/iUd+6ppupboQp90aeeyQ3FcjzmteYxe/qNeFngwm39F0F5z6peELolg5TzrQypPs9QBbjksJ+qwx4cLKYpTixv3gAVUlvfAy1Zc52DWynkQ5/A+Ti9aeAiepuvMEEMZHpSt1Bopgy+GrYKX6hdURcxnxCNL6OfYuMvYHCzeBI0frfZbfky11PT8D1R5N6ID3hSYgfZKB1q6FB5VZZEHoxkxmHMujZRquWhPOrdJrICcYMl6JN56O6RgkWrc5H7aaWoVMI6r3C7JejZTUHKBY95R4X1uXp4NQ6Z8sRWdKxZOfrB+Rh/W0/fls//DN2lEK9GqByDIA50/j15b1VPMcZA2oSXTRWyyay3rPU5qYA5s8/oq/7TgyvthQHKKwxA0aINnRnIttA7zPHEFZ8pLozE7syI5z3wd69H8N7dZN2shS8d/m1TLIQ4DVjKnSaU/cnvxD3kEOo3TxH0DQNETr0wtVp/XcXdEi0KWEJ+cYe+fTk+S9HFIilry+Xt39+lmW9WfxXZ4pFAfgp1U4BVE+7+tIl5JKLnga2AcFvyyzPoa6nD+4LafgFujX+D5hgTU1l1FsIbJakgIKqxZlyxBmV3DH5unteqwYWV1tZWtEgZwgrQlM5hQx71cn5Tpt1C2UVcVyt3Qh7Qf1D3Kh34Zp+oAM98nVHqW7xyraHK9XaSOzHLcyU8lTieywXS93Ne3RMPtALXqjC3XWuH1QM6dxCVA9AuZabE+wsu7JDgbu3xyEDNhuSIuDitKMvt2pcZZ99naY6G+fJ7qbdo4lLwaGCpxhLJWAyHBCE7YEdygSEEArs8znfmzeYuFziAcVhbOzgQYi7wbvOxtJy2BFySfcpOQgZ8XyaC5s9o8NEZ9FNZAJ85RK1TBkBDhwxk+YZ8XgjXTLzaKSZoY768nRYtLQhcIl21lA+jAuxoD5KZo8eYhUoVZN6gitwi0u9/mL4+cY9ks6nHGPWDq4/wSd6b5liPGyuv4qyb8oqGNriEqfSCwm5qHjHEtqgTUgPntU7lQtynlLPZUtuARk7Zl9OVNnvXsxNXt7RyKHwNwrg2krRcxP+UvpZFgas3aZE4BT3S+D++smCHx52sXxyFKqWiHvho/v/Ha6RtHmXVsluEQVupooWeu904+AiRuZj2yK85Qgcv+igFUw3IkY02LFvjkQDIIWTo5l3lc/jZsyYdb/bSmFC5a5bFEYCF1SMArO78RilRrX3sopwOQbyzNmw460Y5CFnTIpHmTH9Ocy8nyMdFCxVhEX5F8DuELphhHsYPx7iX5usCkp/9pa9T7iBEqPqyjuPzpZCZHwL/eEvk3BQLHvcGnJoUleewjWpPpuVuPMKyUquhHRWPLXI2TJ9fPwVq60IUkUPYXthQPmt48Ygv95XvAFtdEgL1edW/mvFS8VoUeclf+iiEueccEe+wHOfl//i9KRPyYxmxeqQ3T1tvtT1ivA0y3V7hM5dWpekukJ43Lzoc0gNALigDZQfmlOXvNlpXOUjDewahhSo0yWejNSeEOqhzYxmGrpOONL523a2SQfjCr8hNnIO4E86/COJqSltGJp3RHq9C03lHzbglAykZGUbTyZp26EIrKEGPHL7ns/IzBWwxpy+b2B3ZYrn6SFMRR5vrr0xQA3qQ1npp8mMZtLNrcB07k8vuX3QhlRxcvZo5iiotMLaaW7vR6jr6RA4QNaabdUgaQDCC0Qxdh3S5R3qDMIN8VENbhPmhD22gVPbV4twXi2GFJG8P0Ha5L8JKMI4LrHF1/LDnxzd8NVXEWW6/RL/7hGoH/p4HqfPZQ757/spDNSmzAltzfAR4cW0KXwwU0CpY1YEQ4CQpiXFf+nHUuAebnf0Ra61es/au5Wmie7yqQUkmlcCZAxdyWgOrIOn7s/PANWh5ZiMyLNSosPxpOXPUPfB+SgqHkmPmX4G4ZXDnsch0w6TkKA30XFT9NGaTZLtKNq0MXRV8PIfVJ/FRSaxXnZQeSmvtr1+917JoVq5rTWcFL4wr+iF0v0JkOHU9HJpPhSAl6o3Q2kgoPWtnXcav6OqKcHwDq2FVwEsDm6S8E90Jk2AmLh3UQe8kzpC3e5xOBREWbDIj007KB2+gf65OelzzZfNjI8JDhtJecnyASq1a/c7Yb9B3eX8UqQjUD9YpXDddiHIbJCmnRIq6okVV63ZtD5sE9Da4mb8M/BWuNxVacJ1elOk1t58wuOQ0fXWCrdifdgVtFqlABTUn0/uz2ScGgB/ZzDxtGwbeRpgSPDVPhWyhdhKd7Czp5mtPyKQm1Y9jefwwqDC8KTFcawM0VSbJnqGgfRIeYFNkfjG4B9avfFn8ljFc9qQYc516Tg4YuwcXjB0i8kiY4q5+d7gvwCFxBZp9SsBzdeVzE/dVtRfHjtOQTn9xy2J8eG7Muq+HLZYN1aga6Mpt6HYD8v24Nc707hzAPE9oxYXMcwnrdivrZZGHllw4m+tofxbX3/L+6eSKfJbaz5rZahvkB9tuLqQM7TvuM6wFDyw2lRlC2Qte3u4yiNu1seFvAYE06Qb9Q0kJc94w13gFm+yFWWBx7f60XvnfeiQgQyeuUY6OGa/O2WWhmvYHc5Y9yHWB77NLd1YshztZqtdysBvpextXlNuRU3KOPhJ71Rpn+FQycho9lJ0UGig4QE5SGRZ8Ahrp2OShrsA85+9u0VPCCpryPmd3fqN9XKuAvUC1CvB47HTAGURgFtBv65dyqIW8YoejG68aHITaewdDeCfNXE1mbsmTGURnM+7vnaIOodE9kq2P2pvQLP9VIspOVJMVO3dxQR1VO8iZIICDioPzBGAjcXRWrJi63yjvQvupsvCgFVAEnrSsamEe48j+sB05BnjeNo8ob2VVYgluM7tBHV0FoB9sj5ycf00Zrur6lJu4rsnCD9lYutQvq6twZojuTOA7OoEXvoS5HpQPYECMVVuaV0UN52tF5vLkjMbMetE+uoGs1R+IJ4OncOFvD7Nm+oEbf7Bs53nj7vdC/HAqdz56nk2MGPfLORNfHY2T7hu39EBRVz33MghFatbv4RvAPlKh8j14GZuAvHAHo+C7UmtZ6DmlZEP1HzuPn3LqmymZbl1UCFSxnVf3PUtldSHeCBMFWbe2AhFKJPbTXTnL+bTBA0dd6nOwRXVbuRMlWXwYQlzaC+5NL97srNPYuEAoF6Ow1xQvbP09u0oiGVHEiAT20jraJCcEkV77t+me5uYqsplh8zTqeMu4vGkrLblUde3O8KwmNhW8ZTqupgH67M91xPI6GC8BUbsKHSrEgtYrF54wx0jEgAxWzoHXOwLVpU+jB9S+K+ajzaGmihlez5VqiCyPcxdHxJqp1sFdIKR9emjLN2FlpCxqhheq4uiIr4omRsUz7ryiwSF+NhBmfaBwqud7mbXOzxa1all7NDremg38iIfus1DuHfp/PNjPRI1DA/+vhzwDkrk1//UDFyVVzxa4EZLWbl2twI59/TqBn83sVUihpgMwOENDPxsVMktDUz5S17EY7yyNujE/lMc248YTqTlWYA0kkkYno3ADFHN8hdd5BSGqwQvV+4uGAm7RxI0NQa4O8f1auEItPdKVTwBAiZpAp5XWk2ZhQy8VJWY1YpzBXA2Ytrt844pOqZYkm6HMv28fFT4OU/IXI48XaFNci5+IM52KY+LtkMqVtsy3BckDqsDkwfYGwWaN3fa4HtC7kuMTyG2yiOJWp+e2QIafdydgCPKwjzfFyAKMAa3JnurAsdX3wf3jHNqdwgWOIPRO4VupufEJLXLQLEvwog2yYhd3a5F0mtfWk0E/o8INgg+VmkFMSms4GtOnN1D4F1GNuJKDzWvabbXG6+hZ3bwYrxuqiL+9vJ0OT6YdVyMP6EMjCt1ecjSrQLEkMxiMxtdQsHipFK3pPUawMmktTiKmoVzVp6+902gRolvCAncOAr2jdX/vTK6hktTMXurM6z9KlSM4eAg2wO+Bf5a9XtgyIRkn6AU2IOsEPfeMthLDlzSbYdjm7AeE0IcDYtrjCifX4//allqTSzZm4zkdRADoIXtnbnttXm9JrPw1LOvv7xu52ks8sl/f5Ia0WRfngpK7pTAXYpNCLy1WfNQlQPMPoi8SPcV5hUUaYSvdLFnO1SM4VZohLvquM902B7/Sus5YZHkTPAhvodNIhrRjaloVkZbJz+xNHr6ZvCKb5+ecSezx2cyzm/dgTKUlK67ENVSkwvhC5Wsm22MxhUXVRUH9sYU8DcgYZjhhHwnr3qvlMt9sChqeZpCLgcgEp5v0T72t1buWVZBhIyBNlTg6DqXpDHDUZYSKcvLU5QqmOkeW7YfooH6S838FLPUF/Thv9++0KMFtmzkp7CSugG362v1bRACduqzuduzKMDCzX2oINAO4yhOfz84kH5igaeTrRw1u5UjK6k8Jgb2vzRmDwkuX2CFSjdOue2cXRojlv0++ipHGdthWq3LZi/NlG5bQpPFxYcTmlh5AwbcYaq5iiUxSc5ZqRvADixBxxF8V06+oHPNReyVqSJfKNHjaDITW25jBKtfXVDfSdYTGTlmo1iqR6mMGjzAyloHF535FxYyfkeHu2uTQBgcVCGB9h/7uw7LZxDs7DULLAQzKKhRzaKH/KtKH02rD0ylosQN+vZnb/NTOSLop30NpeW1Fvc7S/gONq/0JU5ciY7x48Ciuf7VXki5oyjoBUSn6KLtx/Orev54F9tipIUAm4d5HMBtg8XK5egsm1J+w7HrOa3Es5z9CSuYHcW4zEDs3qUw2LL8h6MNuBqUfhImQ1ZCqTsROwFfImkOMQN+ZJPBnDthFnl6xwR+AEN5SvSVSszaXJs/S4VOMASGk5fI0Cb2WLV1O1r66/QmXHDIySfa1xqok7rXy0BSqx0kSaqlPfSwhf6+dYJgM8rbjId2eUg7xSwx9Y2ciG1Rsu3OPo41YUKFJ80EmiGpvwUvAYadF9lZsJuF0/NBylfgGZmgTTyPBC5gqaKowXdcPmkpNl4yyg7RM/o5ievUQ9k9ROdql6eHJyRZ+UaCBCC2O/Ch7c1eL+gory/bYGMC5gS5MIvkcEVyHKZ9YBtsrbS7/vgHmwnxPbhhUEWG7JWm4K+r0+wq8hBrE5xO4gyoF02KtAgaMKzCPZ47r9lju7eMCdaWHGukrBUjYjTvcuLOYXf2lOH7F6Dw+/pweq5aQW9tvrDa5e7sYRi3WHOwPM9nAg330s5/lzKLXSu4M5BmSiSqev+to5HNFk+g4eR0D7fHZ6GI3/Ho3Q64dB6zpV5Suq2WjNwgrdJ7hMwzi7TBv2Xsd4agZxgzquh+TjM7d1pcZe2HBBSMECuywcgHQkVzqR0qBjBKQd8Xo7pqYqj4K/5lGAQ7GdAOs0NdKxfsQ/U46RfJfPm4JBzzbchiyTaNEwd7vzU7A+xA0zuznijlzTEbqA+MlneBLF+bbly5Ab10E2T1UkVGfqDqNiG2HhhO9OZ5IVN+BR1R/yLXwmCftWXHq8lxeX3amSMUU94Va8hgz6y7K/5TFRtQD1RiYx4fOJJXFKm8Wbno1mUQZ+x/OjDh7EMrZj5nFOtjDdgAJrw0cn6mNXGo8Xm1crw973vJBV+qY2htfUVizqwoPe0jHLc99eY03RElsUy4MJBq2prK9ukZR7Y6XPiqrBNeV6V8ndhw3MBwuGYHGAG53C8AUtXY8BpmKMFvG9cl81sC0PbdOMLVS06imhP2+L8UlWhkE4U6s4u6E+d96aqprha6Fxw9NPcaepLVwNBjveU125wYXvHHAxPvPBXFHCduAhNrc7GE9CasU/mnXclfyfrorImfpbOUGmF66uFZhSM5iW7555gurQHJMtxG4ZzSikfKXSbsa+uAWxiXtbaKi99v3aINj1cqT3HWzCq+B8a+/ZLD20MlBIlG59q/NmXIVTnAtcSyerOfXLqFaao5yto3Hzd+wwgvjwue4GigT1TAPGq4YkGvhO52J2oC942aH+43fqsLl6zrj6rnS6B6iXMaBWX3aiEO/bjtz+vWIGjWR1pNdCcolPGJRaDF6sLzppURLg7aczwvST80iDex1Vry97CwH379bYe1Yv/EXQOF1kvwrmHChdYQA1tZc3+nIoOVq4xDJKU+iKSdnQ6ikd9hy0kWT07Kwji4QrbrcYzxuw3ROGQ07Ig3/EsWYN6MIhdIPJRDxPhWQUSeE/9J149EhcAAY8ElZ8ywEmxyJruScZ6RLkvskdcwMfgwn/v8pLo/vAEe21ia5ZSa+fsGWt6wmuygFr//lJuzKVxxkPf2P2WM2DbUs8rcn0P1MLxP04Verr8CjcjH8jLJXSMVEzqmtK37767T/0D3paFjcf35/5DSV7euYcbo50v4E/AvvqNGy5M8H+XR94HYLnqlKdGYtbgfWREUxt9kmwzzS3wuCZxROc0uRhPamHUXHt0rpQle5tMkGfNCgatgUOGH37dV0Teby5tMk0OeRD9Vv+sisSazjtGowVGT4lmnnIy4iqeWhs3s7SsfTmHur5+A3BHIGDuhwfvuaZUO+/mdcOBVtxWcSmRH+Ayl9aYDpfOB4pFBlrombFgL4k+2SDv33pNz3FrJPQ8WRGKXsVCUUn2ZNkr7mQJI+9BbHjZWCa6tPw2J+g1z49SgoI1nwenDcsae1qEQ/Jop2ClZxacfpD9eXuxlCtoVjIxDKsbJF7vdXiBH7A8y/My2aVoSpoD5vmryvBD2YACzIUwnx7hw5KOqbRF//rMdlzN/b+ctZ3Fj7KF53RfBIwXMWWOFGFCLTVrxj8rbowo6qHgCwfb7E3sDN0e54tSbItWPlKA08A19PjjfT2681riyzwGWWLtPHm3BoVV9avvqjvH+1imQXmftc+T5j8mztFYErLrH2OCQ+hCCUH1OXekYb58oV1ATDnXiO/mbVM0VzFDQS9oYlRI655kcb7mSRQuboy1aeoVgV8iWkPMNW5cwaEN6AexeS1LksgCJTli3o8NrfPgC4o9lqCnDz2bI/daaUNhH59W3TfS/0t2VPP6Uxip4nIkkpCOh6QcZzQPcjdBgYaeEOjiAVw0s0vhreMc7wR0y6arBZ/0rg3dy0cTDo+Qq4gRYS00HdV/ISbgQ2fXyHv+xFGZJHXhzjLisxrM8Xcd5ejKzsjjE0sohhn/XXErfJRD7k3v19d0D4MPbcLm8OKWnivcOHOJH7d4EgFXHFJOminBycR6KMU/B5RyYejxsXU4SEgwdDA9xtoKHVDA4uft7hCw36BZ3EvgvluWrd1duvEDofliz/srP4hb2j1znYScgcRjfsmq3Zld6LpgBq3I11PT4GebJ4tbahuiTQ6MrSaRuDMzELibXux+xl3w+7FCTA1GiqhACR9RMyBdc35nDb+Oz5yc8zxLXDk381C98ZHhQ/OQDMSG1Un0QA0J4IoQrrhJZo00y67QKeeAoM6pXkWDDQYYnZx4CzQpiiGzP293Z0WTpRNq/9FP0DsfbdzDZSv2R1DubiSbCXMJlIV6vidQzLCqZR/tyi30DyBdaYZ3irVRD0pwhqVLfb/r2Oa8A0RiQksvt2N0+0uWS+iPUFoz4JeTiJEunVe3jyVT20XhXiHCJ+bFsRj0zgrxiUjLUz8W3NJSM7kNU3IKSJ6Jn8n3S2S493/kqhm59uYBoUrNq8vZqWJBtE66B8ttX4wsfaNMEuBVz6otNmwZG9OSkbik84/XEehpQfcszTGHBNjFadmfjLrv9XclNVrkLYPrMJkwD2HuZcnrmUy8rmXmMwKQVmsppPs3oQXiHxG3GGrHCJpR07howlLfeO91KWuF9MJOXXS1g602yMMqc8knOwF9vhN2qXrMu3sqQIdCP4KO9YEkcYXvPg05UUqvdoLPRzpduN7+VBfTDpOZlJCBDxJWEYZbNzSIhxZkCig1tArveilRS7LhKEDg/4UT+Bgy0wsUlB18Yv+4GgsTgmuHnAgyEVU+5uIWqt7rzoFJy/1eJvoOOTyohMA5kTaHzlIpyLGelqdjTvo2/DgcuUBQxQ2Hh3UiTjou3+7FjhwHLBcssngWVQY5EzS0mbJ/IvG9+txDCZjukCgN7TubMqFa3fzpwJX/Rkfkm7Ik50T/IH7Wg71+i1e7/X61HuDANIDhpjJz9wQcZeX8m7Uk9m5CLr7+nfQXUj+F1YluzQJKBNi5l67BA73b1e23i6Aa5cDd0q+MFhwJh+HcKt4D8mP96mh5Fs/PHeeSmXHCdpA7Q1ODJOqMetFgOIu56Uh2Qx5VgkyGq6+VDtUOOHkTAiaIh+xiq488pCbLgTcpRZFG/lQxB0uQmsG4bc4U4OH+OMn82DwfhBJeR95eHzMiVHROT4ASFUyoPqhfe3EKV7YhHQY38DJwEzt13l2F9VcDA3LnCcJlt8p4uaYIOipcGU3l3Q8TfDx84EnGsSxfG80FY1zRa/vxprtDf5Kc3w8rL0POM5DeeEd3Z+xhGZoaQNndf2kagjVVNMTudwIjp7GLv6LRUA9uJVKYmCT4rjr4nR4a9qQhJ5STqkPardRUpyxoz0ifpQeRSJw71cuV9SVRuAQHZbZWjzu3zGGbbZyMEAs3PxT7SmCGcIDmsqh1aTr//NdmzIXx+b05s9WJsDW739xG+5/wiVXjktb9kuufPxNbN2lxoIkow4QPUgMMjrVabQgiP1clWDgm5FZBpSiJ18p8ZbDmz4UVU/j/U7o092rl++3JYtpm19OGf/eLS/+7xgkOHWxc3Mf5zyqfKYhOvtDLb47U2SRQOGNvHks5mI6M5pBdnaKBcFouLA7lqOmWUBtgmlKcVzU1k9b5v6yifDYR8IP/15AEEWfo+x2tZUNUtw+WAZ7225fP5ax4y1uD94MIGGb5QCjsvZ0jN+zmzI4qu93LYwgucguDOv2cFpYBfGgF6rUKvLYLOA30XqWwuN8T/oVjSjoqQpDExEMPTJPZiHz0srSyDJ/H83pcdQmFjq5fWEL0zLLCRGzKDuhSEbArznCmHdmZUV7PXnwDTtD4X5I04fDvfTsHgeH1sNhAJj1/QPhlEF/8qGaY3wccm0JHB3KHQoE5lIBPomEymhhCST57Kmx71s5Jk9qkb7e8l1XnJtFcoyCI+a8YW0DXR5Ti9YERgg6MWjHmkpZCVR95+jghDjtStA6s8p2c+trRIwlRqIpIOnkncCfh7q1TjZwJLgHv/q3J5nrSEl1kzCdL8mk0teKEXRC6DCwn/wSEobAqofXap8Tf3ZoXlUm5ZGLMAAG39hDMouDhgXbGYIgGr0iqKvkut+Yc4a/uQLJSJh+ZbOj2/eeX5fJYJKPTyFOH0MRpxXodQV9Ya4kNXs3il0q2NBGqRnhopoCuaOI1FSuBqomqJCTFIa/mHqH3SlB+m/JOasCjHdilvk/u4tYeYX/pSFRu5xqEIcLxNBd+QrQ3Mov5MkwaqUrX+8KuxfgSwntxk4BHOLF8sYfS7JGJ8x5XOzbB9DlDakLcEMGaZt0kDsOUCWSz2T6WGSfk0WoDkElK4boddyqMzdIYfImf5k7sqsSkGb2rcoKHTKINEtFQLLolHUEHqRNB4j0eH6ySl6dgLEkEfQh6l80j7g5afpH1NaWnad7j9cCmy8R5rr6mAZVwrEMaXNtv+5H3t4yFKdOrC9cKigQe5GtnH+qWdvcKjeMD4uipIKkwg7Yy1mqGmINTPvxaBXEcHOOZjDoe6R+wPqSK880/ym26B5I9g8CxC2PBvdALIWEuVnuH0qssNrBOrysVEUlY7SxfPA+x2zuY6bI2chKPS6q40SM5IH3mdHL/eYOz9SWXiO8WIsd288rYWdc1Nlj9L6qte2HHYaVz7JVSkJL1DAKmg2U3oH1GRIq8guIXhcifgyJrXOk3gTkR5yV4yfuW9AS0uoK+bSIoQS4Hb4b5TcSybH2MkxPX8ZA2ysMkM+gmyeLyuMhf0zqRzAeFn5aFoiuGMjmoOAHGUXiaZTH4c+ucL5mUDGw2GtGi3n7hAP870MMXS1TfHbXtSQUWdm4i+FyOSzE5XT1tf5FX0dUL2gnmESFbdUcrC8KfLOd0oZHjget8+bMpINJXf0pH4Tsh2vBbsA0r7xhYARuVovWdkgAfNqAaFRuIc3i3nyy+2ViF5eDZbauHgF38sQ79GRYAp4/jc8ruyXafEP6g/5wZH7ntR3tTNtpLy+EghPcQPbtVYUxwqFVPHD4p6NJS59Zs4hwRC9GvHTVWRxETvJQBUGwNds/U+raqJGNxa8wKm07PJJjSzTClMMmKg1Mf7jhWSsUH2T6owSS5PWyK8Cox5Ow73VIRilGBaYhMfld5bqa2IKY+KbQc2TzRLYntm9REn32h/jcsB0jUd+mf9sAW1MFn2SjRsI3pHG1XBhDKE4pSQ27F3F6pB+JjnIo1hh2ZDhnRdtr6WGpr/5TcL14xAMgvAoyujU6B4Czr2+xzEsC1q+9bsCXgIjHiH/jH4SGxNs1tLObfWRFHEEeI2MTKlP3jCOkfM8VrCHdLfc2qNgtfKAbY1B4KrtVEFhMZz7nyJbrxG62T9n2QWjNHicBJH+UJvNww3SW32bjMhpK+YGBih5hRP+BsnR3JhfMfu6HQDe/YFVhztt4oMl47E+j6f6ZdjYoC2yz8Ujf/6Yx9V+AEZ8844uOJcbHn4xw5aluVbQfTn18z3D6ulSPH+ylN3v7fq92dQfuEbqwMo2vef1OsVBcMTtXUz+y9iOU3qZaomWkUPJb5mAvbFrVkM+iLCGYFs/iSs3T52mCW/QlXX0M0yG39kqDxD8iBciOH6fYtNti2r+ti8O3A604n5DvIy1cfylD/eEdk8eS6n36rAWI93zcW9UM3iClST3CreXUHa6RxQWfZoFD3T+twz+lOCMcrcG9tpKAjD+AsLhlSrU6F0VaJGE+jkRhKhLul8uwIaJAdJZSK5vuzWhgc3Iu0ZNLcbC1j0bUkj46D1RRguttK94njAg1nRlznN/9rweTaU+g/Fs3jn357+jur9PHObOY30znLnfy6K7Ym+aY+67O8xdMg6ojZ15RBUd9eK1TU2mggKqUFKzqlj0SjpJip0WTzOkiJeZxBMJuLjlUqULO2F7liljH5P4wxrO5LOSg+RYXYlGDHf6gGtk5gPxMmurr4RBCVS7qG/62zljRVSDIIYo+7B4tfgR1eXsTVMvBkgPNVMByIZ8ZCuBrJZ4z4SS7KYZKIQ22/whemyuP7hXJsMvzF3c2jLRQjWG/izcJb2z/+wAgMNRrmerS6+r4AysNPhXBU1Z1MTU5ueRSarJWHMuGfWbLW+7A9f09O5CGPkikj8UIi7TYGN+y14F1CLRMjhPk+yN8VSIugeYOcjVgLTp+yhDuxLxjWxdSmsseBJJv9qredkIuSAdMW3YbFnB4+ad+jpzz9wZbIVgqyRlRA/w5ugXQUqqWc4G2RT/Rb0OuP72luNZdw8rkwV8W3nBMuwt24N7bsSADMJOOkl6MKry6UWiLP5qHBCy9M84Q2w85f7/tVbcW8ePnORCqzNTNHXy7RwEj6w8hsoQZ5QpJNp1aUzjuuE5EMA4XjVi5EcqdqT4wXx41pJ1qaojoBiAweP40ZAKSiwzqSCTytH7uaXO406djTroE3Az9HuzlauPbEuK26yQppnp0JS3LEzOYAkIWZ6IeVCFmyrykUPUR8IOndVyC0tKwvVVDlRsxiEftHihYH+1U6nR1NJHwph9Dgz6JvpKeGDnfFyWGzkESJqVO7gbrWT9G56Pjk3xO4O+upgi1lg9iOKqfgSkz0E1VsKHZfbPFaSE9ZbGc4Ah5nzjANum+qAFWIMJxCTPU7h8nyYtGkvKoFMwviPD/8xHoIKrmeTHuC7Peud59X5W4KyPg1pyCV2+4vgN3bg8KRvDR0ORgqoIKg0eggmdOVY0/5nr5WmewgCxnHapUFa4zVF1pUCtzMTnZt4usss1YaR/lPvefqO2Trtl4WoRgescvIQhmyTIdnivIIgp5KAR8ZB5uLZ4A7WKedqeWKsKxAP14iFXWfxPQhrzBW63/IFBauj72sZJMmnY8mIVM3rFlnNdnXftoW2Vwfa9tw0J4lgVpFrNT0Jy6xtOFQx4Hto9l94f3RYABNTjYT6GxEa6/zrVKpovecmuAH7zz8jClWv9AheQdnoBym581fAOAuQOTni2F+SIOhbjXDO5zLTyjc+HYsMYALNQ3cNoJSoiD06/ALo04hQ183ruFpFv6T3/1jSqC/ad/2YN0J48SfwIAgPqVoH3+u1FxiyENnwfdSxA81aFfeALn0Lb3EwQePVG2/nKuj+EPVlXt1RbT1pGGn0/Z5lMbGcYm1JWRaCjdmCwUMaEonn4T5kfAmXM8Pe6TmI5zHZp4UB3/44m7Fnt9pY6INXcrqJFnPvXf7xqI4ODCFVujc3u+xwgJHP01BnWXoBxLfR3x0Vz8BFW9sL4Mmmc0COLDTTvqovOp7KEJnSx3xLbasmNKsS4PjNaWCKzHW9eWVDWg23+ywjxwJByywOraCz//6lardkEuKUo5kgulryTy2X+MbCiGoTDSpBWYsATLFUhOmSeWIvkcr/5y7NRBRgCxydc9HnrxUgCSDU6ysLG+aUteSswZw6FCuE99TOh2BVETG7JoJ1vgH4+MeTdA/i6aZs1+3l31l1AhDxPSLk/bS4LefGDOuk1ujb3R72h7yRmRiVD9vIblI7sM7QS/E36BQjYWP8Boxgq5pTYybSWgjE37UM87IPmAGtAwZVhBB2vnEjwdli8ZpVI7g3qT1s5gMFdrgtf8VYsc+88KzbZrb8Y6GzWI7FN7Aun+EOn2bwZowx8elO4DVat90ZopKKlc8juWgLbLE791ct6jN6PeYHXmiM3ug0lc+iYRyxR2+RKd7Sdj6NUN/810WuGZCA1Tjv4Ne/OyWNFVwMi/Gy+54iNdxKP27DfmVaMEVmGHV7xMjTX4Z6Yt523Rz97DFZgbb/mRTlsh6htgf832tk2f5pP01KP9RL+i/aRjHrLsshbxtEru9t6V7NgAdFFumJDHlYz+A0aIGuSmfiUgYOAc8FlnWwGHKpUt15T1h+GbPpeevaLkkdr2nezLZwFBNBjVL76DHUEmu0XKIkQvrv1TvysOgYq1tVaFmxJvUaHKNWwU67H7a/P3s7QFpAGNKxd0CIrHUE2GkPDFV1qqRFou4fgdnQ3rrdSNOps/xfAsH2ZwNtuyjZj1GURNEkXDEhxuEdKtvTruAdVgC+mWA2P3EGd9aKNoD3Si6Ss4FXCCoWaHme/CcmeuTolc09XqhVRl94yEI9eIh3czf+FBKOmEjsMYyT46XJ0pF6GX7wVWklI92iwYx6WToansQfm53MgHPmjO/HbjHUgAK/cAG/v89G/KvhM3HSMwPMvw4VUrj79bONpwkhTO5CuniqW6+LaZ+Evsuj9Xkd2pQqK9BAh48gYzL0IOP21JzYITP9R3j4ZhR0xjCbwVtLKtZgo6EHd4m7V4szXKsR2nbankonBau3dF1o1vzNAy7Jfa1pz+KCMNlSyrZVXIGJMhlC/Gx9L4ae8KE7k/ANluoUexQVFGNu2hjLbg/GDJAxK9C3TkP0zqkVPVU7NVI0nbGNFkHP3cLTyYJ39n+LxE3u+TnTkSWDwfoF2z6zz/etA85p+tzzTA75+pnkXzhyQGpSKhaozzkMcqvU/LJ9gohcAISuGFLHmoTtJi3k+QNbeDwJxygrFqeyn9dlTL6HOBQYtj1qJAZc45AMxnfYCWQcdmmUcd+Pb8RBe5nmtQGN1Zd52ENtbm3VclENT5fAQwTgPM14MVzlmRgE1XumOz9eKw3lCPP2THmISh1KdtRKpfer000loIpy6M0Q9jvRwOsHKhaAfe4q9aHLANKbFgEEoiAJM7MBObI6hkePjEGTwJE/19nLRG3YMKQwHFklXfSrMCcqyRF4Ny5grCXbeVkPjszWR5Tx/KeEFhRPjBVKh73DYlRX/QUb/ADISGakjPu2tfu/PennC0tyi1eLv4Teu2DYVx9sMsxdnQOONpVj43FualZLYubmHPaGUDkFI0f1JPu7a6kFCTk7NzfMp1PFgsLhiYWHoTkp4z3MeGevl5YIDw7z8S0EwAmEU2EGWDlrsXqyYsZlG3rTg1EaMNNszUl+5nFjC89nHO47XhbjLTo0v/YTinxKsyxLpkxQples86bKtHnMSAKIncAiFAAxN8G2/L2Ro3YuvAFkPw/1HzLFnWO9mspbww9j3yf7X55oeDu5vrDTDUazel3IowMoQyKH+4BShwOFQ9iD6CfIQ6aDW/tk0KKsAMfAkGo69ksC2Zfvo82ab04/4h+N1YmjGnQ3qRWYkp5uyaN+3GoLvm5tPsMHJSHg/NHuLRZVkY6FH9OXbQKmbkwvieB5P5UktG39DI6JENbfcrKhs4mkT3ORs/hAGVSP9DwX6gISYTpMFO+6J6alX+IvF/N1nk3vwPGQwxuWv8lzTVkB6+BXoXi52JimkMsraqI8IXS3GrBhCtVjR5FTfBfja2vSi0zlxUGcJNWVTyRvpNVB6WAMfXDg4libo9PbSsPYPMs/tbADYAce30wklqXGqxlVs5rhZe7SkrTK6s9H+ovVBUbfEtkZyS1zuqlRcZX8oViEjEqqI/v0HKFCSP+Tg4dystYY4LC6WUn+YBBc1TE8cm9kQcloAKdsLSLUcJ3TdCBhXxKm4AlAwbyooTap12Zv2RTkBXUaBqZVLIGZ2wgfx7ovC1Ecv0OVXf3DAfTOXMxB/0U4UQ0sERdcNVp8RvyK/yPMq52LBxZKpjykHv/g2EAeepwcdf2F7EUwf6sNOQIqh1S/qG3eyi+VEt2V/SVIXFIa/k7tifS8te3QhuT7+QhLwYQsCsAB3El4xWyZdpGARjr8W5Q93Tp4jzonhglyG07AUGSCy6lbagiiNjFyRRlZ5Nujwk70lYWz/fArZViHMZMlb76BomPZNouBAvC7SAdmtoI5sFlVBPqVK+N0V5x3eCqhNNmXgKqslMCFOUOIPlGJaHxmb585uszowzeaciWAp7HvdTtVtWQ5VLjs745d9M2gkns5KJ30AnR4N3gSYxtCffdG/Wf++4xzFUd0abivBizGGdTJmhyTC3NwN0J07qmJnpq7HaJT5rFSAZ9maU1whuBbHS8+vB1Tw1XaWO/LBgP+xxyOwnVD3EBwi5b40xnjzTthu8UixP0Gb3Cdovp/N92T96ZKCqjoPbdnEr+8erCHKhMixlzxnZxDknb9JB7TRc0AVsy8UAXfAhf//3L0Y/vGx+ufh5TIys/K8RtdGVGpzY+R5yZuZVR7BkxorLCGe7hJ59QR34Lvr4xdxmnyl27FDO9KE7fneUr1hT3pkml8BQNroFhGwyfbKg762P9KqBcbh6AuGySzsQr4Phj4CmLI7wZng4ZLqJYw2jnaI8ovoBFnTE5QNkzYWLoliN6HUFUdRbAMx44eWZBo298eHNFJ74dgMSwWqtAb666voqImc+JKnctQLmdwy+fvnVC9TdUalEY2/E+L5k8YqJjCQj4/sUJubn0/vU9deBKmMCDFvBmDNLBp9BrWfETfBUmQll7Fv8gXut2Kw0OxRKEur+n208tBfOIOQ6/sftQIsBz4oVtIZyyihNLxSBpI8QEEG4QeM4mvD//TczYHu4DEl0G03GI2t/HzuX/Uz4MYY+kiOoFaBW8NxpshJvESZTRdrBlp9+OjI4lVrg2J3yHjmPNh0gHu38eLb6lRcot93czKnpNtXQXDx5rsOP0yjN4AyakUdZzGMrHYXyedxRnplV3YqCpV1dRxO3v3m8IkaL67Yyc21FKX1JZvoLixMg8mF4yheCi16q5tKcy+eyGbnejFUeQMBJhHPinTjB3ENvsT14paDlxV9E+b2qX41p8Qy/UbJR3xax0chxVx7ITwHrPIKMSJubiFajVVUM3NwG5y3F9ojfmyh1RTyBIT/E0d5u6lJuK2PRvxo18R9vGjxwMzBr+8NtaEwg6Vwo3CvQKV+eZz37BC11/9bGoxEHz4YeAIqHjo37GoNNNpKUyXE6YxlrcnqDu23z/k71tdeXPezQ0jh6QMR4CjMmAqirMwWjk1nRGRw+c/8h2lsplKEwR1TkuLSSXFN5l0QTWc2ljva0ZJml/MIOw2agVtYu8vha5w9Df6voVGe+zQCn+g2WoMpGrhZ0n9INQY06WybwqmqW4ZKMdBe8Xqx9gb4jc4BovGkQJV36UYU/cdI/vUnLqs3FY5o3Gdk+tEU2mpHNHQGK6FffYEPIj4Yc6tlVZ0w9CYJ0Zm1jbbBYWH/GcBmxrBnSAxLuh6cN5C5Zg5HEWlzNS5IXQ5QrceX8O9T+GYCjREDdQ6tl8f9G082l+5jbYl6QMyxYSF+DmQPr2LsXqrIi8g+caJKozaRr0eEi7M2gjNbvevSC7jdZ02/Fe1ILeO5uOxscY+4Hu8FSXZO5g1kJIAUD75BEbAvmGoD+k932w46QpTuX1DdBxXc8fXJh3n6Wkn1BfL1clgFi4BJdbnmljHgiAajjm8l/uFGc86HdY8UM/1SVQj/ywVid1XWj62IudXAyKmFPRs3qERAenHkfUA0IadZeG2uc/Wpcr+4vVUJFTBq/ECo7Zq5oAHTxNqieuYiUSIza8Ptn790Cwhn4aK0JHWa06PVNJhLqNybw2t3+r4TXYI1vQ1umIs6Z++4rCI4SRs3xoUvcZ0CKsr5p6CfPhC4/BgDelVjXQyqVSOOWDYfD75D+oZHBBOekCembAREQGFX7c3TWy+Kr3YK+uTgPeqyqguwXs3+jzHDbfRgwC72ukP6ofBrZQ4MNUNUaDkgW0BlUHgP3JS+d60EOR49tMYiJJUNxhiqqXPSj5kCwh5mB0TEBJJe2VZQSn1E4ikKb98k/jE6bQJ1UHEDCtXfh9KO/wmR26t/WWyb84P9pbAdjA7t0UwkQocJ8GBWZFAkPrWRCLb+CaGkCUBO4iyyYnfdBs7SctAd0RPXcckxWPHM0kJG6LI1/sXQUJG7f0Xf/M7oTlsp++K6bLeL4Fh2JYArwkE4Yki+3w5AkTuKQmT48jXeJMCnEV+npadczXqCKW3Qm9de47JH2ZHoA01CyRF3pJTIW0H3wg/7eoHCrtdY5+UjRPim1XDKdA3puCTSTnmI/EheNLs644uxWc+Xhp09EISquBfinPBnda1e5ou90BDCMx3A4wzLK1LGN514+seap+23rD/7QFfZVJIElF/JO8FVHOIBGq7aHgnCpqEsMl4hcGFGJQwT2ea6scOe2W0tX6I6QNck1ljGG0whZLOQM6JEMvUQkZ92eTVYbCsjEj9b17UmDLi5WO9doysNwCqcUote4foxcMuwjwAKL2559uextXVnqYoF2gKu1KqTBYXGYj7R/nIo3pHh2n+Fh3Pyk7dd3zjb53+qfYOGeD3/7W5Rt4B2Tm4k9BgaUO2Je/bKzKadA9cqAlmDqUnC6ynwIdqBitKeburICi8b6SFeN4kyGGvaIqqcckQqEgPDAdH8EpujKDA7L2TX19Helb+j0UBs950YIU8+ZE5IgavhPBpUvBJ5XPh6QVxQdIX7I9px8APXgdjFS8ObngunWp36Z+pzLBsYiYGAFAvqlkgmr7qm4sjzOhVVU8j14XGABijAfc9+yyX9SI0BOPR/uB7Iy/7F+9aR0oFKiPGF60aKW78dhkpshUsqVZ7nydSqIQIVfsunUF5XZYlm9MHwtDTPMCmOjQDPfSCJkxLfNPrgiW23R5x7Q9V3H4NW4YOojePXv/tI/g2nnJT6qN8q9unLiWP3AlIlNr0gyFN/JKGVYqEHnqFMj/oFLtShQ9h/dII4eX3Eqmzky6lRFR9VgLMMFmsCG4WU01dRA/5RlLw0nhwt/txBhk6shSrGzEymUCpcwc0hClHAffS78unDocy8tywCnT3gmDp1WlAqBLURwEHPhWkMQSwcK597LhG+MDLMRFcl9H2Jujk3ufeseU9VmDzSX7ikWSWp+XUyrPVPzc94hIiYXlJwza31+6JabYdZndsTafpocMxxxR6EcjXt8WX/Xon40hud0gbm4YJq0vOEuClACEkKdE+JuerZATApMkq85zRzKzlvm8S6irVSdusgB4g7HzEv6MZ/R0SKJtdks8jiT071pRQtnTWswDeFQ5qcmubbxp898oaw8Jjim+aN5d5nzbdLxOVzTNjPrRKBp7k49t9CnREcc4AjCr+bnnmuO/zfntUCMIKd39sYXnKiH8UlAtvfs+riE+v0n0sb8yvAlzxbPSbfKQGf1K8FMGN+0XzVG+as2RUMgwntOjpa9jayfP2vpkXqj/ft4oBVjSfCoWV26TC69h0NpGN3i+vmay1wM5lBajm/OlMzWASipeamK0qDU7NYWwiGbjIByb6lfbjdGOSqXE0D1ctjE3B/IMO0CUk6dFdvBEQv+3tR6F5hM6mboKFhgJUzW79NIQkaRnu+ld9p6sj+4Bo3XliwFymquniF+yYmhLRHi+on7m/54e2LPY67z3R4SlAnPF0jnWmHWsDDgid2DYY5nlXO0K1XvdBsQO7HfWAi44t6SpqTtAWMr9Gi78PQHzwM2grLqottJRz8c+BhraNCL42nWo05IVVODIEHynnSFBtBU/N7jrGphscU6KRE6EdWv+VjPl4HxWwi+xU9DKAjBFKfeYD6xgnSoesSz/Ea2gTRrkwTxUnqEiieVfJtqaK4vRUWdlZkcJjsoK+tVSKNytEkSlL0PB6pO+xn0yP9PKpzSTuWX+UjpLU3jv7AIx2eWw6OPoqnB3SB47BiZLlCzBMNA3Z08SaqChWkngqsnvHo9vGO6IGUsb8xZHNwfBmYKPEmP+I8HM+bptf8B40QYRKwN5DINAT/fn9u2V8NGyNmkfvmsKStIVrQ8PvXJzhob0WfPwLz929Dyd10gUJEt1m18hqFe+MHql/icJUUGGOX2OVxjpOK9W/zSn0i57pLmE7Kgn74NfOaJdEjfsy4G111i2Yk5D6HkSpJOMlZhpETQ9crdsaedVg8IPI3isWZPda8gAMvIBJ43x++5uD9II5X7FhGH9od1a90X5CBrtWZndmeBBTsH68RDox4CaURMUOD3DIBT7L/1MtnEc8lwr+SopaPMcPxYf8R6V3TtgPbiSdeIEdMskEmJw5fHdLixP3uSANomSe3RFtQDQu71UEYjUgwA/QhANopSFyPFcR4mafrh3WaXh6pyEqkqvCsVk8FB5fHumwGXckChypGOEVlURH0pMBqA+5cm6ZrtKgnIE172OUIn865qe0EdUAn+gFK19G4iLdaWGQQXu6AwFVaCNvOnQLGNn4bUQNgo+rvl6WaFfL74msefbiD9omctBfFctq1erXTs6tgxv+wiiGsqdtnSGq41hzcU3JwNX4m2qugmrrq2+Yk+RC9tz6XYAjHI5Y22skzYgp9BbWdrr8mudsA+zG36I3neaixrgNIPQZdrdpfZCmf2Q/L8a/YDcs3b75mXW1skoOO7shk627S1LHSWNGIj2DVydlJPe648XSddRAkuS34Q/RAR4BGi+WMZ2eLV18NKycMjX5Bsl/KHPy/Y2qmdDcW/mzWGN0js3fDdn3V8XvTpLO0SrQUlhTHvNr8puF1aQ3Dsr2nCuTEktTm0ieKD28L+usZ/AigV1Ia3Q5P8/cBROQRJ5JVunBmhDdtVMasKR2L+vy2urhx1slWEQIw1cIbGSDJqj8s405goGMvmQafIylv+k645Wg4yE71SBuuqxOlQZ7et9IooNaGYW6LzzqJTBdaNfrnwFaZ7CqoieGtX0BYHeLBnEP3fjfYf5bi5rvOV7aJlCbpXbsG3Afg0VO0hj8Q/EgQBV0pgGkAexjK/7U4zqPo74Mjkpkq4LBfvzBlxIDPPlN4ngqcJ6nur4Dwo5MbSu2yhM6cxtsPMEXmmMwCsE2Vy0AODEMywuBCyfxT470wvRFCxh05f3WOR5PwO+WLvNQq0lMAm2fJ+usCKO9Hyu2LW5zfFkJufh2+TRK+BiISeM+Gd9q03Rq4EnAyM62TpXRhpDx3+/3Nv9TRt+soX/NBIZbqS69iDFtcaATEqFqibqLf7IF1J4l75/N0gbuMpq6k+0J2q/1iTWLSbXXEl0VAOPRWZOsYlnn9OYlmgjENVzjPrW5PJzjZgKP7N697g+r9DjGxjg==", "/vUqhGmIGIBN70Ge0OAWogyVi5jB9apqrqpcsO/HF+m9Uy7IoX+NviMTYqCXOlcux5aQXqz0+slqeF1GwZ6gr5mNRb5RPjJLbyUw8xUubBWJigr8hauiDmE/y2DIQixxb1BFDEq14DeK6nxXj/LlkC8ulfl09QoHNejuyc/+Zb/seC5sU7V+eWd6vWRoChRfZJb8yv0lHY426iN0D8tFUL2PzBeu0fFGt2OhQUslqHAyqD09rgSONDfknXzHH/SXThbRQcNVnIAqiMWfLmoKCgAVPEOZdDEZ2u2evEPCOGC8OhXEDb6jg8PRMZpEyQZS1XE75Mbqk7Z4Sh+B87rS9pSI7Fgh9HOCN17vsYVhrBRxM4EmxqiJMZxPBfZYuUiiWVAOiseIXHpZIdAIvh0fvS7n2KYR1YNGL3Jvq/riPAIXtKloavLj8FR+KWHYmcMQcZrGUIbgT4OcRL/Sship7Ps5itUL+bgmQ7lb6ZLtKcJklA95wG3SywDHQaqo7hKpxu37CKWmTWDciLEulDP4E68eJT6S2a3daGTz1h9B+2OkLrT3Cw3WInuQh/mDmuFIdOU3MGxSaBQafvv6o9Yt7gaYWdYSLBp3o27LCePuIbV8pbzaMZ6XeMrR3vOXqb0zE4ijtmbQL6XK/0HiJQCkls82TO9NL+FZppIP1Mjrth6qMmapI2TgbFjp0n4qaUqhC4L9QDa8Ag9VRqt7/m1fy3ewGGPioSM0HG8vdZ5TLwqsj5LWiU0iVoHPhfjva0dSGZzlSGKPPDNW4rYAw3XVhJtXmKtaU2A1/F8g2Fn1t886IK7x+Ve4QHz+h/YD1AjtEmifBCDTbjk2W8LNz4x2KBftYd1cXnp/sSUKRhdNcH5X1mwkvlKWijzeKM58wCKKPHbI/8r53VugKEWaRjGupUdGdIHa1i+C0MbN2aDtVwqAxs06OAro0GeXOqo4uEwAz7Doa7+pg/nVFhA2WrgP76SjIdWEyeT53LsJDxM02/LYgyUDfeaahJz2yMQ4uqeBuJakLLPjhSM7tDH16JQ0EWc199cvHmu/JmAuf0YrvG0hOsA8TGEqfXERoqu1H4y1DjmpgAo4H9SI6bocMuhwXbP2/US5bke6Ta5vYCKnZhVmkPuiBLCYFlHeyZbJ2xknYVzhN/8ga98cko7efR18RTa3z/JGkVvy/JP8k/STU0ucRWRWDvwWmw0Kc1DCgClYyYQi48cK4LZnQcgtPDVxfpSoqAJWBhfOAhYwGIR3F9YDkxjgUx5E3WWqKt71BNkyg4U7zCYaDAWSfUeYBI23bbt+J0PNWaoz3EFflQBSnFaFUynKPwVGberD3nR5fr3NX9V2v3lNAcyradiCwnOscF2l3ScHb14eeMdag5V5gScZMUN97jaaJyp7YZu2byQm+96Pgel+8WMdjWOKQz73JkaSEAntxhg9BEPpHr+9BnPqmSrNheij9aqtX48FFi7wNjY2lJ3VMGly9z5d/5zOBIyJ0ZBAhigbjyFl2DrPxKrFDfsSrZ663cmkPx+EIPDCHIMRqD6YN+g6QVhWMOcXnwF4aKQOcTPHeex86R1B9XS1KXUgkol/C6AN+6GO7ZMw73Bi4/y8M1W2zTmCXoIvW++TCKszoOXMrH+fWZogs/kEh0iM44Nfsk9a+3cJd+xDmsPz2I/A0NekovY9SNBo829otU274wHwhP2QiuJECeGyBWYlrn70U1XNYpp9AwmTwXD7UPi6gm1gp/MV2bmPyLz6BHg4TxXFxUlyzmHskh/ctROH/TOixniyGMVU+JSTAW/QEqx6NBPB3TFqp6Ajc+rAe8OmqhIlJGZoZuUnWuqL0Os0O9yIoy/6joEUgAy2gmJZY1gQXkqXoLNRCieUfPYXmH0JIDAehoi+HiCpbp5OFaQiDDqy6cJeLmdqh2oeB2M0c6TpaYFY4Pwp8Z1mW8f9P3jDMN7HXuoyl1b/h213ujTyDcc/gUTiF4xfBwZ/hHt8UlrK3WsoiNTdiSocjccA2xtgsiVS0rRBl4dBiqX9f1xUOyeAOCME3/KEu/fV/6uH9eMtwxjiCK6w19nT2c6EnCBnnAhrrNp2N5BXF9h42QHo1dRg3meSHXiNmakYC8j+o81R/Q/Qn6gGijRD+zielv4lldWAcoJ05WCnJ4WQsW1rnNHkjMpTFQQBgr4Mg4O6IVzT4z9TZgmWQabFH5jwyIbxl6urqfJNNm3DDD24zk7LYinwxfwJlGbWKS+651Bbk4K4Fpn7iffc2l5ocr209c7IW2wGRQbBWuLxgcA4bN3plD/Y09cs3h13ltjyaC08G4+7sOO50XHPOoR7HajKX3YfUHREx6nx+IA+cVvzqZFQgIjaw8U5TScmw1eeovVqqZG2+abrT2qFHQOH/I3dos5IAy32RKEPmk9/vN1iSzCirIUiC3llwVhyWgM1Cm3v7yhPYR/9K73ZWBKB8d9DkKP8OGCpfEln4PLdBOcQbsJkgPlpOvHuqXMSFzUgCH7Ne4YuWILDBxRHvVYfqqA21DsCrCJSt12Nl9qh3+RROcEcHMp/2qXL7G8acawbvrgFNP+Rc+GqRVKgxqrWJmTInWFXaQsS1z806j2A0lKX0e0xj9fmBHD2q03LWBlv/SnVoCPML362vZowLAFUGcZ5/Wtl8ay56BXyBSYj/SwqjZvgo4mPKZhX9bZVEwWxED9h7MpS/CcnG2q1GV5TBGKGC+bUsLybQzpDnsMWxJzm/o43tj9zfyNAvkteihB3nnS8WvPJKeGpQIVboO7FkfJ7O55hRRt331Ydk/sGRhdkQoAl460DuGruKA7GMJNSPy/SHWxAOscOj/GQVTSsY++VdAH6CB5FowaH0SLDPyapH4/jlrZO95gitbBvZ/0Qoc/op2dYBm/jaYGBN0nbOuz/iNnrZzNOnQ3SuhGyvCZWxsXJqnBsIUymhKy+Ks1/LE0CDBv/MnfPIpeCh79FP8ldk9ESDbUt6H4EW5kVnROn0iQPK+FOTH86Bt0NH1ZduIEeJ/BG1XT+NpYus7SplaapVrccqhJecVAjE34XRJUX3escY99R1aq60Qags3WrjwVCs+F2gGw27kahIxsJXAoEyKN5Yn3q9MMt86ToM42TyOZRSWPCBl+vasb946Lx1WPE2f0tDX4ocv9UHJUYaCFMvP1WoODv0UtlziYa9T39GFlmz9D9wQCnXQJZMif0VK2fEsr2d3wBEMVeQNALYyxeepyaiUtMbbfULdfuKKDlkmA9v6kpu0GbIb5kCoStNJ1dZdMatPlCowvsT/yvpVPdN43VXn0PE4NGUO/6FbNWUZ6qotTC8jSyzohi+NQEFbNuyd0S2syDiZkmE86pXqo33K+/YUqHHHodY8mx8egD0m4iyjcLknBbaEPXWt7S4ER0Lq60mQex1AzmGkHTxUauZulvAf0gbnnF+aspO7y4la/ky1reTvlSHioRkmcMt4ZxvsoR6POwwTS0l4IEmWgMmMMbtCpEp7XwinODz/HDPINLZbf60ibaVT/lKfMKXLKatOE4XXzFWtD5eRAEk1En3m5yPNOBxNaQlqTkhmU1yaShxGIqkFKYiGY8zEMrBPGk/FXlzybs6p7tWm/3LA0H57PDO2Jnp3SxdBUZKx+3lEIPxRLaVacEUZKOmJxb9HxjYOvB7riv+qpoA/Wo+XnZnaV7LbwsXcsCd+a2oox853HWnxYPbt7BY3gaXtQo1VE5gEZS45UxZzxY+C4DJZxwzCSoLCbDEhvAtZy4jq+PWsYlHqbbG2fw6oiSR/Wo7OGBls6100syzJgJ2OUrIi2xj++wh61zSySZjZmyvQTmcJvNbRyAYIwqGhk8LM7QWB+eEa7G5i6OjiVUqhtq0rwfdB2lSJMrs7pQ6JAKqQ939QL/nE6FjLf4gxsKOXwKfmQq7DXOCWsdAX7mXh5PvQwRsBi4zAnCrleASAHNf90QBs25H8PxTs49519XtAYueFptlTSsGod4GwO80+gjtp0nneVDUIM3aDTNwILgY/UyEzK/DGSvzMMwsZI6SQuxaRla3cUtUc7onLLWqfa6taEROE0aimklzRHdOIhCA3iOAogbmS0gGy/uzCwFmmTsD5cBKLkiybOZoXlEL4454t04wG4EnUQw+kwpgNQEKeKiIfETXHBtVPqnZcBd3CVi3AgkDkHMcJiIOoWD+xfaUPb2aL6+tb8pQsYY1pmqwmDuOHWhRp6axOOxx/+Ai6BjhuRZYx0E8p21QiHQUtzuCf/Pbu1C72sOh6l3baXQZS++qSZced8b7q/RKN+pT+pUM3nyNUuMlnwUeEJV6VBlB0dITLMELhKRnGvZrg0ldSKxQQDg8NhI/klzWXoC9Z/kcUordzFgMc9P8W/HKjAzUk2el18Ok7Fubp25w+/42RsexmjThgX+MES3/0ZGBHLAVMfIcgAC7VjL6Y82/Gq4R7woQyZf0I9gFUMcma+DbP0Uk8J6edPaNTZI3dIPeM34cnRlbx+FOOonoYKonfqBwyezPM1392BAZHyX5ZaJyzpTQS1EYLSOVWT4acxuEfdIPBYNnFBComj4NgJVeRu8Qu3YJqG1Mgd6"]; tb.push(103); tc.push(1); var WMETB_getnav = function () {
        var ua = navigator.userAgent, tem, M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []; if (/trident/i.test(M[1])) { tem = /\brv[ :]+(\d+)/g.exec(ua) || []; return 'IE ' + (tem[1] || ''); }
        if (M[1] === 'Chrome') { tem = ua.match(/\bOPR\/(\d+)/); if (tem !== null) return 'Opera'; }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?']; if ((tem = ua.match(/version\/(\d+)/i)) !== null) M.splice(1, 1, tem[1]); return M.join(' ');
    }; tb.push(44); tb.push(1); var WMETB_wait_JqueryUI = function () { 'use strict'; if ((typeof jQuery.ui === 'undefined') || (typeof Waze.loginManager === 'undefined')) { window.setTimeout(WMETB_wait_JqueryUI, 100); console.log('WMETB: waiting for jquery-ui...'); } else { console.log('WMETB: jquery-ui loaded.'); WMETB_load_FP(); WMETB_load_DT(); WMETB_load_JNF(); return; } }, WMETB_load_JqueryUI = function () {
        'use strict'; if ($("#slider").length === 0) { console.log('WMETB: Loading jquery-ui.'); var event = new CustomEvent("DOMInjectJquery", { "detail": "Load resource" }); document.dispatchEvent(event); }
        var event = new CustomEvent("DOMInjectCss", { "detail": "Load resource" }); document.dispatchEvent(event); WMETB_wait_JqueryUI();
    }; tc.push(0); var WMETB_wait_JNF = function (attempt) { 'use strict'; if (attempt < 11) { if (typeof WME_JNF_Version == "undefined") { if (attempt == 1) console.log('WMETB: waiting for standalone JNF...'); window.setTimeout(WMETB_wait_JNF(attempt + 1), 100); } else { console.log('WMETB: using standalone JNF'); WMETB_JNF_source = "external"; } } }, WMETB_JNF_source, WMETB_load_JNF = function () { 'use strict'; WMETB_MainInitialise(); WMETB_JNF_source = "local"; WMETB_wait_JNF(1); if (WMETB_JNF_source == "local") { console.log('WMETB: using internal JNF'); WMETB_JNF_Init(); } }; tb.push(32); var WMETB_wait_FP = function () { 'use strict'; if (typeof WMETB_FPrun == "undefined") { window.setTimeout(WMETB_wait_FP, 100); console.log('WMETB: waiting for FP...'); } else if (WMETB_FP_source == "external") { return; } else { console.log('WMETB: FP loaded.'); WMETB_FPrun(); return; } }, WMETB_FP_source, WMETB_load_FP = function () { 'use strict'; if (typeof run_FP == "undefined") { WMETB_FP_source = "local"; console.log('WMETB: Loading FP.'); var JQ = document.createElement('script'); JQ.type = 'text/javascript'; var event = new CustomEvent("DOMInjectFP", { "detail": "Load resource" }); document.dispatchEvent(event); WMETB_wait_FP(); } else { console.log('WMETB: FP is installed. Cool!'); WMETB_FP_source = "external"; } }; tb.push(43); var WMETB_wait_DT = function () { 'use strict'; if (0 == 1) { window.setTimeout(WMETB_wait_DT, 100); console.log('WMETB: waiting for DataTables...'); } else if (WMETB_DT_source == "external") { return; } else { console.log('WMETB: DataTables loaded.'); return; } }, WMETB_DT_source, WMETB_load_DT = function () { 'use strict'; if (typeof DataTable == "undefined") { WMETB_DT_source = "local"; console.log('WMETB: Loading DataTables.'); var JQ = document.createElement('script'); JQ.type = 'text/javascript'; var event = new CustomEvent("DOMInjectDataTables", { "detail": "Load resource" }); document.dispatchEvent(event); WMETB_wait_DT(); } else { console.log('WMETB: DataTables is installed. Cool!'); WMETB_DT_source = "external"; } }; tc.push(0); var WMETB_getElementsByClassName = function (classname, node) {
        'use strict'; if (!node) node = document.getElementsByTagName("body")[0]; var a = []; var re = new RegExp('\\b' + classname + '\\b'); var els = node.getElementsByTagName("*"); for (var i = 0, j = els.length; i < j; i++) { if (re.test(els[i].className)) a.push(els[i]); }
        return a;
    }, WMETB_getId = function (node) { 'use strict'; return document.getElementById(node); }, WMETB_getURLParameter = function (name) { 'use strict'; return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)').exec(location.search) || [, ""])[1].replace(/\+/g, '%20')) || null; }, WMETB_sleep = function (milliseconds) { 'use strict'; var start = new Date().getTime(); for (var i = 0; i < 1e7; i++) { if ((new Date().getTime() - start) > milliseconds) { break; } } }, WMETB_notInArray = function (item, array) {
        'use strict'; for (var i = 0; i < array.length; i++) { if (item == array[i]) { return false; } }
        return true;
    }, WMETB_isInArray = function WMETB_isInArray(item, array) {
        'use strict'; for (var i = 0; i < array.length; i++) { if (item == array[i]) { return true; } }
        return false;
    }, WMETB_angle = function (node1, node2) { 'use strict'; var deltaX = (node2.geometry.x - node1.geometry.x); var deltaY = (node2.geometry.y - node1.geometry.y); return WMETB_angleDeg(deltaX, deltaY); }, WMETB_angleDeg = function (deltaX, deltaY) {
        'use strict'; if (deltaX === 0) { return (WMETB_sign(deltaY) * 90); }
        if (deltaX > 0) { return (WMETB_AtanDeg(deltaY / deltaX)); }
        else { return ((WMETB_sign(deltaY) * 180) + WMETB_AtanDeg(deltaY / deltaX)); }
    }, WMETB_convertDegRad = function (angledeg) { 'use strict'; return (Math.PI * (angledeg) / 180); }, WMETB_sign = function (x) {
        'use strict'; if (x < 0) { return (-1); }
        else { return (1); }
    }, WMETB_AtanDeg = function (x) { 'use strict'; return (180 * Math.atan(x) / Math.PI); }, WMETB_delete_multi_Ids = function (myArray) {
        'use strict'; var myNewArray = new Array(); if (myArray.length > 0) { myNewArray[0] = myArray[0]; for (var i = 0; i < myArray.length; i++) { if (WMETB_notInArray(myArray[i], myNewArray)) { myNewArray.push(myArray[i]); } } }
        return myNewArray;
    }, WMETB_extractNodes = function (listRoadIds) {
        'use strict'; var nodeList = new Array(); for (var i = 0; i < listRoadIds.length; i++) { var road = Waze.model.segments.objects[listRoadIds[i]]; if (road != null) { nodeList.push(road.attributes.fromNodeID); nodeList.push(road.attributes.toNodeID); } }
        return WMETB_delete_multi_Ids(nodeList);
    }, WMETB_captureCity = function (roadListID) {
        'use strict'; var road = new Object(); road.NoCityNoStreet = null; road.CityNoStreet = null; road.altStreetID = null; for (var i = 0; i < roadListID.length; i++) {
            var road1 = Waze.model.segments.objects[roadListID[i]]; if (road1 != null && road1.attributes.primaryStreetID != null) {
                var adress = road1.getAddress(); road.altStreetID = road1.attributes.primaryStreetID; if ((adress.city.isEmpty) && (adress.street.isEmpty)) { road.NoCityNoStreet = road1.attributes.primaryStreetID; }
                if ((adress.city.name != null) && (adress.city.name !== "") && (adress.street.isEmpty)) { road.CityNoStreet = road1.attributes.primaryStreetID; }
            }
        }
        return road;
    }, WMETB_minInArray = function (array) {
        'use strict'; if (array.length > 0) {
            var minimum = array[0]; for (var i = 1; i < array.length; i++) { if (array[i] < minimum) { minimum = array[i]; } }
            return minimum;
        }
        else return null;
    }, WMETB_select = function (Select_IDs) {
        'use strict'; Select_IDs = WMETB_delete_multi_Ids(Select_IDs); var foundSegs = new Array(); for (var i = 0; i < Select_IDs.length; i++) { foundSegs.push(Waze.model.segments.objects[Select_IDs[i]]); }
        Waze.selectionManager.select(foundSegs);
    }, WMETB_testUnknownPrimarys = function (road) {
        'use strict'; if (road.attributes.roadType == 2 && !road.attributes.fwdDirection && !road.attributes.revDirection) { var node1 = Waze.model.nodes.objects[road.attributes.fromNodeID]; var node2 = Waze.model.nodes.objects[road.attributes.toNodeID]; var action = new Array(); action.push(new UpdateObject(road, { fwdDirection: true, revDirection: true })); action.push(new ModifyAllConnections(node1, true)); action.push(new ModifyAllConnections(node2, true)); Waze.model.actionManager.add(new MultiAction(action)); return 1; }
        return 0;
    }, WMETB_fixeAttributes = function (seg, road) { 'use strict'; seg.attributes.fwdDirection = road.attributes.fwdDirection; seg.attributes.fwdToll = road.attributes.fwdToll; seg.attributes.level = road.attributes.level; seg.attributes.locked = road.attributes.locked; seg.attributes.primaryStreetID = road.attributes.primaryStreetID; seg.attributes.rank = road.attributes.rank; seg.attributes.revDirection = road.attributes.revDirection; seg.attributes.revToll = road.attributes.revToll; seg.attributes.roadType = road.attributes.roadType; seg.attributes.separator = road.attributes.separator; seg.attributes.type = road.attributes.type; return seg; }, WMETB_returnPriority = function (roadType) { var roadpriority = new Array(); roadpriority[1] = 1; roadpriority[2] = 2; roadpriority[3] = 5; roadpriority[4] = 3; roadpriority[6] = 4; roadpriority[7] = 3; roadpriority[8] = 0; roadpriority[18] = 0; roadpriority[19] = 0; roadpriority[20] = 0; roadpriority[5] = 0; roadpriority[10] = 0; roadpriority[16] = 0; roadpriority[17] = 0; roadpriority[21] = 0; return roadpriority[roadType]; }, WMETB_isSegUnknown = function (seg) { return (!seg.attributes.fwdDirection && !seg.attributes.revDirection); }, WMETB_xor = function (a, b) { return (a || b) && !(a && b); }, WMETB_onScreen = function (obj) {
        if (obj.geometry) { return (W.map.getExtent().intersectsBounds(obj.geometry.getBounds())); }
        return (false);
    }, WMETB_getControlByDisplayClass = function (controlClass) {
        for (var iControl in Waze.map.controls) { if (Waze.map.controls[iControl].displayClass) { if (Waze.map.controls[iControl].displayClass.indexOf(controlClass) > -1) return (Waze.map.controls[iControl]); } }
        return (null);
    }
    var WMETB_CheckSameSegmentsWithSameNodes = function (segment) {
        'use strict'; if (segment.attributes.fromNodeID === null || segment.attributes.toNodeID === null || segment.attributes.junctionID !== null)
            return false; var node = Waze.model.nodes.get(segment.attributes.fromNodeID); var otherNode = 'toNodeID'; if (typeof node === "undefined") {
                node = Waze.model.nodes.get(segment.attributes.toNodeID); if (typeof node === "undefined")
                    return false; otherNode = 'fromNodeID';
            }
        for (var i = 0; i < node.attributes.segIDs.length; i++) {
            if (node.attributes.segIDs[i] != segment.getID()) {
                var segmentToTest = Waze.model.segments.get(node.attributes.segIDs[i]); if (segmentToTest && (segmentToTest.attributes.fromNodeID == segment.attributes[otherNode] || segmentToTest.attributes.toNodeID == segment.attributes[otherNode]))
                    return segmentToTest;
            }
        }
        return false;
    }; var WMETB_computeSlope = function (nodeStart, nodeEnd) { 'use strict'; return (nodeEnd.y - nodeStart.y) / (nodeEnd.x - nodeStart.x); }, WMETB_sqr = function (x) { 'use strict'; return x * x; }, WMETB_distance = function (nodeStart, nodeEnd) { 'use strict'; return Math.sqrt(WMETB_sqr(nodeEnd.x - nodeStart.x) + WMETB_sqr(nodeEnd.y - nodeStart.y)); }, WMETB_getSegmentLength = function (segment) {
        'use strict'; var length = 0; for (i = 1; i < segment.geometry.components.length; i++)
        { length += WMETB_distance(segment.geometry.components[i - 1], segment.geometry.components[i]); }
        return length;
    }; var WMETB_getAngleCCWinDeg = function (seg1, node, seg2)
    { var a1 = node.getAngleToSegment(seg1); var a2 = node.getAngleToSegment(seg2); if (a2 > a1) return a2 - a1; return a2 - a1 + 360; }
    var WMETB_findMostLRSegment = function (node, segFrom, mustBeDrivable, mustBeGreenTurn, mustBeOneWay, junctionID) {
        var minAngle = 360; var maxAngle = 0; var minAngleSeg = null; var maxAngleSeg = null; for (var s = 0; s < node.attributes.segIDs.length; s++) {
            if (node.attributes.segIDs[s] == segFrom.attributes.id)
                continue; var segToTest = Waze.model.segments.get(node.attributes.segIDs[s]); if (junctionID != null) {
                    if (segToTest.attributes.junctionID != junctionID)
                        continue;
                }
            if (mustBeDrivable) {
                if ((segToTest.attributes.fromNodeID == node.attributes.id && !segToTest.attributes.fwdDirection) || (segToTest.attributes.toNodeID == node.attributes.id && !segToTest.attributes.revDirection))
                    continue;
            }
            if (mustBeGreenTurn) {
                if (segFrom.isTurnAllowed(segToTest, node) == false)
                    continue;
            }
            if (mustBeOneWay) {
                if (segToTest.attributes.fwdDirection == segToTest.attributes.revDirection || ((segToTest.attributes.fromNodeID == node.attributes.id && !segToTest.attributes.fwdDirection) || (segToTest.attributes.toNodeID == node.attributes.id && !segToTest.attributes.revDirection)))
                { continue; }
            }
            var angleCCW = WMETB_getAngleCCWinDeg(segFrom, node, segToTest); if (angleCCW < minAngle)
            { minAngle = angleCCW; minAngleSeg = segToTest; }
            if (angleCCW > maxAngle)
            { maxAngle = angleCCW; maxAngleSeg = segToTest; }
        }
        if (minAngleSeg == null || maxAngleSeg == null)
            return null; if (Waze.model.countries.top.leftHandTraffic)
                return minAngleSeg; return maxAngleSeg;
    }; var WMETB_limitForSaveReach = function () { if (Waze.model.actionManager.index > 98) { return true; } else { return false; } }; WMETB_getAttr = function (attr, seg, issel) {
        'use strict'; var x = ''; var selseg, st; var seg_model; var attribs; if (seg.model != undefined) { if (seg.model.model != undefined) { seg_model = seg.model.model; attribs = seg.model.attributes; selseg = seg.model; } else { seg_model = seg.model; attribs = seg.attributes; selseg = seg; } } else { seg_model = seg; selseg = seg; }
        var street; if (attribs != undefined) { street = seg_model.streets.get(attribs.primaryStreetID); } else { street = ""; }
        var city, state, country, altstreets; var b = seg_model; if (street) { city = seg_model.cities.get(street.cityID).attributes; state = seg_model.states.get(city.stateID); country = seg_model.countries.get(city.countryID); altstreets = attribs.streetIDs.map(function (g) { b.streets.get(g); }); }
        switch (attr) {
            case 'Country': if (selseg.type == 'segment') { x = (Util.defined(country) && Util.defined(country.name)) ? country.name : ""; }
            else if (selseg.type == 'venue') { st = WMETB_getAddress(selseg); x = (Util.defined(st.country) && Util.defined(st.country.name)) ? st.country.name : ""; }
                break; case 'countryID': x = country ? country.id : ""; break; case 'State': if (selseg.type == 'segment') { x = (Util.defined(state) && Util.defined(state.name)) ? state.name : ""; }
                else if (selseg.type == 'venue') { st = WMETB_getAddress(selseg); x = (Util.defined(st.state) && Util.defined(st.state.name)) ? st.state.name : ""; }
                    break; case 'stateID': x = state ? state.id : ""; break; case 'City': if (selseg.type == 'segment') { x = (Util.defined(city) && Util.defined(city.name)) ? city.name : ""; }
                    else if (selseg.type == 'venue') { st = WMETB_getAddress(selseg); x = (Util.defined(st.city) && Util.defined(st.city.name)) ? st.city.name : ""; }
                        break; case 'cityID': x = city ? city.id : ""; break; case 'Street': if (selseg.type == 'segment') { x = (Util.defined(street) && Util.defined(street.name)) ? street.name : ""; }
                        else if (selseg.type == 'venue') { st = WMETB_getAddress(selseg); x = (Util.defined(st.street) && Util.defined(st.street.name)) ? st.street.name : ""; }
                            break; case 'StreetName': st = WMETB_getStreetNameElt(street ? street.name : ""); x = st[1]; break; case 'StreetAlt': x = ""; for (i = 0; i < selseg.attributes.streetIDs.length; i++) { var sid = selseg.attributes.streetIDs[i]; if (sid !== null) { var aStreet = Waze.model.streets.get(sid); x = x + aStreet.name + (i < selseg.attributes.streetIDs.length - 1 ? '#' : ''); } }
                                break; case 'Length (meters)': x = selseg.attributes["length"] ? selseg.attributes["length"] : "Unknown"; break; case 'Lock Level': x = (selseg.attributes["lockRank"] === null) ? selseg.attributes["rank"] + 1 : selseg.attributes["lockRank"] + 1; break; case 'No Lock (auto)': x = (selseg.attributes["lockRank"] === null); break; case 'Lock = Traffic Lock': x = (selseg.attributes["lockRank"] !== null && selseg.attributes["lockRank"] == selseg.attributes["rank"]); break; case 'Lock > Traffic Lock': x = (selseg.attributes["lockRank"] !== null && selseg.attributes["lockRank"] > selseg.attributes["rank"]); break; case 'Lock < Traffic Lock': x = (selseg.attributes["lockRank"] !== null && selseg.attributes["lockRank"] < selseg.attributes["rank"]); break; case 'Toll': x = (selseg.attributes.fwdToll + selseg.attributes.revToll) / 2; break; case 'Separator': x = selseg.attributes["separator"] ? selseg.attributes["separator"] : "false"; break; case 'Elevation': x = selseg.attributes["level"] ? selseg.attributes["level"] : "Ground"; break; case 'Road Type': x = WMETB_RoadTypes[selseg.attributes.roadType]; break; case 'Editable': x = selseg.arePropertiesEditable() ? "yes" : "no"; break; case 'Created By': x = ""; var cb = selseg.attributes.createdBy; if (cb > 0) { cb = Waze.model.users.objects[cb]; if (cb != null) x = cb.userName + ' (' + cb.normalizedLevel + ')'; }
                                    break; case 'Updated By': x = ""; var cb = selseg.attributes.updatedBy; if (cb > 0) { cb = Waze.model.users.objects[cb]; if (cb != null) x = cb.userName + ' (' + cb.normalizedLevel + ')'; }
                                        break; case 'In Selected Area Place': x = WMETB_isInLanmarks(seg); break; case 'In Screen': var g = [Waze.map.getExtent().toGeometry()]; if (WMETB_isSegmentInGeometries(g, seg, false)) return 1; if (!WMETB_isSegmentInGeometries(g, seg, true)) return 0; x = 0.5; break; case 'Nb Ways': x = (selseg.attributes.fwdDirection ? 1 : 0) + (selseg.attributes.revDirection ? 1 : 0); break; case 'Roundabout': x = selseg.attributes.junctionID != null; break; case 'AllowNoDirection': x = selseg.attributes.allowNoDirection; break; case 'SegmentID': x = selseg.attributes.id; break; case 'Closure': x = 'none'; if (selseg.attributes.hasClosures) { for (var clID in Waze.model.roadClosures.objects) { if (Waze.model.roadClosures.objects[clID].segID == selseg.attributes.id) { if (Waze.model.roadClosures.objects[clID].active) { x = 'active'; } else { x = 'future'; } } } }
                                            break; case 'TBR': x = (selseg.attributes.fwdRestrictions.length + selseg.attributes.revRestrictions.length) > 0 ? true : false; break; case 'Place Name': x = selseg.attributes.name; break; case 'Brand': x = (Util.defined(selseg.attributes.brand)) ? selseg.attributes.brand : ""; break; case 'Primary Category': x = (Util.defined(selseg.attributes.categories[0])) ? I18n.translations[I18n.locale].venues.categories[selseg.attributes.categories[0]] : ""; break; case 'Place Type': if (selseg.attributes.geometry.CLASS_NAME == 'OpenLayers.Geometry.Point') { x = 'Point'; } else { x = 'Area'; }
                                                break; case 'Public': x = ((selseg.attributes.residential == false) ? 'true' : 'false'); break; case 'Place Approved': x = (Util.defined(selseg.attributes.approved)) ? selseg.attributes.approved : 'false'; break; case 'Pending Updates': x = ((selseg.attributes.venueUpdateRequests[0] == null) ? 0 : selseg.attributes.venueUpdateRequests.length); break; case 'Image Count': x = ((selseg.attributes.images[0] == null) ? 0 : selseg.attributes.images.length); break; case 'House Number': x = (Util.defined(selseg.attributes.houseNumber)) ? selseg.attributes.houseNumber : ""; break; case 'Image Preview': var venueImageCheck = (Util.defined(selseg.attributes.images[0])) ? selseg.attributes.images[0].attributes.id : ""; var venueImageHref = '<a href=' + Waze.Config.venues.image_bucket_url + 'thumbs/thumb700_' + venueImageCheck + ' target="_blank"><img src="' + Waze.Config.venues.image_bucket_url + 'thumbs/thumb700_' + venueImageCheck + '"  height="50"</img></a>'; x = (Util.defined(selseg.attributes.images[0])) ? venueImageHref : ""; break; case 'Speed Limit AB': x = selseg.attributes["fwdMaxSpeed"] ? selseg.attributes["fwdMaxSpeed"] + ' kph' : 'unset'; break; case 'Speed Limit BA': x = selseg.attributes["revMaxSpeed"] ? selseg.attributes["revMaxSpeed"] + ' kph' : 'unset'; break;
        }
        return x;
    }; var WMETB_mapObj = function (obj, f) {
        'use strict'; var list = []; for (var key in obj) { var value = obj[key]; list.push(value[f]); }
        return list.unique();
    }, WMETB_getUrlVars = function (href) {
        'use strict'; var vars = {}, hash; var idx = href.indexOf('?'); var hashes = href.slice(idx + 1).split('&'); vars[0] = href.slice(0, idx); for (var i = 0; i < hashes.length; i++) { hash = hashes[i].split('='); vars[hash[0]] = hash[1]; }
        return vars;
    }, WMETB_getCoord = function () { 'use strict'; var mapLoc = localStorage.getItem("mapLocation"); mapLoc = JSON.parse(mapLoc); var b = OpenLayers.Projection.transform({ x: mapLoc.lon, y: mapLoc.lat }, Waze.map.projection, Waze.map.displayProjection); mapLoc.lon = b.x; mapLoc.lat = b.y; return mapLoc; }; tb.push(0); var WMETB_isBadRoundabout = function (seg) {
        if (seg.attributes.junctionID == null) return { errorCode: 1, message: "Segment has no roundabout property." }; if (Waze.model.junctions.objects.hasOwnProperty(seg.attributes.junctionID) == false) return { errorCode: 2, message: "Roundabout information is not loaded in WME.<br>Suggestion: move the map and/or refresh WME." }; var junction = Waze.model.junctions.objects[seg.attributes.junctionID]; var segToTest = null; for (var i = 0; i < junction.segIDs.length; i++) {
            if (Waze.model.segments.objects.hasOwnProperty(junction.segIDs[i]) == false)
                return { errorCode: 3, message: "A segment is not loaded in WME.<br>Suggestion: move the map, or reload WME. Still this error: redo the roundabout." }; segToTest = Waze.model.segments.objects[junction.segIDs[i]]; if (segToTest.attributes.junctionID != junction.id) return { errorCode: 4, message: "A segment is not properly attached to the roundabout.<br>Suggestion: redo the roundabout." };
        }
        var loopClosed = false; segToTest = seg; var startNodeID = segToTest.attributes.fromNodeID; var nextNodeID = segToTest.attributes.fromNodeID; while (!loopClosed) {
            if (nextNodeID == segToTest.attributes.fromNodeID)
                nextNodeID = segToTest.attributes.toNodeID; else
                nextNodeID = segToTest.attributes.fromNodeID; if (nextNodeID == startNodeID)
                { loopClosed = true; break; }
            var nextNode = Waze.model.nodes.objects[nextNodeID]; var nextSegFound = false; for (var i = 0; i < nextNode.attributes.segIDs.length; i++) {
                if (nextNode.attributes.segIDs[i] == segToTest.attributes.id) continue; if (junction.segIDs.indexOf(nextNode.attributes.segIDs[i]) != -1)
                { segToTest = Waze.model.segments.objects[nextNode.attributes.segIDs[i]]; nextSegFound = true; break; }
            }
            if (!nextSegFound)
                break;
        }
        if (!loopClosed) return { errorCode: 5, message: "The roundabout is not a loop.<br>Suggestion: properly connect segments and re-check." }; for (var segID in Waze.model.segments.objects) {
            if (Waze.model.segments.objects.hasOwnProperty(segID)) {
                if (Waze.model.segments.objects[segID].attributes.junctionID == junction.id && junction.segIDs.indexOf(parseInt(segID)) == -1)
                    return { errorCode: 6, message: "Another segment (id: " + segID + ") loaded in WME is attached to this roundabout but is not listed in the roundabout information.<br>Suggestion: delete this segment and re-create it. This will remove the roundabout information attached to it. Then, re-check this roundabout." };
            }
        }
        for (var i = 0; i < junction.segIDs.length; i++) {
            segToTest = Waze.model.segments.objects[junction.segIDs[i]]; var node = null; if (segToTest.attributes.fwdDirection == true)
                node = Waze.model.nodes.objects[segToTest.attributes.toNodeID]; else
                node = Waze.model.nodes.objects[segToTest.attributes.fromNodeID]; var allowedCount = 0; for (var j = 0; j < node.attributes.segIDs.length; j++) {
                    var anotherSegToTest = Waze.model.segments.objects[node.attributes.segIDs[j]]; if (anotherSegToTest.attributes.junctionID == junction.id)
                        continue; if (segToTest.isTurnAllowed(anotherSegToTest, node))
                            allowedCount++;
                }
            if (allowedCount >= 2)
                return { errorCode: 7, message: "A node has " + allowedCount + " exits.<br>Suggestion: connect segments to the roundabout on distinct nodes." };
        }
        var segList = WMETB_findOneWayLoop(seg, true, false, true, junction.id); if (segList.length == 0)
        { return { errorCode: 8, message: "All segments are not in the same way.<br>Suggestion: fix the directionality of the segments." }; }
        var geom = WMETB_RDBExtractPolygon(junction.id); if (!geom) return { errorCode: 10, message: "This roundabout has only one segment and thus forms a loop.<br>Suggestion: consider deleting the roundabout." }; var vertices = geom.getVertices(); var area = 0; for (var i = 0; i < (vertices.length) ; i++)
        { var j = (i + 1) % vertices.length; area += vertices[i].x * vertices[j].y; area -= vertices[j].x * vertices[i].y; }
        if ((area < 0 && !Waze.model.countries.top.leftHandTraffic) || (area >= 0 && Waze.model.countries.top.leftHandTraffic))
            return { errorCode: 9, message: "The roundabout is not in the right direction.<br>Suggestion: change all segment driving direction." }; return { errorCode: 0, message: "This roundabout is correct." };
    }
    var WMETB_TriTab = function (tab1) {
        'use strict'; var n = tab1.length, tab = new Array(n), seg, finPrevX, finPrevY, debutNextX, debutNextY, finNextX, finNextY; tab[0] = tab1[0]; tab.reverse = false; tab.consecutive = true; tab.createdOn = new Date(); for (var i = 0; i < n; i++) {
            if (tab1[i] < tab[0])
                tab[0] = tab1[i]; var seg = Waze.model.segments.objects[tab1[i]]; if (seg.attributes.createdOn < tab.createdOn)
                    tab.createdOn.setTime(seg.attributes.createdOn);
        }
        var debutX, debutY, finX, finY; for (var i = 1; i < n; i++) {
            var seg = Waze.model.segments.objects[tab[i - 1]]; if (seg !== undefined) {
                var finPrevX = seg.geometry.components[seg.geometry.components.length - 1].x; var finPrevY = seg.geometry.components[seg.geometry.components.length - 1].y; for (var j = 0; j < n; j++) {
                    var seg = Waze.model.segments.objects[tab1[j]]; debutNextX = seg.geometry.components[0].x; var debutNextY = seg.geometry.components[0].y; var finNextX = seg.geometry.components[seg.geometry.components.length - 1].x; var finNextY = seg.geometry.components[seg.geometry.components.length - 1].y; if ((finPrevX == debutNextX) && (finPrevY == debutNextY))
                        tab[i] = tab1[j]; if (((finPrevX == finNextX) && (finPrevY == finNextY)) && (tab[i - 1] != tab1[j])) { tab[i] = tab1[j]; tab.reverse = true; }
                }
            }
        }
        for (var i = 1; i < n; i++) {
            if (tab[i] != (tab[i - 1] + 1))
                tab.consecutive = false;
        }
        return tab;
    }; var WMETB_findOneWayLoop = function (seg, mustBeDrivable, mustBeGreenTurn, mustBeOneWay, junctionID) {
        if (seg.attributes.fwdDirection == seg.attributes.revDirection)
            return []; var segList = []; var startNodeID = null; var visitedNodes = []; if (seg.attributes.fwdDirection)
                startNodeID = seg.attributes.fromNodeID; else
                startNodeID = seg.attributes.toNodeID; while (true) {
                    segList.push(seg); var nextNode = null; if (seg.attributes.fwdDirection)
                        nextNode = Waze.model.nodes.objects[seg.attributes.toNodeID]; else
                        nextNode = Waze.model.nodes.objects[seg.attributes.fromNodeID]; if (nextNode.attributes.id == startNodeID)
                        { break; }
                    if (visitedNodes.indexOf(nextNode.attributes.id) != -1)
                    { segList = []; break; }
                    visitedNodes.push(nextNode.attributes.id); seg = WMETB_findMostLRSegment(nextNode, seg, mustBeDrivable, mustBeGreenTurn, mustBeOneWay, junctionID); if (seg == null)
                    { segList = []; break; }
                }
        return segList;
    }; var WMETB_Select_RoundAbout = function () {
        if (Enable_WMETB_Select_RoundAbout && sec.WMETB_RightsCheck("SelRB")) {
            var rbtID = Waze.selectionManager.selectedItems[0].model.attributes.junctionID; var rbtSegments = new Array(); for (var seg in Waze.model.segments.objects) { if (Waze.model.segments.objects[seg].attributes.junctionID == rbtID) { rbtSegments.push(Waze.model.segments.objects[seg]); } }
            Waze.selectionManager.select(rbtSegments);
        } else {
            var seg = Waze.selectionManager.selectedItems[0].model; var segList = []; if (seg.attributes.fwdDirection != seg.attributes.revDirection) {
                segList = WMETB_findOneWayLoop(seg, true, true, true, null); if (segList.length != 0)
                { Waze.selectionManager.select(segList); WMETB_RegularLoopSegIds = segList.map(function (s) { return s.attributes.id; }); WMETB_RegularLoopSegIds.sort(function (a, b) { return a - b }); console.log(WMETB_RegularLoopSegIds); }
                else
                    WMETB_DispWarn("No regular loop detected");
            }
            else
                WMETB_DispWarn("No roundabout segment selected");
        }
    }; var WMETB_extract_rdt = function (listIDs) {
        'use strict'; var rdt = {}; rdt.listAdjRoadIds = new Array(); rdt.higherRank = false; rdt.lockRank = 0; rdt.Toll = false; rdt.listRoadIds = listIDs; rdt.primaryStreetID = null; rdt.level = -5; var xmin = 10000000000000; var ymin = xmin; var xmax = -10000000000000; var ymax = xmax; for (var i = 0; i < rdt.listRoadIds.length; i++) {
            var road = Waze.model.segments.objects[rdt.listRoadIds[i]]; if (road != null) {
                rdt.level = Math.max(rdt.level, road.attributes.level); rdt.primaryStreetID = road.attributes.primaryStreetID; rdt.higherRank = rdt.higherRank || !road.arePropertiesEditable(); if (rdt.lockRank < road.getLockRank())
                    rdt.lockRank = road.getLockRank(); if (road.attributes.fwdToll === true || road.attributes.revToll === true) { rdt.Toll = true; }
                for (var j = 0; j < road.geometry.components.length; j++) { xmin = Math.min(xmin, road.geometry.components[j].x); xmax = Math.max(xmax, road.geometry.components[j].x); ymin = Math.min(ymin, road.geometry.components[j].y); ymax = Math.max(ymax, road.geometry.components[j].y); }
            }
        }
        rdt.listNodeIds = WMETB_extractNodes(rdt.listRoadIds); rdt.rx = (xmax - xmin) / 2; rdt.ry = (ymax - ymin) / 2; rdt.centerX = (xmin + xmax) / 2; rdt.centerY = (ymin + ymax) / 2; for (var i = 0; i < rdt.listNodeIds.length; i++) {
            var node = Waze.model.nodes.objects[rdt.listNodeIds[i]]; if (node != null) {
                var nbSegs = node.attributes.segIDs.length; for (var j = 0; j < nbSegs; j++) {
                    var road = Waze.model.segments.objects[node.attributes.segIDs[j]]; if ((road != null) && (WMETB_notInArray(road.attributes.id, rdt.listRoadIds))) {
                        rdt.higherRank = rdt.higherRank || !road.arePropertiesEditable(); if (WMETB_isInArray(road.attributes.fromNodeID, rdt.listNodeIds)) { rdt.listAdjRoadIds.push({ id: road.getID(), sideConnect: "A" }); }
                        if (WMETB_isInArray(road.attributes.toNodeID, rdt.listNodeIds)) { rdt.listAdjRoadIds.push({ id: road.getID(), sideConnect: "B" }); }
                    }
                }
            }
        }
        var streetID = WMETB_captureCity(rdt.listRoadIds); return rdt;
    }, WMETB_searchNewRdt = function (listRdtSegIds, StreetID, oldRdtLockRank, oldRdtToll, ma) {
        'use strict'; var roadpriority = new Array(); roadpriority[1] = 0; roadpriority[2] = 1; roadpriority[3] = 3; roadpriority[4] = 0; roadpriority[6] = 3; roadpriority[7] = 2; roadpriority[8] = 0; roadpriority[18] = 0; roadpriority[19] = 0; roadpriority[20] = 0; roadpriority[5] = 0; roadpriority[10] = 0; roadpriority[16] = 0; roadpriority[17] = 0; roadpriority[21] = 0; var priorityToRoadtype = new Array(); priorityToRoadtype[0] = 1; priorityToRoadtype[1] = 2; priorityToRoadtype[2] = 7; priorityToRoadtype[3] = 6; var compteur = [0, 0, 0, 0]; var listRdtNodeIds = new Array(); for (var i = 0; i < listRdtSegIds.length; i++) { var road = Waze.model.segments.objects[listRdtSegIds[i]]; if (road != null) { listRdtNodeIds.push(road.attributes.fromNodeID); listRdtNodeIds.push(road.attributes.toNodeID); } }
        listRdtNodeIds = WMETB_delete_multi_Ids(listRdtNodeIds); var usedNodeIDs = new Array(); usedNodeIDs.push.apply(usedNodeIDs, listRdtNodeIds); var rdt = {}; for (var i = 0; i < listRdtNodeIds.length; i++) {
            var node = Waze.model.nodes.objects[listRdtNodeIds[i]]; if (node != null) {
                var nbSegs = node.attributes.segIDs.length; for (var j = 0; j < nbSegs; j++) {
                    var road = Waze.model.segments.objects[node.attributes.segIDs[j]]; if ((road != null) && (WMETB_notInArray(road.attributes.id, listRdtSegIds))) {
                        if (road.attributes.roadType == 3) { ma.doSubAction(new UpdateObject(road, { roadType: 6 })); }
                        if (WMETB_notInArray(road.attributes.roadType, ([1, 2, 3, 4, 6, 7]))) { ma.doSubAction(new UpdateObject(road, { roadType: 1 })); }
                        if (!road.attributes.fwdDirection && !road.attributes.revDirection) { ma.doSubAction(new UpdateObject(road, { fwdDirection: true, revDirection: true })); }
                        if (road.attributes.primaryStreetID == null && StreetID != null) { ma.doSubAction(new UpdateObject(road, { primaryStreetID: StreetID })); }
                        if (WMETB_notInArray(road.attributes.fromNodeID, usedNodeIDs) || WMETB_notInArray(road.attributes.toNodeID, usedNodeIDs)) { compteur[roadpriority[road.attributes.roadType]]++; usedNodeIDs.push(usedNodeIDs, road.attributes.fromNodeID); usedNodeIDs.push(usedNodeIDs, road.attributes.toNodeID); }
                    }
                }
            }
        }
        rdt.roadtype = priorityToRoadtype[0]; var foundMax = false; for (var i = 3; i > 0; i--) { if ((compteur[i] > 1) && (foundMax === false)) { rdt.roadtype = priorityToRoadtype[i]; foundMax = true; } else { compteur[i - 1] = compteur[i - 1] + compteur[i]; compteur[i] = 0; } }
        return rdt;
    }; var WMETB_RDBExtractPolygon = function (junctionID) {
        if (Waze.model.junctions.objects.hasOwnProperty(junctionID) == false)
            return null; var segIDs = Waze.model.junctions.objects[junctionID].segIDs; if (segIDs.length == 0)
                return null; var i = 0; while (i < segIDs.length && Waze.model.segments.objects.hasOwnProperty(segIDs[i]) == false) i++; if (i == segIDs.length)
                    return null; var seg = Waze.model.segments.objects[segIDs[i]]; var firstSegID = segIDs[i]; var polyPoints = new Array(); var finished = false; while (!finished) {
                        var followNode = null; var vertices = seg.geometry.getVertices(); if (seg.attributes.fwdDirection) {
                            for (var j = 0; j < vertices.length - 1; j++)
                                polyPoints.push(vertices[j]); followNode = Waze.model.nodes.objects[seg.attributes.toNodeID];
                        }
                        else {
                            for (var j = vertices.length - 1; j > 0; j--)
                                polyPoints.push(vertices[j]); followNode = Waze.model.nodes.objects[seg.attributes.fromNodeID];
                        }
                        var nextSeg = null; for (var j = 0; j < followNode.attributes.segIDs.length; j++) {
                            nextSeg = Waze.model.segments.objects[followNode.attributes.segIDs[j]]; if (nextSeg.attributes.id == seg.attributes.id) continue; if (nextSeg.attributes.junctionID == null || nextSeg.attributes.junctionID != junctionID) continue; if (nextSeg.attributes.id == firstSegID)
                            { finished = true; break; }
                            break;
                        }
                        if (!finished && nextSeg.attributes.id == seg.attributes.id)
                        { return null; }
                        seg = nextSeg;
                    }
        var polygon = new OpenLayers.Geometry.Polygon(new OpenLayers.Geometry.LinearRing(polyPoints)); polygon.calculateBounds(); return polygon;
    }
    tb.push(61); tc.push(0); var WMETB_Clear_Road_Geometry = function (ev) {
        if (Enable_WMETB_Clear_Road_Geometry && sec.WMETB_RightsCheck("ClearGeom")) {
            if (Waze.selectionManager.selectedItems.length != 0) {
                for (var i = 0; i < Waze.selectionManager.selectedItems.length; i++) { var sel = Waze.selectionManager.selectedItems[i]; var seg = sel.model; if (seg.type == "segment") { var newGeo = seg.geometry.clone(); newGeo.components.splice(1, newGeo.components.length - 2); newGeo.components[0].calculateBounds(); newGeo.components[1].calculateBounds(); Waze.model.actionManager.add(new UpdateSegmentGeometry(seg, seg.geometry, newGeo)); } }
                WMETB_DispLog("Road geometry cleared");
            }
        } else { WMETB_DispWarn("No segment selected"); }
    }; tb.push(15); var WMETB_getQueryString = function (link, name) {
        'use strict'; WMETB_Debug("link:" + link); WMETB_Debug("name:" + name); var pos = link.indexOf(name + '=') + name.length + 1; WMETB_Debug("pos:" + pos); var len = link.substr(pos).indexOf('&'); if (len == -1) { len = link.substr(pos); }
        WMETB_Debug("len:" + len); var data = link.substr(pos, len); WMETB_Debug("data:" + data); return data;
    }; tb.push(17); var WMETB_ResetElevation = function () {
        'use strict'; var count = 0; if (Waze.selectionManager.selectedItems.length != 0) {
            for (var i = 0; i < Waze.selectionManager.selectedItems.length; i++) { var seg = Waze.selectionManager.selectedItems[i].model; if (seg.arePropertiesEditable()) { if (seg.type == "segment" && seg.attributes.level != 0) { Waze.model.actionManager.add(new UpdateObject(seg, { level: 0 })); count++; } } }
            WMETB_DispLog(count + " elevation" + (count != 1 ? "s" : "") + " reset to ground");
        } else { WMETB_DispWarn("No segment selected"); }
    }; tc.push(1); var WMETB_EnterAddress = function (clearCity) {
        'use strict'; if (Waze.selectionManager.selectedItems.length > 0) {
            $('.address-edit-btn').click(); if (clearCity && document.getElementById('emptyCity').checked)
                $('#emptyCity').click(); if (document.getElementById('emptyState') !== null) {
                    if (document.getElementById('emptyState').checked)
                        $('#emptyState').click();
                }
            if (document.getElementById('emptyStreet').checked)
                $('#emptyStreet').click(); $('[name=streetName]').select();
        };
    }; var WMETB_EnterAddressNoClearCity = function () { WMETB_EnterAddress(false); }
    var WMETB_EnterAddressPrefill = function () {
        'use strict'; if (Waze.selectionManager.selectedItems.length > 0) {
            WMETB_EnterAddress(true); if (Waze.model.segments.topCityID) {
                var topCity = Waze.model.cities.get(Waze.model.segments.topCityID); if (!$('[name=cityName]').val()) { $('[name=cityName]').val(topCity.attributes.name); }
                if (Waze.model.states.top.id !== 1) { $('[name=stateID]').val(Waze.model.states.top.id); }
                if (Waze.model.countries.top.id !== 1) { $('[name=countryID]').val(Waze.model.countries.top.id); }
            }
        };
    }; tb.push(2); var WMETB_SplitRoad = function (road) {
        'use strict'; if (road.arePropertiesEditable()) {
            var geo = road.geometry.clone(); WMETB_Debug("WMETB_SplitRoad - geo.components.length=" + geo.components.length); var action = null; if (geo.components.length <= 2) { geo.components.splice(1, 0, new OL.Geometry.Point(((geo.components.last().x + geo.components.first().x) / 2), ((geo.components.last().y + geo.components.first().y) / 2))); Waze.model.actionManager.add(new UpdateSegmentGeometry(road, road.geometry, geo)); WMETB_Debug("WMETB_SplitRoad - create new geonode"); }
            action = new SplitSegments(road, { splitAtPoint: road.geometry.components[Math.ceil(road.geometry.components.length / 2 - 1)] }); WMETB_Debug("WMETB_SplitRoad - split on existing point"); Waze.model.actionManager.add(action); var RoadIds = new Array(); if (action.splits !== null) { for (var i = 0; i < action.splits.length; i++) { RoadIds.push(action.splits[i].attributes.id); } }
            return RoadIds;
        }
    }, WMETB_Split_Road = function () {
        'use strict'; if (Enable_WMETB_Split_Road && sec.WMETB_RightsCheck("CutSeg")) {
            var RoadIds = new Array(); var numberOfCuts = 0; if (Waze.selectionManager.selectedItems.length != 0) {
                var segtosplit = []; for (var i = 0; i < Waze.selectionManager.selectedItems.length; i++) { segtosplit.push(Waze.selectionManager.selectedItems[i]); }
                for (var i = 0; i < segtosplit.length; i++) {
                    var seg = segtosplit[i].model; var attr = seg.attributes; if (seg.type == "segment" && attr.junctionID === null && (!seg.getDirection() || !WMETB_nonDividableRoadTypes.contains(attr.roadType))) {
                        RoadIds = WMETB_SplitRoad(seg); if (RoadIds !== undefined)
                            numberOfCuts++;
                    }
                }
                if (numberOfCuts > 0) { WMETB_DispLog(numberOfCuts + (numberOfCuts > 1 ? " segments" : " segment") + " cut in two"); } else { WMETB_DispWarn("Segment(s) could not be cut"); }
            }
        } else { WMETB_DispWarn("No segment selected"); }
    }; tb.push(4); var WMETB_CreateJunctions = function () {
        if (!WMETB_ToSave.ToolbarFeatures.CreateJunctions || !sec.WMETB_RightsCheck("CreateJunc"))
            return; if (Waze.selectionManager.selectedItems.length < 2) { WMETB_DispWarn("Please select at least 2 segments"); return; }
        var changes = true; var numberOfNewJunctions = 0; while (changes) {
            var segs = Waze.selectionManager.selectedItems.filter(function (seg) {
                if ((seg.model.state !== OpenLayers.State.DELETE) && (!seg.model.getDirection() || !WMETB_nonDividableRoadTypes.contains(seg.model.attributes.roadType)))
                    return true; return false;
            }); var newObj = null; segs = _(segs).pluck("model"); changes = false; segs.some(function (seg) {
                segs.some(function (segToTest) {
                    if (seg.attributes.id == segToTest.attributes.id) return false; if (seg.attributes.level != segToTest.attributes.level) return false; var newGeom = seg.geometry.split(segToTest.geometry, { edge: true, mutual: true }); if (newGeom != null) {
                        var splitOK = true; for (var i = 0; i < newGeom[0].length; i++) {
                            if (newGeom[0][i].components.length == 2) {
                                var x1 = newGeom[0][i].components[0].x; var y1 = newGeom[0][i].components[0].y; var x2 = newGeom[0][i].components[1].x; var y2 = newGeom[0][i].components[1].y; var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); if (length < 0.0001)
                                { splitOK = false; break; }
                            }
                        }
                        if (splitOK == true)
                        { newObj = new AddIntersection([seg, segToTest], newGeom); numberOfNewJunctions++; Waze.model.actionManager.add(newObj); var selectionSet = _(Waze.selectionManager.selectedItems).pluck("model").concat(newObj.sourceSplits, newObj.targetSplits); Waze.selectionManager.select(selectionSet); changes = true; return true; }
                    }
                }); return changes;
            });
        }
        if (numberOfNewJunctions > 0) { WMETB_DispLog(numberOfNewJunctions + (numberOfNewJunctions > 1 ? " junctions" : " junction") + " created"); } else { WMETB_DispWarn("No intersecting segments found on same elevation (within selection)"); }
    }; tc.push(1); var WMETB_DispLog = function (msg, prefix) { 'use strict'; if (prefix !== true) msg = "WME Toolbox: " + msg; var obj = $('<div id="mylog">').append(msg).css('background-color', 'rgba(0, 0, 100, 0.6)'); $('#WMETB_logger').append(obj); obj.delay(3000).slideUp({ duration: 200, complete: function () { obj.remove(); } }); }, WMETB_DispWarn = function (msg, prefix, delayMS) {
        'use strict'; if (typeof delayMS === 'undefined') { var warnDelay = 3000 } else { warnDelay = delayMS }
        if (prefix !== true) msg = "WME Toolbox: " + msg; var obj = $('<div id="mylog">').append(msg).css('background-color', 'rgba(255, 150, 0, 0.6)'); $('#WMETB_logger_warn').append(obj); obj.delay(warnDelay).slideUp({ duration: 200, complete: function () { obj.remove(); } });
    }, WMETB_DispErr = function (msg) { 'use strict'; if (msg !== undefined && msg !== "undefined") { var href = $('.WazeControlPermalink a.fa-link')[0].href; prompt("WME Toolbox: please report this error (use Ctrl-C to copy):", msg + "|" + msg.stack + "|" + href + "|" + sec.WMETB_VerifiedUserName + "|" + sec.WMETB_VerifiedUserRank + "|" + WMETB_getnav()); } }, WMETB_blink = function (selector) { 'use strict'; $(selector).fadeOut('slow', function () { $(this).fadeIn('slow', function () { WMETB_blink(this); }); }); }, WMETB_Debug = function (msg) { 'use strict'; if (sec.WMETB_Debug_Users.indexOf(sec.WMETB_VerifiedUserName) > -1) { console.debug("WMETB: " + msg); } }; tb.push(42); var wme_version_regex = /WME\.min\.js\?v=([0-9]+)/g; WMETB_JNF_Version = "Toolbox 0096"; var WMETB_JNF_matched = false; var WME_Version = undefined; var WMETB_JNF_storage, WMETB_JNF_fail, WMETB_JNF_uid; var WMETB_JNF_options = {}; var WCENC = null; var WCCHAT = null; var WCLU = null; var WCUR = null; var WCMP = null; var WMETB_oldHook = true; function WMETB_JNF_PatchAndReload() { }
    function WMETB_JNF_SaveEnd(b) { console.log("WMETB-JNF: Save %s", b.success ? "succeeded" : "failed"); }
    function WMETB_JNF_smn(s1, s2) {
        var pmap = [0, 10, 11, 15, 14, 1, 13, 12, 8, 0, 3, 0, 0, 0, 0, 0, 2, 7, 5, 4, 6, 9]; var mod = null; if (s1.isGeometryEditable() && !s2.isGeometryEditable()) { console.log("WMETB-JNF: only s1 can be modified"); mod = s1; } else if (!s1.isGeometryEditable() && s2.isGeometryEditable()) { console.log("WMETB-JNF: only s2 can be modified"); mod = s2; } else if (s1.isGeometryEditable() && s2.isGeometryEditable()) { if (pmap[s1.attributes.roadType] < pmap[s2.attributes.roadType]) { console.log("WMETB-JNF: s1 lower type"); mod = s1; } else if (pmap[s1.attributes.roadType] > pmap[s2.attributes.roadType]) { console.log("WMETB-JNF: s2 lower type"); mod = s2; } else { if (s1.attributes.length > s2.attributes.length) { console.log("WMETB-JNF: s1 longer"); mod = s1; } else if (s1.attributes.length < s2.attributes.length) { console.log("WMETB-JNF: s2 longer"); mod = s2; } else { if (s1.attributes.createdOn > s2.attributes.createdOn) { console.log("WMETB-JNF: s1 newer"); mod = s1; } else if (s1.attributes.createdOn < s2.attributes.createdOn) { console.log("WMETB-JNF: s2 newer"); mod = s2; } else { if (s1.getID() > s2.getID()) { console.log("WMETB-JNF: s1 higher id"); mod = s1; } else { console.log("WMETB-JNF: s2 higher id"); mod = s2; } } } } } else { console.log("WMETB-JNF: cannot modify either."); }
        if (mod) {
            if (!mod.attributes.junctionID) {
                var point; if (mod.geometry.components.length > 2) { console.log("WMETB-JNF: Splitting: " + mod.getID() + " on geo point " + (Math.ceil(mod.geometry.components.length / 2) - 1) + " of " + mod.geometry.components.length); point = mod.geometry.components[Math.ceil(mod.geometry.components.length / 2) - 1]; } else { point = mod.getCenter(); console.log("WMETB-JNF: Splitting:", mod.getID(), "at center."); }
                W.model.actionManager.add(new global.SplitSegments(mod, { splitAtPoint: point }));
            }
        }
    }
    function WMETB_JNF_CleanRBT(jct) {
        var roadTypes = { "street": 1, "primary": 2, "freeway": 3, "ramp": 4, "trail": 5, "major": 6, "minor": 7, "dirt": 8, "boardwalk": 10, "stairway": 16, "private": 17, "railroad": 18, "runway": 19, "parking": 20, "service": 21 }; var typenames = { 1: "street", 2: "primary", 3: "freeway", 4: "ramp", 5: "trail", 6: "major", 7: "minor", 8: "dirt", 10: "boardwalk", 16: "stairway", 17: "private", 18: "railroad", 19: "runway", 20: "parking", 21: "service" }; var prec = [4, 6, 7, 2, 1, 21, 17, 20, 8]; if (jct.valid == true) {
            var types = {}; var roadtype = false; var cities = {}; var i = 0; var cityid = 0; var street = null; var city = null; var state = null; var country = null; var update = true; var street_updated = false; var type_updated = false; var nodes = {}; jct.segIDs.forEach(function (segid) {
                var seg = W.model.segments.get(segid); for (var i = 0; i < seg.geometry.components.length; i++)
                    if (!onScreen(seg))
                        update = false;
            }); if (update == false)
                return; jct.segIDs.forEach(function (segid) {
                    var seg = W.model.segments.get(segid); if (seg.attributes.primaryStreetID) {
                        street = W.model.streets.get(seg.attributes.primaryStreetID); city = W.model.cities.get(street.cityID).attributes; if (city) {
                            if (!cities[street.cityID])
                                cities[street.cityID] = 0; if (!city.isEmpty)
                                    cities[street.cityID] += 100;
                        }
                    }
                    nodes[seg.attributes.toNodeID] = W.model.nodes.get(seg.attributes.toNodeID); nodes[seg.attributes.fromNodeID] = W.model.nodes.get(seg.attributes.fromNodeID);
                }); Object.forEach(nodes, function (k, node) {
                    node.attributes.segIDs.forEach(function (csegid) {
                        var cseg = W.model.segments.get(csegid); if (!cseg.attributes.junctionID) {
                            if (cseg.attributes.roadType != roadTypes["freeway"]) {
                                if (!types[cseg.attributes.roadType])
                                    types[cseg.attributes.roadType] = 0; if (cseg.attributes.fwdDirection)
                                        types[cseg.attributes.roadType] += 1; if (cseg.attributes.revDirection)
                                            types[cseg.attributes.roadType] += 1; if (cseg.attributes.primaryStreetID) {
                                                street = W.model.streets.get(cseg.attributes.primaryStreetID); city = W.model.cities.get(street.cityID).attributes; if (city) {
                                                    if (!cities[street.cityID])
                                                        cities[street.cityID] = 0; if (city.isEmpty) { cities[street.cityID] += 1; } else { cities[street.cityID] += 2; }
                                                }
                                            }
                            }
                        }
                    });
                }); i = 0; Object.forEach(cities, function (k, v) { if (i < v) { i = v; cityid = k; } }); street = W.model.streets.getByAttributes({ isEmpty: true, cityID: cityid }).first(); city = W.model.cities.get(cityid).attributes; if (city)
                    country = W.model.countries.get(city.countryID); state = null; if (city && city.stateID)
                        state = W.model.states.get(city.stateID); var j; for (i = 0; i < prec.length && !roadtype; i++) {
                            if (city.countryID == 234 && prec[i] == 4)
                                continue; if (prec[i] in types) {
                                    if (types[prec[i]] > 3 || (types[prec[i]] && city.countryID == 234)) { roadtype = prec[i]; } else { for (j = i + 1; j < prec.length && !roadtype; j++) { if (types[prec[j]] > 1) { roadtype = prec[j]; } } }
                                    if (!roadtype)
                                        roadtype = prec[i];
                                }
                        }
            jct.segIDs.forEach(function (segid) {
                var seg = W.model.segments.get(segid); if (seg.attributes.roadType != roadtype) { W.model.actionManager.add(new global.UpdateObject(seg, { roadType: roadtype })); if (!type_updated) { console.log("WMETB-JNF_RBT: road type: " + roadtype + " " + typenames[roadtype]); type_updated = true; } }
                if (!seg.attributes.primaryStreetID || (street && seg.attributes.primaryStreetID != street.id)) {
                    W.model.actionManager.add(new global.UpdateFeatureAddress(seg, { countryID: city.countryID, stateID: city.stateID, cityName: city.name, emptyStreet: true }, { streetIDField: "primaryStreetID" })); if (!street_updated) {
                        if (state.name != "Other")
                            console.log("WMETB-JNF_RBT: " + city.name + ", " + state.name + ", " + country.name); else
                            console.log("WMETB-JNF_RBT: " + city.name + ", " + country.name); street = W.model.streets.getByAttributes({ isEmpty: true, cityID: cityid }).first(); console.log("WMETB-JNF_RBT: street: %o ", street); street_updated = true;
                    }
                }
            }); Object.forEach(nodes, function (k, node) { WMETB_JNF_FixNode(node, false); });
        }
    }
    function WMETB_JNF_DAT(a) {
        if (WMETB_oldHook) {
            if (!a.enabled)
                return; WMETB_JNF_FixNode(a.selectedFeature, true);
        }
        else { WMETB_JNF_FixNode(a.model, true); }
    }
    function onScreen(obj) {
        if (obj.geometry) { return (W.map.getExtent().intersectsBounds(obj.geometry.getBounds())); }
        return (false);
    }
    WMETB_JNF_FixNode = function (node, doJunctions) {
        if (!node)
            return; if (!node.type)
                return; if (node.type != "node")
                    return; if (node.areConnectionsEditable() && onScreen(node)) {
                        connections = {}; junctions = {}; for (var i = 0; i < node.attributes.segIDs.length; i++) {
                            var seg = W.model.segments.get(node.attributes.segIDs[i]); if (seg) {
                                if (seg.attributes.toNodeID == seg.attributes.fromNodeID) {
                                    if (seg.attributes.junctionID) { console.log("WMETB-JNF: single node rb"); } else { console.log("WMETB-JNF: single node loop"); }
                                    var seg1geo = seg.geometry.clone(); var seg2geo = seg.geometry.clone(); var seg3geo = seg.geometry.clone(); var mod3 = seg.geometry.components.length % 3; for (var i = 0; i < seg.geometry.components.length / 3 - 1; i++) { seg1geo.components.pop(); seg1geo.components.pop(); seg2geo.components.pop(); seg2geo.components.shift(); seg3geo.components.shift(); seg3geo.components.shift(); }
                                    if (mod3 == 2) { seg1geo.components.pop(); seg3geo.components.shift(); }
                                    if (mod3 == 0) { seg1geo.components.pop(); seg1geo.components.pop(); seg3geo.components.shift(); seg3geo.components.shift(); }
                                    seg1geo.calculateBounds(); seg2geo.calculateBounds(); seg3geo.calculateBounds(); var newseg1, newseg3, ns1ls, ns3ls; if (node.attributes.connections) { newseg1 = new global.FeatureVectorSegment(seg1geo); newseg3 = new global.FeatureVectorSegment(seg3geo); } else { newseg1 = new global.FeatureVectorSegment({ geometry: seg1geo }); newseg3 = new global.FeatureVectorSegment({ geometry: seg3geo }); }
                                    newseg1.copyAttributes(seg); newseg3.copyAttributes(seg); newseg1.attributes.junctionID = null; seg.attributes.junctionID = null; newseg3.attributes.junctionID = null; newseg1.attributes.fromNodeID = null; newseg3.attributes.fromNodeID = null; newseg1.attributes.toNodeID = null; newseg3.attributes.toNodeID = null; if (!node.attributes.connections) { if (seg.setID) { newseg1.setID(null); newseg3.setID(null); } else { newseg1.geometry = seg1geo; newseg3.geometry = seg3geo; } }
                                    var joinsegs = []; joinsegs.push(newseg1); joinsegs.push(seg); W.model.actionManager.add(new global.DisconnectSegment(seg, node)); W.model.actionManager.add(new global.DisconnectSegment(seg, node)); W.model.actionManager.add(new global.UpdateSegmentGeometry(seg, seg.geometry, seg2geo)); W.model.actionManager.add(new global.AddSegment(newseg1)); W.model.actionManager.add(new global.AddSegment(newseg3)); W.model.actionManager.add(new global.ConnectSegment(node, newseg1)); W.model.actionManager.add(new global.ConnectSegment(node, newseg3)); W.model.actionManager.add(new global.AddNode(seg1geo.components.last(), joinsegs)); joinsegs = []
                                    joinsegs.push(seg); joinsegs.push(newseg3); W.model.actionManager.add(new global.AddNode(seg3geo.components.first(), joinsegs)); W.model.actionManager.add(new global.UpdateObject(newseg1, { fwdTurnsLocked: true, revTurnsLocked: true })); W.model.actionManager.add(new global.UpdateObject(seg, { fwdTurnsLocked: true, revTurnsLocked: true })); W.model.actionManager.add(new global.UpdateObject(newseg3, { fwdTurnsLocked: true, revTurnsLocked: true })); W.model.actionManager.add(new global.ModifyAllConnections(newseg1.getToNode(), true)); W.model.actionManager.add(new global.ModifyAllConnections(newseg1.getFromNode(), true)); W.model.actionManager.add(new global.ModifyAllConnections(seg.getToNode(), true)); W.model.actionManager.add(new global.ModifyAllConnections(seg.getFromNode(), true)); W.model.actionManager.add(new global.ModifyAllConnections(newseg3.getToNode(), true)); W.model.actionManager.add(new global.ModifyAllConnections(newseg3.getFromNode(), true));
                                }
                                if (!seg.isDeleted()) {
                                    if (seg.attributes.junctionID) { junctions[seg.attributes.junctionID] = W.model.junctions.get(seg.attributes.junctionID); }
                                    var segments = []; segments.push(seg); if (seg.attributes.toNodeID == null) { W.model.actionManager.add(new global.AddNode(seg.geometry.components.last(), segments)); }
                                    if (seg.attributes.fromNodeID == null) { W.model.actionManager.add(new global.AddNode(seg.geometry.components.first(), segments)); }
                                    var toNode = seg.getToNode(); var fromNode = seg.getFromNode(); if (toNode && fromNode && !toNode.isDeleted() && !fromNode.isDeleted()) {
                                        if (onScreen(toNode) && onScreen(fromNode)) {
                                            if ((seg.attributes.fwdDirection == false || seg.attributes.revDirection == false) && (toNode.attributes.segIDs.length < 2 || fromNode.attributes.segIDs.length < 2))
                                            { console.log("WMETB-JNF: updating dead-end segment " + seg.getID() + " to two-way"); W.model.actionManager.add(new global.UpdateObject(seg, { fwdDirection: true, revDirection: true })); }
                                        }
                                        if (node.attributes.segIDs.length > 1) {
                                            var turnAllowed; if (node.attributes.connections) { turnAllowed = node.isTurnAllowed(seg, seg); } else { turnAllowed = seg.isTurnAllowed(seg, node); }
                                            if (turnAllowed) { console.log("WMETB-JNF: Disabling U-Turn at", node.getID(), "on", seg.getID()); W.model.actionManager.add(new global.ModifyConnection(seg.getID(), node, seg.getID(), false)); }
                                        }
                                    }
                                }
                            }
                        }
                        if (node.attributes.segIDs.length > 1) {
                            var seg1, seg2; for (var i = 0; i < node.attributes.segIDs.length - 1; i++) {
                                seg1 = W.model.segments.get(node.attributes.segIDs[i]); for (var j = i + 1; j < node.attributes.segIDs.length; j++) {
                                    seg2 = W.model.segments.get(node.attributes.segIDs[j]); if (seg1.isDeleted() == false && seg2.isDeleted() == false) {
                                        var fwd_t; var rev_t; var fwd_a; var rev_a; if (node.attributes.connections) { fwd_t = node.isTurnAllowed(seg1, seg2); rev_t = node.isTurnAllowed(seg2, seg1); } else { fwd_t = seg1.isTurnAllowed(seg2, node); rev_t = seg2.isTurnAllowed(seg1, node); }
                                        fwd_a = node.isTurnAllowedBySegDirections(seg1, seg2); rev_a = node.isTurnAllowedBySegDirections(seg2, seg1); if (fwd_t && !fwd_a) { console.log("WMETB-JNF: Disabling RevCon at", node.getID(), "into", seg2.getID()); var turn = Waze.model.getTurnGraph().getTurnThroughNode(node, seg1, seg2); Waze.model.actionManager.add(new global.SetTurn(Waze.model.getTurnGraph(), turn.withTurnData(turn.getTurnData().withState(0)))); }
                                        if (rev_t && !rev_a) { console.log("WMETB-JNF: Disabling RevCon at", node.getID(), "into", seg1.getID()); var turn = Waze.model.getTurnGraph().getTurnThroughNode(node, seg2, seg1); Waze.model.actionManager.add(new global.SetTurn(Waze.model.getTurnGraph(), turn.withTurnData(turn.getTurnData().withState(0)))); }
                                        if ((seg1.attributes.fromNodeID == seg2.attributes.fromNodeID && seg1.attributes.toNodeID == seg2.attributes.toNodeID) || (seg1.attributes.fromNodeID == seg2.attributes.toNodeID && seg1.attributes.toNodeID == seg2.attributes.fromNodeID)) { console.log("WMETB-JNF: sid:", seg1.getID(), "and sid:", seg2.getID(), "connected to same nodes:", seg1.attributes.fromNodeID, seg1.attributes.toNodeID); WMETB_JNF_smn(seg1, seg2); }
                                    }
                                }
                                if (!seg1.isDeleted() && !seg1.areTurnsLocked(node)) {
                                    var attr = seg1.getTurnsLockAttribute(node); var dict = {}
                                    dict[attr] = true; console.log("WMETB-JNF: Locking Turns at", node.getID(), "on", seg1.getID()); W.model.actionManager.add(new global.UpdateObject(seg1, dict));
                                }
                            }
                            if (!seg2.isDeleted() && !seg2.areTurnsLocked(node)) {
                                var attr = seg2.getTurnsLockAttribute(node); var dict = {}
                                dict[attr] = true; console.log("WMETB-JNF: Locking Turns at", node.getID(), "on", seg2.getID()); W.model.actionManager.add(new global.UpdateObject(seg2, dict));
                            }
                        }
                        if (doJunctions) { Object.forEach(junctions, function (i, j) { WMETB_JNF_CleanRBT(j); }); }
                        WCENC.toggleShowAllArrows(); WCENC.toggleShowAllArrows();
                    }
    }
    function WMETB_JNF_CheckAllAPI(attempt, handlerAPIOK, handlerAPIKO) {
        if (WMETB_JNF_CheckAPI())
        { console.log("WMETB-JNF: API check OK"); handlerAPIOK(); }
        else
        {
            if (attempt >= 20)
                handlerAPIKO()
            else
            { window.setTimeout(function () { WMETB_JNF_CheckAllAPI(attempt + 1, handlerAPIOK, handlerAPIKO); }, 1000); }
        }
    }
    function WMETB_JNF_CheckAPI() {
        if (typeof (Waze) != "object") { WMETB_JNF_matched = "Waze"; return false; }
        if (typeof (W.model) != "object") { WMETB_JNF_matched = "W.model"; return false; }
        if (typeof (W.map) != "object") { WMETB_JNF_matched = "W.map"; return false; }
        if (typeof (W.map.controls) != "object") { WMETB_JNF_matched = "W.map.controls"; return false; }
        if (typeof (W.map.controls[0]) != "object") { WMETB_JNF_matched = "W.map.controls[0]"; return false; }
        if (typeof (W.map.controls[0].displayClass) != "string") { WMETB_JNF_matched = "W.map.controls[0].displayClass"; return false; }
        Object.forEach(W.map.controls, function (k, v) {
            if (v.displayClass == "WazeControlEditNodeConnections") { WCENC = v; }
            if (v.displayClass == "WazeControlChat") { WCCHAT = v; }
            if (v.displayClass == "WazeControlMapProblems") { WCMP = v; }
            if (v.displayClass == "WazeControlUpdateRequests") { WCUR = v; }
            if (v.displayClass == "WazeControlLiveUsers") { WCLU = v; }
        }); if (typeof (WCENC) != "object") { WMETB_JNF_matched = "WCENC"; return false; }
        if (typeof (WCCHAT) != "object") { WMETB_JNF_matched = "WCCHAT"; return false; }
        if (typeof (WCMP) != "object") { WMETB_JNF_matched = "WCMP"; return false; }
        if (typeof (WCUR) != "object") { WMETB_JNF_matched = "WCUR"; return false; }
        if (typeof (WCLU) != "object") { WMETB_JNF_matched = "WCLU"; return false; }
        if (typeof (Waze.Config) != "object") { WMETB_JNF_matched = "Waze.Config"; return false; }
        if (typeof (Waze.Config.cameras) != "object") { WMETB_JNF_matched = "Waze.Config.cameras"; return false; }
        if (typeof (Waze.Config.cameras.minDisplayZoom) != "number") { WMETB_JNF_matched = "Waze.Config.cameras.minDisplayZoom"; return false; }
        if (typeof (W.model.cameras) != "object") { WMETB_JNF_matched = "W.model.cameras"; return false; }
        if (typeof (W.model.cameras.minZoom) != "number") { WMETB_JNF_matched = "W.model.cameras.minZoom"; return false; }
        if (typeof (WCENC.showAllArrows) != "boolean") { WMETB_JNF_matched = "WCENC.showAllArrows"; return false; }
        if (typeof (WCENC.showArrows) != "boolean") { WMETB_JNF_matched = "WCENC.showArrows"; return false; }
        if (typeof (WCENC.toggleShowAllArrows) != "function") { WMETB_JNF_matched = "WCENC.toggleShowAllArrows"; return false; }
        if (typeof (W.map.DefaultPanInPixel) != "number") { WMETB_JNF_matched = "W.map.DefaultPanInPixel"; return false; }
        if (typeof (Waze.accelerators) != "object") { if (typeof (Waze.Accelerators) != "object") { WMETB_JNF_matched = "Waze.accelerators"; return false; } else { Waze.accelerators = Waze.Accelerators; } }
        if (typeof (Waze.accelerators.events) != "object") { WMETB_JNF_matched = "Waze.accelerators.events"; return false; }
        if (typeof (Waze.accelerators.events.listeners) != "object") { WMETB_JNF_matched = "Waze.accelerators.events.listeners"; return false; }
        if (typeof (Waze.accelerators.events.listeners.disallowAllConnections) != "object") { WMETB_oldHook = false; }
        if (typeof (W.map.getExtent) != "function") { WMETB_JNF_matched = "W.map.getExtent"; return false; }
        var tstvar = W.map.getExtent(); if (typeof (tstvar) != "object") { WMETB_JNF_matched = "W.map.getExtent()"; return false; }
        if (typeof (tstvar.toGeometry) != "function") { WMETB_JNF_matched = "W.map.getExtent().toGeometry"; return false; }
        var tstvar = tstvar.toGeometry(); if (typeof (tstvar) != "object") { WMETB_JNF_matched = "W.map.getExtent().toGeometry() == object"; return false; }
        if (typeof (tstvar.containsPoint) != "function") { WMETB_JNF_matched = "W.map.getExtent().toGeometry().containsPoint"; return false; }
        if (typeof (W.model.segments) != "object") { WMETB_JNF_matched = "W.model.segments"; return false; }
        if (typeof (W.model.segments.get) != "function") { WMETB_JNF_matched = "W.model.segments.get"; return false; }
        if (typeof (W.model.nodes) != "object") { WMETB_JNF_matched = "W.model.nodes"; return false; }
        if (typeof (W.model.nodes.get) != "function") { WMETB_JNF_matched = "W.model.nodes.get"; return false; }
        if (typeof (W.model.junctions) != "object") { WMETB_JNF_matched = "W.model.junctions"; return false; }
        if (typeof (W.model.junctions.get) != "function") { WMETB_JNF_matched = "W.model.junctions.get"; return false; }
        if (typeof (W.model.streets) != "object") { WMETB_JNF_matched = "W.model.streets"; return false; }
        if (typeof (W.model.streets.get) != "function") { WMETB_JNF_matched = "W.model.streets.get"; return false; }
        if (typeof (W.model.streets.getByAttributes) != "function") { WMETB_JNF_matched = "W.model.streets.getByAttributes"; return false; }
        if (typeof (W.model.cities) != "object") { WMETB_JNF_matched = "W.model.cities"; return false; }
        if (typeof (W.model.cities.get) != "function") { WMETB_JNF_matched = "W.model.cities.get"; return false; }
        if (typeof (W.model.countries) != "object") { WMETB_JNF_matched = "W.model.countries"; return false; }
        if (typeof (W.model.countries.get) != "function") { WMETB_JNF_matched = "W.model.countries.get"; return false; }
        if (typeof (W.model.actionManager) != "object") { WMETB_JNF_matched = "W.model.actionManager"; return false; }
        if (typeof (W.model.actionManager.add) != "function") { WMETB_JNF_matched = "W.model.actionManager.add"; return false; }
        if (typeof (global.UpdateObject) != "function") { WMETB_JNF_matched = "UpdateObject"; return false; }
        if (typeof (global.UpdateFeatureAddress) != "function") { WMETB_JNF_matched = "UpdateFeatureAddress"; return false; }
        if (typeof (global.DisconnectSegment) != "function") { WMETB_JNF_matched = "DisconnectSegment"; return false; }
        if (typeof (global.UpdateSegmentGeometry) != "function") { WMETB_JNF_matched = "UpdateSegmentGeometry"; return false; }
        if (typeof (global.AddSegment) != "function") { WMETB_JNF_matched = "AddSegment"; return false; }
        if (typeof (global.AddNode) != "function") { WMETB_JNF_matched = "AddNode"; return false; }
        if (typeof (global.ConnectSegment) != "function") { WMETB_JNF_matched = "ConnectSegment"; return false; }
        if (typeof (global.ModifyAllConnections) != "function") { WMETB_JNF_matched = "ModifyAllConnections"; return false; }
        if (typeof (global.FeatureVectorSegment) != "function") { WMETB_JNF_matched = "FeatureVectorSegment"; return false; }
        if (typeof (W.model.nodes.objects) != "object") { WMETB_JNF_matched = "W.model.nodes.objects"; return false; }
        tstvar = Object.keys(W.model.nodes.objects); if (typeof (tstvar) != "object") { WMETB_JNF_matched = "W.model.nodes.objects keys"; return false; }
        return true;
    }
    function WMETB_JNF_RestoreSettings() {
        if (WMETB_JNF_storage) {
            console.log("WMETB-JNF: loading options"); options = JSON.parse(WMETB_JNF_storage.getItem('WMETB_JNF')); if (options == null) { console.log("no options"); return; }
            if (WCENC) { WCENC.showAllArrows = options['showallarrows']; WCENC.showArrows = options['showarrows']; WCENC.toggleShowAllArrows(); WCENC.toggleShowAllArrows(); } else { console.log("no WCENC"); }
        }
    }
    function WMETB_JNF_OnUnload() { if (WMETB_JNF_storage) { console.log("WMETB-JNF: saving options"); options = {}; Object.forEach(W.map.controls, function (k, v) { if (v.displayClass == "WazeControlEditNodeConnections") { options['showallarrows'] = v.showAllArrows; options['showarrows'] = v.showArrows; } }); WMETB_JNF_storage.setItem('WMETB_JNF', JSON.stringify(options)); } }
    function WMETB_JNF_Hook() { console.log("WMETB-JNF: Hook"); Waze.Config.cameras.minDisplayZoom = 0; W.model.cameras.minZoom = 0; W.map.DefaultPanInPixel = W.map.size.h / 4; $(window).on("beforeunload", WMETB_JNF_OnUnload); Waze.selectionManager.events.register("selectionchanged", this, WMETB_JNF_hookShortcuts); }
    function WMETB_JNF_hookShortcuts() {
        if (Waze.selectionManager.selectedItems.length == 0 && !WMETB_oldHook) {
            if (Waze.accelerators.events.listeners.hasOwnProperty('disallowAllConnections') && Waze.accelerators.events.listeners.disallowAllConnections.length != 0)
            { Waze.accelerators.events.listeners.disallowAllConnections = []; }
            if (Waze.accelerators.events.listeners.hasOwnProperty('allowAllConnections') && Waze.accelerators.events.listeners.allowAllConnections.length != 0)
            { Waze.accelerators.events.listeners.allowAllConnections = []; }
            return;
        }
        if (Waze.selectionManager.selectedItems.length != 0 && Waze.selectionManager.selectedItems[0].model.type != 'node')
            return; if (Waze.accelerators.events.listeners.hasOwnProperty('disallowAllConnections') && Waze.accelerators.events.listeners.disallowAllConnections.length != 0)
            { Waze.accelerators.events.listeners.disallowAllConnections[0].func = function () { WMETB_JNF_DAT(this); } }
        if (Waze.accelerators.events.listeners.hasOwnProperty('allowAllConnections') && Waze.accelerators.events.listeners.allowAllConnections.length != 0) {
            Waze.accelerators.events.listeners.allowAllConnections[0].func = function () {
                if (typeof (allowAllConnections) == 'function') { allowAllConnections(); } else {
                    if (WMETB_oldHook)
                        this.setAllConnections(true); else
                        this._setAllConnections(true);
                }
                WCENC.toggleShowAllArrows(); WCENC.toggleShowAllArrows();
            }
        }
    }
    var init_tries = 0; function WMETB_JNF_Init() {
        console.log("WMETB-JNF: " + WMETB_JNF_Version + " starting"); try { WMETB_JNF_uid = new Date; (WMETB_JNF_storage = window.localStorage).setItem(WMETB_JNF_uid, WMETB_JNF_uid); WMETB_JNF_fail = WMETB_JNF_storage.getItem(WMETB_JNF_uid) != WMETB_JNF_uid; WMETB_JNF_storage.removeItem(WMETB_JNF_uid); WMETB_JNF_fail && (WMETB_JNF_storage = false); } catch (e) { }
        console.log("WMETB-JNF: Checking API"); WMETB_JNF_CheckAllAPI(0, function () { WMETB_JNF_RestoreSettings(); WMETB_JNF_Hook(); }, function () { console.log("WMETB-JNF: failed API check, exiting: " + WMETB_JNF_matched); alert("WME Junction Node Fixer has failed to load due to API check: " + WMETB_JNF_matched); WMETB_JNF_FixNode = undefined; });
    }
    var WMETB_Redo_RoundAbout = function (ev) {
        if (sec.WMETB_RightsCheck("RedoRB")) {
            var selSegIds = Waze.selectionManager.selectedItems.map(function (s) { return s.model.attributes.id; }); if (selSegIds.length == WMETB_RegularLoopSegIds.length && selSegIds.length != 0) {
                selSegIds.sort(function (a, b) { return a - b }); WMETB_RegularLoopSegIds.sort(function (a, b) { return a - b }); var array_equal = true; for (var i = 0; i < selSegIds.length; i++) {
                    if (selSegIds[i] != WMETB_RegularLoopSegIds[i])
                    { array_equal = false; break; }
                }
                if (array_equal)
                { var junctionAction = new CreateObject(null, Waze.model.junctions, { segIDs: selSegIds, type: "RA" }); Waze.model.actionManager.add(junctionAction); var junction = junctionAction.object; Waze.selectionManager.selectedItems.forEach(function (e) { Waze.model.actionManager.add(new UpdateObject(e.model, { junctionID: junction.getID() })) }); WMETB_DispLog("Regular loop has been converted to roundabout"); return; }
            }
            if (Enable_WMETB_Redo_RoundAbout) {
                if (Waze.selectionManager.selectedItems.length !== 0) {
                    var junc = null; if (Waze.selectionManager.selectedItems[0].model.attributes.junctionID != null) { var sel = Waze.selectionManager.selectedItems[0].model; junc = Waze.model.junctions.objects[sel.attributes.junctionID]; var listRoadIds = junc.segIDs; var listId; } else { var listRoadIds = new Array(); for (var i = 0; i < Waze.selectionManager.selectedItems.length; i++) { var sel = Waze.selectionManager.selectedItems[i]; listRoadIds.push(sel.model.attributes.id); } }
                    var polygon = WMETB_RDBExtractPolygon(junc.id); var oldRdt = WMETB_extract_rdt(listRoadIds); if (oldRdt.higherRank === false) {
                        var ma = new MultiAction; ma.setModel(Waze.model); for (var i = 0; i < oldRdt.listRoadIds.length; i++) { var seg = Waze.model.segments.objects[oldRdt.listRoadIds[i]]; ma.doSubAction(new DeleteSegment(seg)); }
                        for (var i = 0; i < oldRdt.listAdjRoadIds.length; i++) {
                            var seg = Waze.model.segments.objects[oldRdt.listAdjRoadIds[i].id]; if (seg.state == "Delete")
                                continue; var newGeo = seg.geometry.clone(); if (oldRdt.listAdjRoadIds[i].sideConnect == "A") { var index1 = 0; var index2 = 1; var nodeEnd = Waze.model.nodes.objects[seg.attributes.toNodeID]; } else { var index1 = newGeo.components.length - 1; var index2 = newGeo.components.length - 2; var nodeEnd = Waze.model.nodes.objects[seg.attributes.fromNodeID]; }
                            if (nodeEnd != null && WMETB_onScreen(nodeEnd) && nodeEnd.attributes.segIDs.length < 2) { ma.doSubAction(new UpdateObject(seg, { fwdDirection: true, revDirection: true })); }
                            if (!seg.attributes.fwdDirection && !seg.attributes.revDirection) { ma.doSubAction(new UpdateObject(seg, { fwdDirection: true, revDirection: true })); }
                            var deltaX = newGeo.components[index1].x - newGeo.components[index2].x; var deltaY = newGeo.components[index1].y - newGeo.components[index2].y; var angle = WMETB_angleDeg(deltaX, deltaY); var meanExt = 0.1 * (oldRdt.rx + oldRdt.ry); newGeo.components[index1].x = newGeo.components[index1].x + meanExt * Math.cos(WMETB_convertDegRad(angle)); newGeo.components[index1].y = newGeo.components[index1].y + meanExt * Math.sin(WMETB_convertDegRad(angle)); newGeo.components[index1].calculateBounds(); ma.doSubAction(new UpdateSegmentGeometry(seg, seg.geometry, newGeo));
                        }
                        Waze.model.actionManager.add(ma); var R = {}; R.center = { x: oldRdt.centerX, y: oldRdt.centerY }; R.rx = Math.min(parseInt(144), oldRdt.rx); R.ry = Math.min(parseInt(144), oldRdt.ry); if (Math.abs(R.rx - R.ry) < (0.15 * R.rx)) { R.rx = (R.rx + R.ry) / 2; R.ry = R.rx; }
                        R.bounds = new OpenLayers.Bounds(R.center.x - R.rx, R.center.y - R.ry, R.center.x + R.rx, R.center.y + R.ry); R.segIdList = []; oldRdt.listAdjRoadIds.forEach(function (e) { R.segIdList.push(e.id) }); for (var seg in Waze.model.segments.objects) {
                            if (Waze.model.segments.objects.hasOwnProperty(seg) == false)
                                continue; var segment = Waze.model.segments.objects[seg]; if (WMETB_isInArray(segment.attributes.id, oldRdt.listRoadIds))
                                    continue; if (WMETB_isInArray(segment.attributes.id, R.segIdList))
                                        continue; var endPoint = segment.geometry.components[0]; if (endPoint.x >= polygon.bounds.left && endPoint.x <= polygon.bounds.right && endPoint.y >= polygon.bounds.bottom && endPoint.y <= polygon.bounds.top) {
                                            if (polygon.containsPoint(endPoint))
                                            { R.segIdList.push(segment.attributes.id); continue; }
                                        }
                            endPoint = segment.geometry.components[segment.geometry.components.length - 1]; if (endPoint.x >= polygon.bounds.left && endPoint.x <= polygon.bounds.right && endPoint.y >= polygon.bounds.bottom && endPoint.y <= polygon.bounds.top) {
                                if (polygon.containsPoint(endPoint))
                                { R.segIdList.push(segment.attributes.id); continue; }
                            }
                        }
                        var addExtraNode = false; if (R.segIdList.length == 2 && sec.WMETB_IsGC())
                            addExtraNode = confirm("This is a 2 segments roundabout.\nDo you want to add an extra node?"); R.addExtranode = addExtraNode; var R2 = R; var action; try { action = new CreateRoundaboutNoCross(R); }
                        catch (e)
                        { console.log("WMETB: Create Roundabout No Cross Failed! Trying old method..."); action = new CreateRoundabout(R); }
                        Waze.model.actionManager.add(action); var ma = new MultiAction; ma.setModel(Waze.model); var rbtRoadIds = new Array(); for (var i = 0; i < action.roundaboutSegments.length; i++) { rbtRoadIds.push(action.roundaboutSegments[i].attributes.id); }
                        var newRdt = WMETB_searchNewRdt(rbtRoadIds, oldRdt.primaryStreetID, oldRdt.lockRank, oldRdt.Toll, ma); for (var i = 0; i < rbtRoadIds.length; i++) { var road = Waze.model.segments.objects[rbtRoadIds[i]]; ma.doSubAction(new UpdateObject(road, { roadType: newRdt.roadtype, level: oldRdt.level, lockRank: oldRdt.lockRank, fwdToll: oldRdt.Toll, revToll: oldRdt.Toll, routingRoadType: null, validated: true })); if (oldRdt.primaryStreetID != null) { ma.doSubAction(new UpdateObject(road, { primaryStreetID: oldRdt.primaryStreetID })); } }
                        for (var i = 0; i < rbtRoadIds.length; i++) {
                            var road = Waze.model.segments.objects[rbtRoadIds[i]]; var attributes = road.attributes; var line = WMETB_getId(road.geometry.id); var toNode = road.getToNode(); var fromNode = road.getFromNode(); if (line !== null && attributes.fwdTurnsLocked !== undefined && attributes.revTurnsLocked !== undefined && (attributes.fwdDirection || attributes.revDirection)) {
                                if (!attributes.fwdTurnsLocked && toNode.attributes.segIDs.length > 1 && WMETB_onScreen(toNode)) { ma.doSubAction(new UpdateObject(road, { fwdTurnsLocked: true })); }
                                if (!attributes.revTurnsLocked && fromNode.attributes.segIDs.length > 1 && WMETB_onScreen(fromNode)) { ma.doSubAction(new UpdateObject(road, { revTurnsLocked: true })); }
                            }
                        }
                        Waze.model.actionManager.add(ma); WMETB_select(rbtRoadIds); WMETB_DispLog("Roundabout has been rebuilt");
                    } else { WMETB_DispWarn("You cannot redo this roundabout, because you cannot edit all segments (incl. exits)"); }
                } else { WMETB_DispWarn("Incorrect Selection: \n\nEither no segment selected \nor the selected segment is not a Roundabout segment"); }
            } else { WMETB_DispWarn("No roundabout segment selected"); }
        }
    }
    var WMETB_RDBToStandardRoad = function () {
        if (sec.WMETB_RightsCheck("RBStan")) {
            if (Enable_WMETB_RDBToStandardRoad) {
                var rbtID = Waze.selectionManager.selectedItems[0].model.attributes.junctionID; var rbtSegments = new Array(); for (var seg in Waze.model.segments.objects) {
                    if (Waze.model.segments.objects[seg].attributes.junctionID == rbtID) {
                        if (!Waze.model.segments.objects[seg].arePropertiesEditable()) { WMETB_DispWarn("You cannot convert this roundabout, because you cannot edit all segments"); return; }
                        rbtSegments.push(Waze.model.segments.objects[seg]);
                    }
                }
                if (rbtSegments.length === 1) { WMETB_SplitRoad(rbtSegments[0]); } else { for (var i = 0; i < rbtSegments.length; i++) { Waze.model.actionManager.add(new UpdateObject(rbtSegments[i], { junctionID: null })); } }
                Waze.selectionManager.select(rbtSegments); WMETB_DispLog("Roundabout changed to standard circular road");
            } else { WMETB_DispWarn("No roundabout segment selected"); }
        }
    }; var WMETB_RDBLandmark = function () { if (Enable_WMETB_DrawRDBTLandmark && sec.WMETB_RightsCheck("RBArea")) { Waze.map.landmarkLayer.setVisibility(true); var jID = Waze.selectionManager.selectedItems[0].model.attributes.junctionID; if (jID == null) return; var polygon = WMETB_RDBExtractPolygon(jID); if (polygon == null) return; var landmark = new FeatureVectorLandmark(); landmark.geometry = polygon; landmark.attributes.categories = ["JUNCTION_INTERCHANGE"]; Waze.model.actionManager.add(new AddLandmark(landmark), _.defer(function () { Waze.selectionManager.select([landmark]) })); WMETB_DispLog("Roundabout area place created"); } else { WMETB_DispWarn("No roundabout segment selected"); } }; tb.push(3); var WMETB_slideSideBar = function (action) {
        'use strict'; var sideoffset = (parseInt($("#sidebar").parent().parent().css('padding-left')) * 100) / document.body.clientWidth; if (action == "hide") { WMETB_sidebarvisible = false; $("#WME_JCB_All").hide(); $("#sidebar").animate({ width: "-=" + WMETB_sidebarOriginalWidth + "px" }, { duration: 150, complete: function () { $("#editor-container").css({ left: 0, width: ($(window).width()), position: "absolute" }); $("#links").hide(); $("#sidebarContent").hide(); $("waze-staff-tools").hide(); $('#WMETB_ToggleSidebar').attr('src', document["sidebar_arrow_right.png"].src); window.dispatchEvent(new Event('resize')); }, fail: function () { WMETB_DispErr("sidebar hide failed to complete"); } }); } else if (action == "show") {
            WMETB_sidebarvisible = true; $("#sidebar").animate({ width: "+=" + WMETB_sidebarOriginalWidth }, {
                duration: 150, complete: function () {
                    $("#editor-container").css({ left: "", width: "", position: "" }); $("#links").show(); $("#sidebarContent").show(); $("waze-staff-tools").show(); $("#WME_JCB_All").show(); if (WMETB_AutoHideSideBar === false) { $('#WMETB_ToggleSidebar').attr('src', document["sidebar_arrow_left.png"].src); }
                    window.dispatchEvent(new Event('resize'));
                }, fail: function () { WMETB_DispErr("sidebar show failed to complete"); }
            });
        }
    }, WMETB_ToggleSidebar = function () { 'use strict'; if (WMETB_AutoHideSideBar === true) { WMETB_AutoHideSideBar = false; if (WMETB_sidebarvisible === false) { WMETB_sidebarvisible = true; WMETB_slideSideBar("show"); } } else { WMETB_AutoHideSideBar = true; } }; tc.push(0); var WMETB_ToggleHighlights = function () {
        'use strict'; if (WMETB_ToSave.EnableHighlights) { WMETB_ToSave.EnableHighlights = false; $('#WMETB_ToggleHighlights').attr('src', document["power_red.png"].src); $("#toolbox-switcher").css('visibility', 'hidden'); WMETB_Save_All(); } else { WMETB_ToSave.EnableHighlights = true; $('#WMETB_ToggleHighlights').attr('src', document["power_green.png"].src); $("#toolbox-switcher").css('visibility', 'visible'); WMETB_Save_All(); }
        for (var i = 0; i < WMETB_Highlight_Obj.objects.length; i++) { WMETB_Highlight_Obj.objects[i].HighlightSegments(); }
    }; tb.push(44); var WMETB_ToggleLockHighlights = function () {
        'use strict'; if (WMETB_ToSave.ToggleLockHighlights) { WMETB_ToSave.ToggleLockHighlights = false; $('#WMETB_ToggleLockHighlights').attr('src', document["lock_red.png"].src); WMETB_Save_All(); } else { WMETB_ToSave.ToggleLockHighlights = true; $('#WMETB_ToggleLockHighlights').attr('src', document["lock_green.png"].src); WMETB_Save_All(); }
        for (var i = 0; i < WMETB_Highlight_Obj.objects.length; i++) { WMETB_Highlight_Obj.objects[i].HighlightSegments(); }
    }; tc.push(1); var WMETB_ToggleLiveMapOverview = function () { 'use strict'; if (WMETB_ToSave.LiveMapOverviewFeatures.EnableLiveMapOverview) { WMETB_ToSave.LiveMapOverviewFeatures.EnableLiveMapOverview = false; $('#WMETB_ToggleLiveMapOverview').attr('src', document["search-icon-red.png"].src); $("#WMETB_iframeMiniMap").css('visibility', 'hidden'); $('#WMETB_MiniMap').css('zIndex', -1); WMETB_Save_All(); } else { WMETB_ToSave.LiveMapOverviewFeatures.EnableLiveMapOverview = true; $('#WMETB_ToggleLiveMapOverview').attr('src', document["search-icon-green.png"].src); $('#WMETB_MiniMap').css('zIndex', 1000); $("#WMETB_iframeMiniMap").css('visibility', 'visible'); WMETB_Save_All(); } }; tb.push(64); var WMETB_ToggleUserGreetings = function (set) {
        'use strict'; if (typeof set == 'undefined') { set = WMETB_ToSave.HideUserGreetings; } else { WMETB_ToSave.HideUserGreetings = set; }
        if (set) { $("div.user-profile").hide(); } else { $("div.user-profile").show(); }
    }; tb.push(68); var WMETB_ToggleZoomControlLeft = function (set) {
        'use strict'; if (typeof set == 'undefined') { set = WMETB_ToSave.ZoomControlLeft; } else { WMETB_ToSave.ZoomControlLeft = set; }
        if (set) { $(".olControlPanZoomBar").css({ 'left': 10, 'width': 30, 'right': "" }); $('#WMETB_ZoomLevelIndicator').css({ 'left': 50, 'right': "" }); if (WMETB_ToSave.ZoomLevelIndicator) { $('#panel-container').css({ 'left': 70, 'position': 'absolute' }); } else { $('#panel-container').css({ 'left': 50, 'position': 'absolute' }); } } else { $(".olControlPanZoomBar").css({ 'right': 10, 'width': 30, 'left': "" }); $('#WMETB_ZoomLevelIndicator').css({ 'right': 50, 'left': "" }); $('#panel-container').css({ 'left': "", 'position': "" }); }
    }
    var WMETB_ToggleZoomLevelIndicator = function (set) {
        'use strict'; if (typeof set == 'undefined') { set = WMETB_ToSave.ZoomLevelIndicator; } else { WMETB_ToSave.ZoomLevelIndicator = set; }
        if (set) { $("#WMETB_ZoomLevelIndicator").show(); } else { $("#WMETB_ZoomLevelIndicator").hide(); }
        WMETB_ToggleZoomControlLeft();
    }, WMETB_UpdateZoomLevelIndicator = function () {
        'use strict'; if ($('#WMETB_ZoomLevelIndicator').length == 1)
            $('#WMETB_ZoomLevelIndicator')[0].innerHTML = Waze.map.getZoom();
    }; tc.push(0); var WMETB_Label_Distance = function () {
        'use strict'; var label_distance; switch (Waze.map.zoom) { case 9: label_distance = 2; break; case 8: label_distance = 4; break; case 7: label_distance = 7; break; case 6: label_distance = 12; break; case 5: label_distance = 20; break; case 4: label_distance = 40; break; case 3: label_distance = 70; break; case 2: label_distance = 150; break; case 1: label_distance = 200; break; }
        return label_distance;
    }, WME_TBLayer = Class.extend({
        init: function (params) {
            var tbLi = document.createElement('li'); var tbDiv = document.createElement('div'); tbDiv.className = 'toggler'; var tbInput = document.createElement('input'); tbInput.className = 'toggle'; tbInput.id = params.Switcher; tbInput.type = 'checkbox'; this.ShortSwitcher = params.Switcher.split("WMETB_cb")[1]; if (WMETB_ToSave[this.ShortSwitcher]) { tbInput.checked = true; }
            tbInput.onclick = (function () {
                var ShortSwitcher = this.id.split("WMETB_cb")[1]; var a = WMETB_getId(ShortSwitcher); if (a.style.fontWeight === "normal") { a.style.fontWeight = "bold"; } else { a.style.fontWeight = "normal"; }
                var WMETB_myHighlightObj = WMETB_GetHighlightObj(ShortSwitcher); if (WMETB_myHighlightObj.LineLayer.getVisibility()) { WMETB_myHighlightObj.LineLayer.setVisibility(false); } else { WMETB_myHighlightObj.LineLayer.setVisibility(true); WMETB_myHighlightObj.HighlightSegments(); }
                WMETB_Save_All();
            }); var tbLabel = document.createElement('label'); tbLabel.htmlFor = tbInput.id; var c = (/.png/.test(params.legendPicture) ? '<img src="' + params.legendPicture + '" style="max-height:16px;" alt="" title=""; /> ' : '<div class="tbLegend" style="background-color:' + params.Color + ';"></div>'); c += '<span id="' + params.Switcher.split("WMETB_cb")[1] + '" class="label-text" ' + (WMETB_ToSave[this.ShortSwitcher] ? 'style="font-weight:bold;"' : 'style="font-weight:normal;"') + '>' + params.LayerName + '</span>'; tbLabel.innerHTML = c; tbDiv.appendChild(tbInput); tbDiv.appendChild(tbLabel); tbLi.appendChild(tbDiv); WMETB_getId('toolboxUl').appendChild(tbLi);
        }, refresh: function () { }
    }), WMETB_Highlight_Obj = Class.extend({
        init: function (params) {
            WMETB_Highlight_Obj.objects.push(this); this.Type = params.Type; this.Pattern = params.Pattern; this.Color = params.Color; this.Switcher = params.Switcher; this.LockLevel = params.LockLevel; this.MinZoom = params.MinZoom; this.legendPicture = params.legendPicture; this.highlightFunc = params.highlightFunc; this.LineLayer = new OL.Layer.Vector(params.LayerName, { listart: params.listart, liend: params.liend, displayInLayerSwitcher: false, legendPicture: params.legendPicture, showlegendPicture: params.showlegendPicture, legendColor: params.legendColor, backGround: params.backGround, hideFromPermalink: true, uniqueName: this.Switcher }); this.LineLayer.addOptions({ id: this.Switcher }); Waze.map.addLayer(this.LineLayer); this.ShortSwitcher = this.Switcher.split("WMETB_cb")[1]; if (localStorage.WME_Toolbox_Options) { this.LineLayer.setVisibility(WMETB_ToSave[this.ShortSwitcher]); } else { this.LineLayer.setVisibility(false); }
            Waze.map.events.register("zoomend", this, this.HighlightSegments.bind(this)); Waze.map.events.register("moveend", this, this.HighlightSegments.bind(this)); Waze.map.events.register("mergeend", this, this.HighlightSegments.bind(this)); Waze.map.events.register("changelayer", this, this.HighlightSegments.bind(this)); setTimeout(this.HighlightSegments.bind(this), 100);
        }, HighlightSegments: function () {
            this.LineLayer.destroyFeatures(); if (Waze.map.zoom < this.MinZoom || this.LineLayer.getVisibility() !== true || !WMETB_ToSave.EnableHighlights || (!WMETB_ToSave.ToggleLockHighlights && this.Type == "Lock")) { return; }
            if (ToolboxPending) { setTimeout(this.HighlightSegments.bind(this), 100); return; }
            this.highlightFunc();
        }
    }), WMETB_GetHighlightObj = function (ShortSwitcher) {
        for (var i = 0; i < WMETB_Highlight_Obj.objects.length; i++) { if (WMETB_Highlight_Obj.objects[i].ShortSwitcher == ShortSwitcher) return WMETB_Highlight_Obj.objects[i]; }
        return null;
    }; var ComputeLocked = function () {
        var pic; for (var seg in Waze.model.segments.objects) {
            var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var line = WMETB_getId(segment.geometry.id); if (line !== null) {
                var lockedlevel = attributes.lockRank + 1; var trafficlockedlevel = attributes.rank + 1; if ((lockedlevel === this.LockLevel) || (attributes.lockRank === null && trafficlockedlevel === this.LockLevel)) {
                    var SegmentPoints = [], LabelPoint, oldparam = {}, _this = this; if (attributes.lockRank === null) { pic = _this.legendPicture.split(".png")[0] + "A.png"; } else { pic = _this.legendPicture; }
                    oldparam.x = null; oldparam.y = null; var AtLeastOne = false; $.each(segment.geometry.getVertices(), function (idx, param) {
                        SegmentPoints.push(new OL.Geometry.Point(param.x, param.y)); var style = { externalGraphic: pic, graphicHeight: 30, graphicWidth: 30, graphicOpacity: 0.9 }; if (oldparam.x !== null && oldparam.y !== null) { if (Math.abs(oldparam.x - param.x) > WMETB_Label_Distance() || Math.abs(oldparam.y - param.y) > WMETB_Label_Distance() || AtLeastOne === false) { var centerparam = {}; centerparam.x = ((oldparam.x + param.x) / 2); centerparam.y = ((oldparam.y + param.y) / 2); if (Math.abs(centerparam.x - param.x) > WMETB_Label_Distance() || Math.abs(centerparam.y - param.y) > WMETB_Label_Distance() || AtLeastOne === false) { LabelPoint = new OL.Geometry.Point(centerparam.x, centerparam.y); var pointFeature = new OL.Feature.Vector(LabelPoint, null, style); _this.LineLayer.addFeatures([pointFeature]); AtLeastOne = true; } } }
                        oldparam.x = param.x; oldparam.y = param.y;
                    }); var newline = new OL.Geometry.LineString(SegmentPoints); var style = { strokeColor: this.Color, strokeOpacity: 0.5, strokeWidth: 7, strokeDashstyle: this.Pattern }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); if (attributes.lockRank === null)
                    { var newline = new OL.Geometry.LineString(SegmentPoints); var style = { strokeColor: this.Color, strokeOpacity: 0.4, strokeWidth: 15, strokeDashstyle: this.Pattern }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); }
                }
            }
        }
    }, ComputeLockedDifferentThanAuto = function () {
        for (var seg in Waze.model.segments.objects) {
            var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; if (attributes.lockRank !== null) {
                if (attributes.lockRank < attributes.rank) { var color = "#FF0000"; var opacity = 0.5; } else if (attributes.lockRank > attributes.rank) { var color = "#00FF00"; var opacity = 0.5; } else { var color = "#00FFFF"; var opacity = 0.5; }
                var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: color, strokeOpacity: opacity, strokeWidth: 20 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]);
            }
        }
    }, ComputeElevation = function () {
        for (var seg in Waze.model.segments.objects) {
            var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; if ((attributes.level != 0) && (attributes.level != null)) {
                if (attributes.level < 0) { var color = "#993300"; var opacity = 0.5; } else { var color = "#00ffcc"; var opacity = 0.2; }
                var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: color, strokeOpacity: opacity, strokeWidth: 30 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); if (WMETB_ToSave.highlightElevationMarkers == true) {
                    var segGeo = segment.geometry.components; var icon = document["WMETB_Green0.png"].src; switch (attributes.level) { case 0: icon = document["WMETB_Green0.png"].src; break; case 1: icon = document["WMETB_Green1.png"].src; break; case 2: icon = document["WMETB_Green2.png"].src; break; case 3: icon = document["WMETB_Green3.png"].src; break; case 4: icon = document["WMETB_Green4.png"].src; break; case 5: icon = document["WMETB_Green5.png"].src; break; case 6: icon = document["WMETB_Green6.png"].src; break; case 7: icon = document["WMETB_Green7.png"].src; break; case 8: icon = document["WMETB_Green8.png"].src; break; case 9: icon = document["WMETB_Green9.png"].src; break; case -1: icon = document["WMETB_Red1.png"].src; break; case -2: icon = document["WMETB_Red2.png"].src; break; case -3: icon = document["WMETB_Red3.png"].src; break; case -4: icon = document["WMETB_Red4.png"].src; break; case -5: icon = document["WMETB_Red5.png"].src; break; }
                    var style = { externalGraphic: icon, graphicWidth: 22, graphicHeight: 22, graphicYOffset: -22, zIndex: 99999 }; if (segGeo.length == 2) { var midX = (((segGeo[0].x + segGeo[1].x) / 2) + segGeo[0].x) / 2; var midY = (((segGeo[0].y + segGeo[1].y) / 2) + segGeo[0].y) / 2; var labelPoint = new OL.Geometry.Point(midX, midY); var imageFeature = new OpenLayers.Feature.Vector(labelPoint, null, style); this.LineLayer.addFeatures([imageFeature]); }
                    else { for (i = 0; i < segGeo.length - 1; i++) { if (i % 3 == 1) { var midX = (((segGeo[i].x + segGeo[i + 1].x) / 2) + segGeo[i].x) / 2; var midY = (((segGeo[i].y + segGeo[i + 1].y) / 2) + segGeo[i].y) / 2; var labelPoint = new OL.Geometry.Point(midX, midY); var imageFeature = new OpenLayers.Feature.Vector(labelPoint, null, style); this.LineLayer.addFeatures([imageFeature]); } } }
                }
            }
        }
    }, ComputeSameConn = function () { for (var seg in Waze.model.segments.objects) { var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var line = WMETB_getId(segment.geometry.id); if (line !== null) { if (WMETB_CheckSameSegmentsWithSameNodes(segment)) { var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: this.Color, strokeOpacity: 0.7, strokeWidth: 7 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); } } } }, ComputeBadRdbt = function () {
        for (var seg in Waze.model.segments.objects) {
            var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var line = WMETB_getId(segment.geometry.id); if (line !== null) {
                var roundabout = attributes.hasOwnProperty('junctionID') && attributes.junctionID !== null; if (roundabout) {
                    if (WMETB_isBadRoundabout(segment).errorCode > 2)
                    { var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: this.Color, strokeOpacity: 0.9, strokeWidth: 7, strokeDashstyle: this.Pattern }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); }
                }
            }
        }
    }, ComputeSimpleSegments = function () {
        if (sec.WMETB_RightsCheck("HiLiSi")) {
            var dmax = 2.5; for (var seg in Waze.model.segments.objects) {
                var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var line = WMETB_getId(segment.geometry.id); if (segment.type == "segment" && segment.geometry.components.length > 2 && WMETB_onScreen(segment) && segment.attributes.junctionID == null && segment.state != "Delete" && segment.attributes.updatedBy) {
                    var ax = Math.abs(segment.geometry.components[0].x - segment.geometry.components[1].x); var ay = Math.abs(segment.geometry.components[0].y - segment.geometry.components[1].y); var da = Math.sqrt(ax * ax + ay * ay); var bx = Math.abs(segment.geometry.components[segment.geometry.components.length - 2].x - segment.geometry.components[segment.geometry.components.length - 1].x); var by = Math.abs(segment.geometry.components[segment.geometry.components.length - 2].y - segment.geometry.components[segment.geometry.components.length - 1].y); var db = Math.sqrt(bx * bx + by * by); var a1 = null; var b1 = null; if (da < dmax) { a1 = segment.geometry.components[1].clone(); }
                    if (db < dmax) { b1 = segment.geometry.components[segment.geometry.components.length - 2].clone(); }
                    if (a1 != null && b1 != null && a1.x == b1.x && a1.y == b1.y) { b1 = null; }
                    var geo = segment.geometry.simplify(0.8); if (segment.geometry.components.length != geo.components.length) {
                        if (a1 != null) { if (a1.x != geo.components[1].x || a1.y != geo.components[1].y) { geo.addPoint(a1, 1); } }
                        if (b1 != null) { if (b1.x != geo.components[geo.components.length - 2].x || b1.y != geo.components[geo.components.length - 2].y) { geo.addPoint(b1, geo.components.length - 1); } }
                    }
                    var reduced = segment.geometry.components.length - geo.components.length; if (reduced) { var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: this.Color, strokeOpacity: 0.7, strokeWidth: 3 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); }
                }
            }
        }
    }, ComputeHouseNumbers = function () { for (var seg in Waze.model.segments.objects) { var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var hasHNs = attributes.hasHNs; if (hasHNs) { var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: this.Color, strokeOpacity: 0.5, strokeWidth: 9 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); } } }, ComputeStreetNamesWithoutHouseNumber = function () { for (var seg in Waze.model.segments.objects) { var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var hasHNs = attributes.hasHNs; var sid = attributes.primaryStreetID; var roadType = attributes.roadType; var street = Waze.model.streets.get(sid); var noName = (street != null) && street.isEmpty; if (!hasHNs && !noName && roadType <= 2) { var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: this.Color, strokeOpacity: 0.5, strokeWidth: 9 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); } } }, ComputeTimeRestrictions = function () {
        var savedthis = this; var DateNow = Date.now(); var tNow = new Date(); tNow.getTime(); var strNow = tNow.getFullYear() + "-" + ("0" + (tNow.getMonth() + 1)).substr(-2, 2) + "-" + ("0" + tNow.getDate()).substr(-2, 2); for (var segID in Waze.model.segments.objects) {
            var seg = Waze.model.segments.get(segID); var attributes = seg.attributes; var line = WMETB_getId(seg.geometry.id); if (line !== null && attributes.fwdRestrictions !== undefined && attributes.revRestrictions !== undefined) {
                var imgsrc = document["TimeRestrictedNode.png"].src; var linecolor = this.Color; if (attributes.fwdRestrictions.length > 0 || attributes.revRestrictions.length > 0) {
                    for (var rest = 0; rest < attributes.fwdRestrictions.length; rest++) {
                        if (typeof attributes.fwdRestrictions[rest] !== 'undefined') {
                            if (attributes.fwdRestrictions[rest]._toDate !== null) {
                                if (attributes.fwdRestrictions[rest]._toTime !== null) { var t = Date.parse(attributes.fwdRestrictions[rest]._toDate + " " + attributes.fwdRestrictions[rest]._toTime); } else { var t = Date.parse(attributes.fwdRestrictions[rest]._toDate + " 23:59:59"); }
                                if (t < DateNow) { imgsrc = document["TimeRestrictedNodeOld.png"].src; linecolor = RestrictionColorOld; }
                            }
                        }
                    }
                    for (var rest = 0; rest < attributes.revRestrictions.length; rest++) {
                        if (typeof attributes.revRestrictions[rest] !== 'undefined') {
                            if (attributes.revRestrictions[rest]._toDate !== null) {
                                if (attributes.revRestrictions[rest]._toTime !== null) { var t = Date.parse(attributes.revRestrictions[rest]._toDate + " " + attributes.revRestrictions[rest]._toTime); } else { var t = Date.parse(attributes.revRestrictions[rest]._toDate + " 23:59:59"); }
                                if (t < DateNow) { imgsrc = document["TimeRestrictedNodeOld.png"].src; linecolor = RestrictionColorOld; }
                            }
                        }
                    }
                    var SegmentPoints = [], LabelPoint, oldparam = {}, _this = this; oldparam.x = null; oldparam.y = null; $.each(seg.geometry.getVertices(), function (idx, param) {
                        SegmentPoints.push(new OL.Geometry.Point(param.x, param.y)); var style = { externalGraphic: imgsrc, graphicHeight: 17, graphicWidth: 17, graphicOpacity: 0.7 }; if (oldparam.x !== null && oldparam.y !== null) { if (Math.abs(oldparam.x - param.x) > WMETB_Label_Distance() || Math.abs(oldparam.y - param.y) > WMETB_Label_Distance()) { LabelPoint = new OL.Geometry.Point(param.x, param.y); var pointFeature = new OL.Feature.Vector(LabelPoint, null, style); _this.LineLayer.addFeatures([pointFeature]); var centerparam = {}; centerparam.x = ((oldparam.x + param.x) / 2); centerparam.y = ((oldparam.y + param.y) / 2); if (Math.abs(centerparam.x - param.x) > WMETB_Label_Distance() || Math.abs(centerparam.y - param.y) > WMETB_Label_Distance()) { LabelPoint = new OL.Geometry.Point(centerparam.x, centerparam.y); var pointFeature = new OL.Feature.Vector(LabelPoint, null, style); _this.LineLayer.addFeatures([pointFeature]); } } } else { LabelPoint = new OL.Geometry.Point(param.x, param.y); var pointFeature = new OL.Feature.Vector(LabelPoint, null, style); _this.LineLayer.addFeatures([pointFeature]); }
                        oldparam.x = param.x; oldparam.y = param.y; var pointFeature = new OL.Feature.Vector(LabelPoint, null, style); _this.LineLayer.addFeatures([pointFeature]);
                    }); var newline = new OL.Geometry.LineString(SegmentPoints); var style = { strokeColor: linecolor, strokeOpacity: 0.7, strokeWidth: 8 }; seg["WMETB_color"] = linecolor; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]);
                }
            }
            ["from", "to"].forEach(function (dir) {
                seg.getConnectedSegmentsByDirection(dir).forEach(function (seg2) {
                    var node = seg.getNodeByDirection(dir); var turn = Waze.model.getTurnGraph().getTurnThroughNode(node, seg, seg2); turn._turnData._restrictions.forEach(function (restr) {
                        var imgsrc = document["TimeRestrictedNode.png"].src; var linecolor = savedthis.Color; if (restr._toDate) { if (Date.parse(restr._toDate + " " + restr._toTime) < DateNow) { imgsrc = document["TimeRestrictedNodeOld.png"].src; linecolor = RestrictionColorOld; } }
                        var points = []; var pointNode = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x, node.geometry.getVertices()[0].y); points.push(pointNode); var pointLabel = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x + WMETB_Label_Distance(), node.geometry.getVertices()[0].y - WMETB_Label_Distance()); points.push(pointLabel); var styleNode = { strokeColor: linecolor, strokeOpacity: 0.75, strokeWidth: 4, fillColor: "#0000FF", pointRadius: 3 }; var styleLabel = { externalGraphic: imgsrc, graphicHeight: 17, graphicWidth: 17 }; var pointFeature = new OpenLayers.Feature.Vector(pointNode, null, styleNode); savedthis.LineLayer.addFeatures([pointFeature]); var newline = new OL.Geometry.LineString(points); var lineFeature = new OL.Feature.Vector(newline, null, styleNode); savedthis.LineLayer.addFeatures([lineFeature]); var pointFeature = new OpenLayers.Feature.Vector(pointLabel, null, styleLabel); savedthis.LineLayer.addFeatures([pointFeature]);
                    })
                })
            })
        }
    }, ComputeUTurns = function () {
        for (var currentNode in Waze.model.nodes.objects) {
            var node = Waze.model.nodes.get(currentNode); if (node === undefined) continue; var numUTurns = 0; for (var j = 0; j < node.attributes.segIDs.length; j++) {
                var segID = node.attributes.segIDs[j]; var segment = Waze.model.segments.get(segID); if (segment === undefined)
                    continue; var attributes = segment.attributes; if (attributes.fwdDirection === true && attributes.revDirection === true) {
                        if (node.attributes.segIDs.length > 1) {
                            if (segment.isTurnAllowed(segment, node))
                                numUTurns++;
                        }
                    }
                if (numUTurns > 0) { var points = []; var pointNode = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x, node.geometry.getVertices()[0].y); points.push(pointNode); var pointLabel = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x + WMETB_Label_Distance(), node.geometry.getVertices()[0].y + WMETB_Label_Distance()); points.push(pointLabel); var styleNode = { strokeColor: this.Color, strokeOpacity: 0.75, strokeWidth: 4, fillColor: "#0000FF", pointRadius: 3 }; var styleLabel = { externalGraphic: document["UTurnNode.png"].src, graphicHeight: 30, graphicWidth: 30 }; var pointFeature = new OpenLayers.Feature.Vector(pointNode, null, styleNode); this.LineLayer.addFeatures([pointFeature]); var newline = new OL.Geometry.LineString(points); var lineFeature = new OL.Feature.Vector(newline, null, styleNode); this.LineLayer.addFeatures([lineFeature]); var pointFeature = new OpenLayers.Feature.Vector(pointLabel, null, styleLabel); this.LineLayer.addFeatures([pointFeature]); }
            }
        }
    }, ComputeRevConns = function () {
        for (var currentNode in Waze.model.nodes.objects) {
            var node = Waze.model.nodes.get(currentNode); if (node === undefined)
                continue; if (node.attributes.segIDs.length <= 1) { continue; }
            var numRevConns = 0; var seg1, seg2; for (var i = 0; i < node.attributes.segIDs.length - 1; i++) {
                seg1 = Waze.model.segments.get(node.attributes.segIDs[i]); for (var j = i + 1; j < node.attributes.segIDs.length; j++) {
                    seg2 = Waze.model.segments.get(node.attributes.segIDs[j]); if (seg1 != undefined && seg2 != undefined) {
                        if (seg1.isDeleted() == false && seg2.isDeleted() == false) {
                            var fwd_t = seg1.isTurnAllowed(seg2, node); var rev_t = seg2.isTurnAllowed(seg1, node); var fwd_a = node.isTurnAllowedBySegDirections(seg1, seg2); var rev_a = node.isTurnAllowedBySegDirections(seg2, seg1); if ((fwd_t && !fwd_a) || (rev_t && !rev_a)) {
                                if (!WMETB_isSegUnknown(seg1) && !WMETB_isSegUnknown(seg2))
                                    numRevConns++;
                            }
                        }
                    }
                }
            }
            if (numRevConns > 0) { var points = []; var pointNode = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x, node.geometry.getVertices()[0].y); points.push(pointNode); var pointLabel = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x + WMETB_Label_Distance(), node.geometry.getVertices()[0].y + WMETB_Label_Distance()); points.push(pointLabel); var styleNode = { strokeColor: this.Color, strokeOpacity: 0.75, strokeWidth: 4, fillColor: "#0000FF", pointRadius: 3 }; var styleLabel = { externalGraphic: document["RevConnNode.png"].src, graphicHeight: 30, graphicWidth: 30 }; var pointFeature = new OpenLayers.Feature.Vector(pointNode, null, styleNode); this.LineLayer.addFeatures([pointFeature]); var newline = new OL.Geometry.LineString(points); var lineFeature = new OL.Feature.Vector(newline, null, styleNode); this.LineLayer.addFeatures([lineFeature]); var pointFeature = new OpenLayers.Feature.Vector(pointLabel, null, styleLabel); this.LineLayer.addFeatures([pointFeature]); }
        }
    }, ComputeDeadEndRDB = function () {
        for (var currentNode in Waze.model.nodes.objects) {
            var node = Waze.model.nodes.get(currentNode); if (node === undefined)
                continue; if (node.attributes.segIDs.length <= 1) { continue; }
            var numDeadEndRDB = 0; var badseg; for (var j = 0; j < node.attributes.segIDs.length; j++) {
                badseg = null; var segID = node.attributes.segIDs[j]; var segment = Waze.model.segments.get(segID); if (segment === undefined)
                    continue; var attributes = segment.attributes; if (attributes.fromNodeID == attributes.toNodeID) { numDeadEndRDB++; badseg = segment; }
                if (numDeadEndRDB > 0) { var points = []; var pointNode = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x, node.geometry.getVertices()[0].y); points.push(pointNode); var pointLabel = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x + WMETB_Label_Distance(), node.geometry.getVertices()[0].y + WMETB_Label_Distance()); points.push(pointLabel); var styleNode = { strokeColor: this.Color, strokeOpacity: 0.75, strokeWidth: 5, fillColor: "#0000FF", pointRadius: 4 }; var styleLabel = { externalGraphic: document["DeadEndNode.png"].src, graphicHeight: 30, graphicWidth: 30 }; var pointFeature = new OpenLayers.Feature.Vector(pointNode, null, styleNode); this.LineLayer.addFeatures([pointFeature]); var newline = new OL.Geometry.LineString(points); var lineFeature = new OL.Feature.Vector(newline, null, styleNode); this.LineLayer.addFeatures([lineFeature]); var pointFeature = new OpenLayers.Feature.Vector(pointLabel, null, styleLabel); this.LineLayer.addFeatures([pointFeature]); var points = []; $.each(badseg.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var lineFeature = new OL.Feature.Vector(newline, null, styleNode); this.LineLayer.addFeatures([lineFeature]); break; }
            }
        }
    }, ComputeTunnels = function () { for (var seg in Waze.model.segments.objects) { var segment = Waze.model.segments.get(seg); var attributes = segment.attributes; var isTunnel = (attributes.flags & 1) == 1; if (isTunnel) { var points = []; $.each(segment.geometry.getVertices(), function (idx, param) { points.push(new OL.Geometry.Point(param.x, param.y)); }); var newline = new OL.Geometry.LineString(points); var style = { strokeColor: this.Color, strokeOpacity: 0.3, strokeWidth: 20 }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); } } }, shiftGeometry = function (d, line, trigo) {
        if (!trigo)
            d = -d; function getOrthoVector(p1, p2)
            { return [p1.y - p2.y, p2.x - p1.x]; }
        function normalizeVector(v) {
            if (v[0] * v[0] + v[1] * v[1] == 0)
                return v; var l = Math.sqrt(v[0] * v[0] + v[1] * v[1]); return [v[0] / l, v[1] / l];
        }
        var points = []; for (var i = 0; i < line.length; i++) {
            var prevVector = [0, 0]; var nextVector = [0, 0]; if (i > 0)
            { var p1 = line[i - 1]; var p2 = line[i]; prevVector = getOrthoVector(p1, p2); prevVector = normalizeVector(prevVector); }
            if (i < line.length - 1)
            { var p1 = line[i]; var p2 = line[i + 1]; nextVector = getOrthoVector(p1, p2); nextVector = normalizeVector(nextVector); }
            var v = [(prevVector[0] + nextVector[0]), (prevVector[1] + nextVector[1])]; v = normalizeVector(v); points.push(new OpenLayers.Geometry.Point(line[i].x + v[0] * d, line[i].y + v[1] * d));
        }
        return points;
    }, ComputeSpeedLimit = function () {
        var roadsLayer = Waze.map.getLayersBy('uniqueName', 'roads')[0]; if (!roadsLayer.getVisibility()) return; this.LineLayer.setZIndex(roadsLayer.getZIndex() - 1); var segTypesToHighlight = [1, 2, 3, 4, 6, 7, 17, 20]; for (var seg in Waze.model.segments.objects) {
            var segment = Waze.model.segments.get(seg); if (WMETB_notInArray(segment.attributes.roadType, segTypesToHighlight))
                continue; var attributes = segment.attributes; var speed = 0; var maxKMH = 130; var Pattern = this.Pattern; var speeds = [attributes.fwdMaxSpeed, attributes.revMaxSpeed]; var speedsUnverified = [attributes.fwdMaxSpeedUnverified, attributes.revMaxSpeedUnverified]; for (var i = 0; i < speeds.length; i++)
            { if (i == 0 && !attributes.fwdDirection) continue; if (i == 1 && !attributes.revDirection) continue; speed = speeds[i]; if (speed == null || speed == 0) continue; var red = 255 - (255 / maxKMH) * speed; var green = (255 / maxKMH) * speed; red = Math.floor(red); green = Math.floor(green); color = ("000000" + (red * 65536 + green * 256).toString(16)).substr(-6); color = "#" + color; var points = []; points = shiftGeometry(8 * Waze.map.getResolution(), segment.geometry.getVertices(), (i == 0 ? Waze.model.countries.top.leftHandTraffic : !Waze.model.countries.top.leftHandTraffic)); var newline = new OL.Geometry.LineString(points); Pattern = "solid"; if (speedsUnverified[i]) Pattern = "dot"; var style = { strokeColor: color, strokeOpacity: 1, strokeWidth: 6, strokeDashstyle: Pattern }; segment["WMETB_color"] = this.Color; var lineFeature = new OL.Feature.Vector(newline, null, style); this.LineLayer.addFeatures([lineFeature]); }
        }
    }, ComputeSoftTurns = function () {
        if (sec.WMETB_RightsCheck("HiLiSoftT")) {
            for (var currentNode in Waze.model.nodes.objects) {
                var node = Waze.model.nodes.get(currentNode); if (node === undefined)
                    continue; if (node.attributes.segIDs.length <= 1) { continue; }
                var numSoftTurns = 0; for (var j = 0; j < node.attributes.segIDs.length; j++) {
                    var segID = node.attributes.segIDs[j]; var segment = Waze.model.segments.get(segID); if (segment === undefined)
                        continue; var attributes = segment.attributes; var n = (attributes.fromNodeID == currentNode) ? 1 : 0; var nodeLocked = (n === 0) ? attributes.fwdTurnsLocked : attributes.revTurnsLocked; if (nodeLocked === false)
                            numSoftTurns++; if (numSoftTurns > 0) { var point = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x, node.geometry.getVertices()[0].y); var style = { strokeColor: "#000000", strokeOpacity: 1, strokeWidth: 1, fillColor: this.Color, fillOpacity: 1, pointRadius: 7 }; var pointFeature = new OpenLayers.Feature.Vector(point, null, style); this.LineLayer.addFeatures([pointFeature]); }
                }
            }
        }
    }, ComputeTTSOverride = function () {
        if (sec.WMETB_RightsCheck("HiLiTTSOver")) {
            var adjacencyList = Waze.model.getTurnGraph()._adjacencyList
            for (var currentNode in Waze.model.nodes.objects) {
                var node = Waze.model.nodes.get(currentNode); if (node === undefined)
                    continue; if (node.attributes.segIDs.length <= 1) { continue; }
                var numTTSOverrides = 0; for (var seg1 = 0; seg1 < node.attributes.segIDs.length; seg1++) {
                    var seg1ID = node.attributes.segIDs[seg1]; var segment1 = Waze.model.segments.get(seg1ID); if (segment1 === undefined)
                        continue; var seg1AttachName = seg1ID.toString() + ((segment1.attributes.fromNodeID == currentNode) ? "r" : "f"); for (var seg2 = 0; seg2 < node.attributes.segIDs.length; seg2++) {
                            if (seg1 === seg2)
                                continue; var seg2ID = node.attributes.segIDs[seg2]; var segment2 = Waze.model.segments.get(seg2ID); if (segment2 === undefined)
                                    continue; var seg2AttachName = seg2ID.toString() + ((segment2.attributes.fromNodeID == currentNode) ? "f" : "r"); if (adjacencyList.hasOwnProperty(seg1AttachName)) { if (adjacencyList[seg1AttachName].hasOwnProperty(seg2AttachName)) { if (adjacencyList[seg1AttachName][seg2AttachName]._instructionOpcode) { numTTSOverrides++; } } }
                        }
                }
                if (numTTSOverrides > 0) { var points = []; var pointNode = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x, node.geometry.getVertices()[0].y); points.push(pointNode); var pointLabel = new OpenLayers.Geometry.Point(node.geometry.getVertices()[0].x - WMETB_Label_Distance(), node.geometry.getVertices()[0].y + WMETB_Label_Distance()); points.push(pointLabel); var styleNode = { strokeColor: this.Color, strokeOpacity: 0.75, strokeWidth: 4, fillColor: "#0000FF", pointRadius: 3 }; var styleLabel = { externalGraphic: document["TTSOverride.png"].src, graphicHeight: 25, graphicWidth: 25 }; var pointFeature = new OpenLayers.Feature.Vector(pointNode, null, styleNode); this.LineLayer.addFeatures([pointFeature]); var newline = new OL.Geometry.LineString(points); var lineFeature = new OL.Feature.Vector(newline, null, styleNode); this.LineLayer.addFeatures([lineFeature]); var pointFeature = new OpenLayers.Feature.Vector(pointLabel, null, styleLabel); this.LineLayer.addFeatures([pointFeature]); }
            }
        }
    }
    WMETB_Highlight_Init = function () {
        'use strict'; if (typeof WMETB_Highlight_Obj !== 'undefined' && WMETB_Highlight_Obj.hasOwnProperty('objects') == true) {
            for (var i = 0; i < WMETB_Highlight_Obj.objects.length; i++)
            { WMETB_Highlight_Obj.objects[i].LineLayer.destroyFeatures(); Waze.map.removeLayer(WMETB_Highlight_Obj.objects[i].LineLayer); }
        }
        WMETB_Highlight_Obj.objects = []; WMETB_getId('toolboxUl').innerHTML = ""; if (sec.WMETB_RightsCheck("HiLiL6")) { var WMETB_Highlight_LockL6 = new WMETB_Highlight_Obj({ listart: true, liend: false, Type: "Lock", LayerName: "L6 locks", MinZoom: 2, LockLevel: 6, Pattern: "1 30", Color: L6LockColor, Switcher: "WMETB_cbHighlightLocked_L6", legendPicture: document["lockl6.png"].src, legendColor: true, backGround: false, highlightFunc: ComputeLocked }); var TBLayer_LockL6 = new WME_TBLayer({ Switcher: "WMETB_cbHighlightLocked_L6", LayerName: "L6 locks", Color: L6LockColor, legendPicture: document["lockl6.png"].src, allowLevel: "1", newline: false }); }
        if (sec.WMETB_RightsCheck("HiLiL5")) { var WMETB_Highlight_LockL5 = new WMETB_Highlight_Obj({ listart: true, liend: false, Type: "Lock", LayerName: "L5 locks", MinZoom: 2, LockLevel: 5, Pattern: "1 30", Color: L5LockColor, Switcher: "WMETB_cbHighlightLocked_L5", legendPicture: document["lockl5.png"].src, legendColor: true, backGround: false, highlightFunc: ComputeLocked }); var TBLayer_LockL5 = new WME_TBLayer({ Switcher: "WMETB_cbHighlightLocked_L5", LayerName: "L5 locks", Color: L5LockColor, legendPicture: document["lockl5.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiL4")) { var WMETB_Highlight_LockL4 = new WMETB_Highlight_Obj({ listart: true, liend: false, Type: "Lock", LayerName: "L4 locks", MinZoom: 2, LockLevel: 4, Pattern: "1 30", Color: L5LockColor, Switcher: "WMETB_cbHighlightLocked_L4", legendPicture: document["lockl4.png"].src, legendColor: true, backGround: false, highlightFunc: ComputeLocked }); var TBLayer_LockL4 = new WME_TBLayer({ Switcher: "WMETB_cbHighlightLocked_L4", LayerName: "L4 locks", Color: L5LockColor, legendPicture: document["lockl4.png"].src, allowLevel: "1", newline: false }); }
        if (sec.WMETB_RightsCheck("HiLiL3")) { var WMETB_Highlight_LockL3 = new WMETB_Highlight_Obj({ listart: true, liend: false, Type: "Lock", LayerName: "L3 locks", MinZoom: 2, LockLevel: 3, Pattern: "1 30", Color: L5LockColor, Switcher: "WMETB_cbHighlightLocked_L3", legendPicture: document["lockl3.png"].src, legendColor: true, backGround: false, highlightFunc: ComputeLocked }); var TBLayer_LockL3 = new WME_TBLayer({ Switcher: "WMETB_cbHighlightLocked_L3", LayerName: "L3 locks", Color: L3LockColor, legendPicture: document["lockl3.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiL2")) { var WMETB_Highlight_LockL2 = new WMETB_Highlight_Obj({ listart: true, liend: false, Type: "Lock", LayerName: "L2 locks", MinZoom: 2, LockLevel: 2, Pattern: "1 30", Color: L5LockColor, Switcher: "WMETB_cbHighlightLocked_L2", legendPicture: document["lockl2.png"].src, legendColor: true, backGround: false, highlightFunc: ComputeLocked }); var TBLayer_LockL2 = new WME_TBLayer({ Switcher: "WMETB_cbHighlightLocked_L2", LayerName: "L2 locks", Color: L3LockColor, legendPicture: document["lockl2.png"].src, allowLevel: "1", newline: false }); }
        if (sec.WMETB_RightsCheck("HiLiMaLo")) { var WMETB_Highlight_MaLo = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "ManualLock", LayerName: "Manual locks", MinZoom: 3, LockLevel: null, Pattern: null, Color: ElevationColor, Switcher: "WMETB_cbHighlightManualLocks", legendPicture: document["manuallock.png"].src, legendColor: true, backGround: false, highlightFunc: ComputeLockedDifferentThanAuto }); var TBLayer_MaLo = new WME_TBLayer({ Switcher: "WMETB_cbHighlightManualLocks", LayerName: "Manual locks", Color: ElevationColor, legendPicture: document["manuallock.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiElGr")) { var WMETB_Highlight_Elevation = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "Elevation", LayerName: "Elevation < or > ground", MinZoom: 3, LockLevel: null, Pattern: null, Color: ElevationColor, Switcher: "WMETB_cbHighlightElevation", legendPicture: null, legendColor: false, backGround: false, highlightFunc: ComputeElevation }); var TBLayer_Highlight_Elevation = new WME_TBLayer({ Switcher: "WMETB_cbHighlightElevation", LayerName: "Elevation < or > ground", Color: ElevationColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiHouNo")) { var WMETB_Highlight_HouseNumbers = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "HN", LayerName: "House numbers", MinZoom: 4, LockLevel: null, Pattern: null, Color: HouseNumbersColor, Switcher: "WMETB_cbHighlightHouseNumbers", legendPicture: null, legendColor: false, backGround: HouseNumbersColor, highlightFunc: ComputeHouseNumbers }); var TBLayer_Highlight_HouseNumbers = new WME_TBLayer({ Switcher: "WMETB_cbHighlightHouseNumbers", LayerName: "House numbers", Color: HouseNumbersColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiwoHouNo")) { var WMETB_Highlight_StreenNamesWithoutHouseNumber = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "StNameNoHN", LayerName: "Streets with name but no house number", MinZoom: 4, LockLevel: null, Pattern: null, Color: StreenNamesWithoutHouseNumbersColor, Switcher: "WMETB_cbHighlightStreetNamesWithoutHouseNumbers", legendPicture: null, legendColor: false, backGround: StreenNamesWithoutHouseNumbersColor, highlightFunc: ComputeStreetNamesWithoutHouseNumber }); var TBLayer_Highlight_StreenNamesWithoutHouseNumber = new WME_TBLayer({ Switcher: "WMETB_cbHighlightStreetNamesWithoutHouseNumbers", LayerName: "Streets with name but no house number", Color: StreenNamesWithoutHouseNumbersColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiTunnel")) { var WMETB_cbHighlightTunnels = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "Tunnels", LayerName: "Tunnels", MinZoom: 4, LockLevel: null, Pattern: null, Color: TunnelColor, Switcher: "WMETB_cbHighlightTunnels", legendPicture: null, legendColor: false, backGround: TunnelColor, highlightFunc: ComputeTunnels }); var TBLayer_cbHighlightTunnels = new WME_TBLayer({ Switcher: "WMETB_cbHighlightTunnels", LayerName: "Tunnels", Color: TunnelColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiMaxSpeed")) { var WMETB_cbHighlightSpeedLimit = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "SpeedLimit", LayerName: "Speed Limit", MinZoom: 4, LockLevel: null, Pattern: null, Color: SpeedLimitColor, Switcher: "WMETB_cbHighlightSpeedLimit", legendPicture: null, legendColor: false, backGround: SpeedLimitColor, highlightFunc: ComputeSpeedLimit }); var TBLayer_cbHighlightSpeedLimit = new WME_TBLayer({ Switcher: "WMETB_cbHighlightSpeedLimit", LayerName: "Speed Limit", Color: SpeedLimitColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiRest")) { var WMETB_Highlight_TimeRestrictions = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "TimeRestrictions", LayerName: "Segments/nodes with time restrictions", MinZoom: 4, LockLevel: null, Pattern: "1 15", Color: RestrictionColor, Switcher: "WMETB_cbHighlightTimeRestrictions", legendPicture: document["TimeRestrictedNode.png"].src, legendColor: false, backGround: RestrictionColor, highlightFunc: ComputeTimeRestrictions }); var TBLayer_Highlight_TimeRestrictions = new WME_TBLayer({ Switcher: "WMETB_cbHighlightTimeRestrictions", LayerName: "Segments/nodes with time restrictions", Color: RestrictionColor, legendPicture: document["TimeRestrictedNode.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiLoop")) { var WMETB_Highlight_SameConnection = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "SameConn", LayerName: "Loops (same connection segments)", MinZoom: 3, LockLevel: null, Pattern: null, Color: SameConnectionsColor, Switcher: "WMETB_cbHighlightSameConnection", legendPicture: null, legendColor: false, backGround: SameConnectionsColor, highlightFunc: ComputeSameConn }); var TBLayer_Highlight_SameConnection = new WME_TBLayer({ Switcher: "WMETB_cbHighlightSameConnection", LayerName: "Loops (same connection segments)", Color: SameConnectionsColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiRB")) { var WMETB_Highlight_BadRdbt = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "BadRdbt", LayerName: "Roundabouts which may cause issues", MinZoom: 3, LockLevel: null, Pattern: "5 15", Color: BadRdbtColor, Switcher: "WMETB_cbHighlightRB", legendPicture: null, legendColor: false, backGround: BadRdbtColor, highlightFunc: ComputeBadRdbt }); var TBLayer_Highlight_BadRdbt = new WME_TBLayer({ Switcher: "WMETB_cbHighlightRB", LayerName: "Roundabouts which may cause issues", Color: BadRdbtColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiSi")) { var WMETB_Highlight_SimpleSegments = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "Simple", LayerName: "Simplifiable segments", MinZoom: 2, LockLevel: null, Pattern: null, Color: SimpleSegmentsColor, Switcher: "WMETB_cbHighlightSimpleSegment", legendPicture: null, legendColor: false, backGround: SimpleSegmentsColor, highlightFunc: ComputeSimpleSegments }); var TBLayer_Highlight_SimpleSegments = new WME_TBLayer({ Switcher: "WMETB_cbHighlightSimpleSegment", LayerName: "Simplifiable segments", Color: SimpleSegmentsColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiUTurn")) { var WMETB_Highlight_UTurns = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "UTurns", LayerName: "U-Turns", MinZoom: 3, LockLevel: null, Pattern: null, Color: UTurnsColor, Switcher: "WMETB_cbHighlightUTurns", legendPicture: document["UTurnNode.png"].src, legendColor: true, backGround: null, highlightFunc: ComputeUTurns }); var TBLayer_Highlight_UTurns = new WME_TBLayer({ Switcher: "WMETB_cbHighlightUTurns", LayerName: "U-Turns", Color: UTurnsColor, legendPicture: document["UTurnNode.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiRevC")) { var WMETB_Highlight_RevConns = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "RevConns", LayerName: "Reverse Connections", MinZoom: 3, LockLevel: null, Pattern: null, Color: RevConnsColor, Switcher: "WMETB_cbHighlightRevConns", legendPicture: document["RevConnNode.png"].src, legendColor: true, backGround: null, highlightFunc: ComputeRevConns }); var TBLayer_Highlight_RevConns = new WME_TBLayer({ Switcher: "WMETB_cbHighlightRevConns", LayerName: "Reverse Connections", Color: RevConnsColor, legendPicture: document["RevConnNode.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiDELp")) { var WMETB_Highlight_DeadEndRDB = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "DeadEndRDB", LayerName: "Dead-end loops", MinZoom: 3, LockLevel: null, Pattern: null, Color: DeadEndRDBColor, Switcher: "WMETB_cbHighlightDeadEndRDB", legendPicture: document["DeadEndNode.png"].src, legendColor: true, backGround: null, highlightFunc: ComputeDeadEndRDB }); var TBLayer_Highlight_DeadEndRDB = new WME_TBLayer({ Switcher: "WMETB_cbHighlightDeadEndRDB", LayerName: "Dead-end loops", Color: DeadEndRDBColor, legendPicture: document["DeadEndNode.png"].src, allowLevel: "1", newline: true }); }
        if (sec.WMETB_RightsCheck("HiLiSoftT")) { var WMETB_Highlight_SoftTurns = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "SoftTurns", LayerName: "Soft-Turns", MinZoom: 3, LockLevel: null, Pattern: null, Color: SoftTurnsColor, Switcher: "WMETB_cbHighlightSoftTurns", legendPicture: null, legendColor: false, backGround: SoftTurnsColor, highlightFunc: ComputeSoftTurns }); var TBLayer_Highlight_SoftTurns = new WME_TBLayer({ Switcher: "WMETB_cbHighlightSoftTurns", LayerName: "Soft-Turns", Color: SoftTurnsColor, legendPicture: null, allowLevel: "1", newline: true }); }
        if ((typeof (Waze.model.getTurnGraph) === "function") && sec.WMETB_RightsCheck("HiLiTTSOver")) { var WMETB_Highlight_TTSOverrides = new WMETB_Highlight_Obj({ listart: true, liend: true, Type: "TTSOverrides", LayerName: "TTS Overrides", MinZoom: 3, LockLevel: null, Pattern: null, Color: TTSOverrideColor, Switcher: "WMETB_cbHighlightTTSOverrides", legendPicture: null, legendColor: false, backGround: TTSOverrideColor, highlightFunc: ComputeTTSOverride }); var TBLayer_Highlight_TTSOverrides = new WME_TBLayer({ Switcher: "WMETB_cbHighlightTTSOverrides", LayerName: "TTS Overrides", Color: TTSOverrideColor, legendPicture: document["TTSOverride.png"].src, allowLevel: "1", newline: true }); };
    }; tb.push(42); var WMETB_CountryChanged = function () {
        WMETB_Highlight_Init(); WMETB_ToolBar_Obj.objects = []; if (typeof WMETB_ToolBar !== 'undefined') { WMETB_ToolBar.refresh(); }
        WMETB_reloadShortcuts();
    }; tb.push(23); var wazeinit = arguments.callee; var WMETB_ClearCache = function () { for (var key in localStorage) { if (key.indexOf('WME_Toolbox_Picture_') != -1) { localStorage.removeItem(key); } } }; tc.push(1); var WMETB_MouseInPopup, WMETB_MaskActive, WMETB_EnterPopup = function () { 'use strict'; WMETB_MouseInPopup = true; }, WMETB_ExitPopup = function () { 'use strict'; WMETB_MouseInPopup = false; }, WMETB_MaskTest = function () {
        'use strict'; if (WMETB_MaskLayer === null) return false; if (Waze.map.layers[WMETB_MaskLayer].div === null) {
            if (WMETB_MaskActive === false) { WMETB_MaskActive = true; }
            return true;
        }
        if (Waze.map.layers[WMETB_MaskLayer].div.innerHTML.indexOf('fill="black"') != -1) {
            if (WMETB_MaskActive === false) { WMETB_MaskActive = true; }
            return true;
        }
        WMETB_MaskActive = false; return false;
    }; var WMETB_NullOpenLayers, WMETB_NullRootContainer, WMETB_NewPopupCheck = function () {
        'use strict'; if (ToolboxPending) { return; }
        if ($('#WMETB_NavBar').position().top < $('#map').position().top) { $('#WMETB_NavBar').css('top', $('#map').position().top + 'px'); }
        if (WMETB_MaskTest() === true)
            return; if (OpenLayers === null) {
                if (WMETB_NullOpenLayers === false) { WMETB_NullOpenLayers = true; }
                return;
            }
        WMETB_NullOpenLayers = false; var rc = document.getElementById(WMETB_RootContainer); if (rc === null) {
            if (WMETB_NullRootContainer === false) { WMETB_NullRootContainer = true; }
            return;
        }
        WMETB_NullRootContainer = false; var currentItems = rc.getElementsByTagName('g'); var result = '', rw, rh, doPopUp = false, popup_loc = new OpenLayers.LonLat(0, 0), objHasIgnoreLink = false, objHasDeleteLink = false, markerx = WMETB_CurrentMousePosX, markery = WMETB_CurrentMousePosY, offsetx = rc.getBoundingClientRect().left - rc.offsetLeft, offsety = rc.getBoundingClientRect().top - rc.offsetTop; var objHasRedoRDBTLink = false, objHasNotRDBTLink = false; if (Waze.selectionManager.selectedItems.length === 1 && Waze.selectionManager.selectedItems[0].model.type === 'segment' && Waze.selectionManager.selectedItems[0].model.attributes.junctionID !== null) {
            if (Waze.selectionManager.selectedItems[0].model.attributes.primaryStreetID === null) { result = "This segment has no City and/or Street name."; result += '<br>Please fix that. For a roundabout, you must check "none" on street name.'; doPopUp = true; } else {
                if (Waze.selectionManager.selectedItems[0].model.attributes.hasOwnProperty('junctionID') && Waze.selectionManager.selectedItems[0].model.attributes.junctionID !== null) {
                    var badRAInfo = WMETB_isBadRoundabout(Waze.selectionManager.selectedItems[0].model); if (badRAInfo.errorCode > 0) {
                        if (badRAInfo.errorCode < 4) { result = "<img src='" + document["gyro.gif"].src + "'> This roundabout's status is uncertain."; } else { result = "<img src='" + document["gyro.gif"].src + "'> This roundabout is not correct."; result += '<br>This may result in incorrect navigation instructions.'; }
                        result += '<br>' + badRAInfo.message; doPopUp = true;
                    } else { result = "This roundabout is correct."; doPopUp = true; }
                }
            }
            if (Enable_WMETB_Select_RoundAbout === false) { Enable_WMETB_Select_RoundAbout = true; $('#WMETB_SelectRDBTNavBar').attr('src', document["RDB_Select.png"].src); $('#WMETB_SelectRDBTNavBar').css('cursor', 'pointer'); }
            if (Enable_WMETB_Redo_RoundAbout === false) { Enable_WMETB_Redo_RoundAbout = true; $('#WMETB_RedoRDBTNavBar').attr('src', document["RDB_Redo.png"].src); $('#WMETB_RedoRDBTNavBar').css('cursor', 'pointer'); }
            if (Enable_WMETB_RDBToStandardRoad === false) { Enable_WMETB_RDBToStandardRoad = true; $('#WMETB_NotRDBTNavBar').attr('src', document["RDB_StandardRoad.png"].src); $('#WMETB_NotRDBTNavBar').css('cursor', 'pointer'); }
            if (Enable_WMETB_DrawRDBTLandmark === false) { Enable_WMETB_DrawRDBTLandmark = true; $('#WMETB_DrawRDBTLandmarkNavBar').attr('src', document["RDB_Landmark.png"].src); $('#WMETB_DrawRDBTLandmarkNavBar').css('cursor', 'pointer'); }
        } else {
            if (Enable_WMETB_Select_RoundAbout === true) { Enable_WMETB_Select_RoundAbout = false; $('#WMETB_SelectRDBTNavBar').attr('src', document["RDB_Grey.png"].src); $('#WMETB_SelectRDBTNavBar').css('cursor', 'not-allowed'); }
            if (Enable_WMETB_Redo_RoundAbout === true) { Enable_WMETB_Redo_RoundAbout = false; $('#WMETB_RedoRDBTNavBar').attr('src', document["RDB_Grey.png"].src); $('#WMETB_RedoRDBTNavBar').css('cursor', 'not-allowed'); }
            if (Enable_WMETB_RDBToStandardRoad === true) { Enable_WMETB_RDBToStandardRoad = false; $('#WMETB_NotRDBTNavBar').attr('src', document["RDB_Grey.png"].src); $('#WMETB_NotRDBTNavBar').css('cursor', 'not-allowed'); }
            if (Enable_WMETB_DrawRDBTLandmark === true) { Enable_WMETB_DrawRDBTLandmark = false; $('#WMETB_DrawRDBTLandmarkNavBar').attr('src', document["RDB_Grey.png"].src); $('#WMETB_DrawRDBTLandmarkNavBar').css('cursor', 'not-allowed'); }
        }
        if (!doPopUp && Waze.selectionManager.selectedItems.length === 1 && Waze.selectionManager.selectedItems[0].model.type === 'segment' && Waze.selectionManager.selectedItems[0].model.attributes.primaryStreetID === null) { result = "This segment has no City and/or Street name."; result += '<br>Please fix that.'; doPopUp = true; }
        if (Waze.selectionManager.selectedItems.length >= 1 && Waze.selectionManager.selectedItems[0].model.type === 'segment') {
            if (Enable_WMETB_Clear_Road_Geometry === false) { Enable_WMETB_Clear_Road_Geometry = true; $('#WMETB_Clear_Road_Geometry').attr('src', document["Clear_Road_Geometry.png"].src); $('#WMETB_Clear_Road_Geometry').css('cursor', 'pointer'); }
            if (Enable_WMETB_Split_Road === false) { Enable_WMETB_Split_Road = true; $('#WMETB_Split_Road').attr('src', document["Split_Road.png"].src); $('#WMETB_Split_Road').css('cursor', 'pointer'); }
        } else {
            if (Enable_WMETB_Clear_Road_Geometry === true) { Enable_WMETB_Clear_Road_Geometry = false; $('#WMETB_Clear_Road_Geometry').attr('src', document["Clear_Road_Geometry_Grey.png"].src); $('#WMETB_Clear_Road_Geometry').css('cursor', 'not-allowed'); }
            if (Enable_WMETB_Split_Road === true) { Enable_WMETB_Split_Road = false; $('#WMETB_Split_Road').attr('src', document["Split_Road_Grey.png"].src); $('#WMETB_Split_Road').css('cursor', 'not-allowed'); }
        }
        if (Waze.selectionManager.selectedItems.length >= 1 && (Waze.selectionManager.selectedItems[0].model.type === 'venue' || Waze.selectionManager.selectedItems[0].model.type === 'landmark')) { if (Enable_WMETB_Select_In_Landmark === false) { Enable_WMETB_Select_In_Landmark = true; $('#WMETB_Select_In_Landmark').attr('src', document["Select_In_Landmark.png"].src); $('#WMETB_Select_In_Landmark').css('cursor', 'pointer'); } } else { if (Enable_WMETB_Select_In_Landmark === true) { Enable_WMETB_Select_In_Landmark = false; $('#WMETB_Select_In_Landmark').attr('src', document["Select_In_Landmark_Grey.png"].src); $('#WMETB_Select_In_Landmark').css('cursor', 'not-allowed'); } }
        if (!sec.WMETB_RightsCheck("FixSuppGeoAll")) { if (Waze.selectionManager.selectedItems.length >= 1 && Waze.selectionManager.selectedItems[0].model.type === 'segment' && sec.WMETB_RightsCheck("FixSuppGeoSel")) { if (Enable_WMETB_SuppressUnneededGeometry === false) { Enable_WMETB_SuppressUnneededGeometry = true; $('#WMETB_SuppressUnneededGeometry').attr('src', document["WMETB_SuppressUnneededGeometry.png"].src); $('#WMETB_SuppressUnneededGeometry').css('cursor', 'pointer'); } } else { if (Enable_WMETB_SuppressUnneededGeometry === true) { Enable_WMETB_SuppressUnneededGeometry = false; $('#WMETB_SuppressUnneededGeometry').attr('src', document["WMETB_SuppressUnneededGeometry_Grey.png"].src); $('#WMETB_SuppressUnneededGeometry').css('cursor', 'not-allowed'); } } }
        if (Waze.selectionManager.selectedItems.length >= 1) { if (Enable_WMETB_PropertiesEditor === false) { Enable_WMETB_PropertiesEditor = true; $('#WMETB_PropertiesEditor').attr('src', document["pe_on.png"].src); $('#WMETB_PropertiesEditor').css('cursor', 'pointer'); } } else if (Enable_WMETB_PropertiesEditor === true) { Enable_WMETB_PropertiesEditor = false; $('#WMETB_PropertiesEditor').attr('src', document["pe_off.png"].src); $('#WMETB_PropertiesEditor').css('cursor', 'not-allowed'); }
        if (Waze.selectionManager.selectedItems.length >= 2) { if (Enable_WMETB_CopySegmentAttributes === false) { Enable_WMETB_CopySegmentAttributes = true; $('#WMETB_CopySegmentAttributes').attr('src', document["WMETB_CopySegmentAttributes.png"].src); $('#WMETB_CopySegmentAttributes').css('cursor', 'pointer'); } } else if (Enable_WMETB_CopySegmentAttributes === true) { Enable_WMETB_CopySegmentAttributes = false; $('#WMETB_CopySegmentAttributes').attr('src', document["WMETB_CopySegmentAttributes_Grey.png"].src); $('#WMETB_CopySegmentAttributes').css('cursor', 'not-allowed'); }
        if (sec.WMETB_RightsCheck("PopUps")) { if (WMETB_ToSave.Popups === false) return; }
        if (doPopUp === true) {
            WMETB_PopupX = markerx + 15; WMETB_PopupY = markery + 25; if (WMETB_PopupShown === false) {
                WMETB_PopupShown = true; WMETB_PopupDiv.innerHTML = result; if (objHasRedoRDBTLink === true) { document.getElementById('WMETB_RedoRDBT').addEventListener('click', WMETB_Redo_RoundAbout, true); }
                else if (objHasNotRDBTLink === true) { document.getElementById('WMETB_NotRDBT').addEventListener('click', WMETB_RDBToStandardRoad, true); }
                rw = parseInt(WMETB_PopupDiv.clientWidth); rh = parseInt(WMETB_PopupDiv.clientHeight); if (rw > (window.innerWidth / 2))
                    rw = (window.innerWidth / 2); if (rh > (window.innerHeight / 2))
                        rh = (window.innerHeight / 2); if ((WMETB_PopupX + rw) > window.innerWidth) {
                            WMETB_PopupX = window.innerWidth - (rw + 50); if (WMETB_PopupX < 0)
                                WMETB_PopupX = 0;
                        }
                if ((WMETB_PopupY + rh) > window.innerHeight) {
                    WMETB_PopupY = window.innerHeight - (rh + 50); if (WMETB_PopupY < 0)
                        WMETB_PopupY = 0;
                }
                WMETB_PopupDiv.style.top = WMETB_PopupY + 'px'; WMETB_PopupDiv.style.left = WMETB_PopupX + 'px'; WMETB_PopupDiv.style.visibility = 'visible';
            }
            WMETB_PopupTimer = -1;
        } else { if (WMETB_PopupTimer === -1) { WMETB_PopupTimer = 2; } }
        if (WMETB_PopupTimer > 0) { if (WMETB_MouseInPopup === false) WMETB_PopupTimer--; }
        if (WMETB_PopupTimer === 0) { WMETB_PopupDiv.style.visibility = 'hidden'; WMETB_PopupShown = false; WMETB_PopupTimer = -2; }
    }; var WMETB_LayersInitialise = function () {
        'use strict'; console.log('WMETB: Initializing layers'); WMETB_MouseInPopup = false; WMETB_NullOpenLayers = false; WMETB_NullRootContainer = false; WMETB_PopupShown = false; WMETB_PopupTimer = -2; WMETB_MaskLayer = null; var WMETB_PopupDiv = document.createElement('div'); WMETB_PopupDiv.id = "WMETB_PopupDiv"; WMETB_PopupDiv.style.position = 'absolute'; WMETB_PopupDiv.style.visibility = 'hidden'; WMETB_PopupDiv.style.top = '0'; WMETB_PopupDiv.style.left = '0'; WMETB_PopupDiv.style.zIndex = 100; WMETB_PopupDiv.style.backgroundColor = 'LemonChiffon'; WMETB_PopupDiv.style.border = '1px solid red'; WMETB_PopupDiv.style.boxShadow = '5px 5px 10px Silver'; WMETB_PopupDiv.style.padding = '4px'; document.body.appendChild(WMETB_PopupDiv); for (i = 0; i < Waze.map.layers.length; i++) {
            if (Waze.map.layers[i].name == 'Spotlight')
                WMETB_MaskLayer = i; if (Waze.map.layers[i].name && Waze.map.layers[i].name.indexOf('Control.SelectHighlightFeature') != -1) { this.WMETB_RootContainer = Waze.map.layers[i].div.id; }
        }
        WMETB_PopupDiv.addEventListener("mouseover", WMETB_EnterPopup, false); WMETB_PopupDiv.addEventListener("mouseout", WMETB_ExitPopup, false); Waze.selectionManager.events.register("selectionchanged", null, WMETB_NewPopupCheck); window.setInterval(WMETB_NewPopupCheck, 100); console.log('WMETB: Layers initialized'); return true;
    }; tb.push(31); var WMETB_Permalinks = { livemap: ["Waze live map", "WMETB_LiveMapPermalink", "LM"], beta: ["Waze beta/prod editor", "WMETB_BetaPermalink", "beta"] }, WMETB_Permalink_Register_Links = function () {
        'use strict'; $('#WMETB_LiveMapPermalink').click(function () {
            var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom += 12; if (zoom > 17)
                zoom = 17; if (isNaN(zoom))
                    zoom = 12; var mapsUrl = 'https://www.waze.com/livemap?lon=' + lon + '&lat=' + lat + '&zoom=' + zoom; window.open(mapsUrl, '_blank');
        }); $('#WMETB_BetaPermalink').click(function () {
            var mapsUrl; var href = $('.WazeControlPermalink a.fa-link')[0].href; var beta = href.indexOf('beta.waze.com'); if (beta == -1) { mapsUrl = href.replace('www.waze.com', 'beta.waze.com'); } else { mapsUrl = href.replace('beta.waze.com', 'www.waze.com'); }
            window.open(mapsUrl);
        }); $('#WMETB_BingPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://www.bing.com/maps/default.aspx?cp=' + lat + '~' + lon + '&lvl=' + zoom; window.open(mapsUrl, '_blank'); }); $('#WMETB_GooglePermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'https://maps.google.com/?ll=' + lat + ',' + lon + '&z=' + zoom; window.open(mapsUrl, '_blank'); }); $('#WMETB_GoogleMapMakerPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'https://www.google.com/mapmaker?ll=' + lat + ',' + lon + '&spn=0.00' + zoom + ',0.00' + zoom; window.open(mapsUrl, '_blank'); }); $('#WMETB_HerePermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://here.com/' + lat + ',' + lon + ',' + zoom + ',0,0,normal.day'; window.open(mapsUrl, '_blank'); }); $('#WMETB_IGNPermalink').click(function () {
            var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); switch (zoom) { case 10: zoom = 0.000003648865662418647; break; case 9: zoom = 0.000003648865662418647; break; case 8: zoom = 0.000003648865662418647; break; case 7: zoom = 0.000003648865662418647; break; case 6: zoom = 0.000006454478476155455; break; case 5: zoom = 0.000011417326973512833; break; case 4: zoom = 0.00002019610968533674; break; case 3: zoom = 0.0000625642009137609; break; case 2: zoom = 0.00011122524606647397; break; case 1: zoom = 0.00019576383574934658; break; case 0: zoom = 0.00034628664905454276; break; }
            var mapsUrl = 'http://www.geoportail.gouv.fr/accueil?c=' + lon + ',' + lat + '&z=' + zoom + '&l=ORTHOIMAGERY.ORTHOPHOTOS::GEOPORTAIL:OGC:WMTS(1)&l=TRANSPORTNETWORKS.ROADS::GEOPORTAIL:OGC:WMTS(0.95703125)&l=GEOGRAPHICALNAMES.NAMES::GEOPORTAIL:OGC:WMTS(1)&l=ADMINISTRATIVEUNITS.BOUNDARIES::GEOPORTAIL:OGC:WMTS(1)&permalink=yes'; window.open(mapsUrl, '_blank');
        }); $('#WMETB_MappyPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 8 ? 12 : zoom + 4; var mapsUrl = 'http://fr.mappy.com/#/0/M2/Lp/TDiscovery/N151.12061,6.11309,' + lon + ',' + lat + '/Z' + zoom + '/'; window.open(mapsUrl, '_blank'); }); $('#WMETB_MapquestPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://www.mapquest.com/?q=' + lat + ',' + lon + '&zoom=' + zoom + '&maptype=map'; window.open(mapsUrl, '_blank'); }); $('#WMETB_OSMPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://www.openstreetmap.org/#map=' + zoom + '/' + lat + '/' + lon; window.open(mapsUrl, '_blank'); }); $('#WMETB_VMPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 5 ? 16 : zoom + 11; var mapsUrl = 'http://www.viamichelin.com/web/Maps/?zoomLevel=' + zoom + '&strCoord=' + lon + '*' + lat; window.open(mapsUrl, '_blank'); }); $('#WMETB_YahooPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://maps.yahoo.com/#mvt=m&lat=' + lat + '&lon=' + lon + '&zoom=' + zoom; window.open(mapsUrl, '_blank'); }); $('#WMETB_WikimapiaPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://wikimapia.org/#lat=' + lat + '&lon=' + lon + '&z=' + zoom; window.open(mapsUrl, '_blank'); }); $('#WMETB_OAMTCPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = 10 - 2 * zoom; zoom = (zoom < 2) ? 1 : zoom; var mapsUrl = 'http://www.oeamtc.at/maps/?lat=' + lat + '&lon=' + lon + '&zoom=' + zoom; window.open(mapsUrl, '_blank') }); $('#WMETB_GeoAdminPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')) + 5; var phi1 = ((lat * 3600) - 169028.66) / 10000; var lmd1 = ((lon * 3600) - 26782.5) / 10000; var x = 200147.07 + 308807.95 * phi1 + 3745.25 * lmd1 * lmd1 + 76.63 * phi1 * phi1 + 119.79 * phi1 * phi1 * phi1 - 194.56 * lmd1 * lmd1 * phi1; var y = 600072.37 + 211455.93 * lmd1 - 10938.51 * lmd1 * phi1 - 0.36 * lmd1 * phi1 * phi1 - 44.54 * lmd1 * lmd1 * lmd1; var mapsUrl = 'http://map.geo.admin.ch/?Y=' + y.toFixed(0) + '&X=' + x.toFixed(0) + '&zoom=' + zoom + '&bgLayer=ch.swisstopo.pixelkarte-farbe&time_current=latest&lang=de'; window.open(mapsUrl, '_blank') }); $('#WMETB_MapyPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom + 10; var mapsUrl = 'http://mapy.cz/#!x=' + lon + '&y=' + lat + '&z=' + zoom; window.open(mapsUrl, '_blank') }); $('#WMETB_MaplinkPermalink').click(function () { var href = $('.WazeControlPermalink a.fa-link')[0].href; var lon = WMETB_getQueryString(href, 'lon'); var lat = WMETB_getQueryString(href, 'lat'); var zoom = parseInt(WMETB_getQueryString(href, 'zoom')); zoom = zoom > 6 ? 19 : zoom + 12; var mapsUrl = 'http://www.maplink.com.br/?loc=' + lat + ',' + lon + ',' + zoom; window.open(mapsUrl, '_blank') });
    }, WMETB_ToolBar_Permalink_Obj = Class.extend({ init: function (pl) { this.Add_Permalink(pl); }, Add_Permalink: function (pl) { for (var k in WMETB_Permalinks) { if (pl == k) { var plname = WMETB_Permalinks[k][0]; var plid = WMETB_Permalinks[k][1]; var plimg = WMETB_Permalinks[k][2] + ".png"; WMETB_NavBar.innerHTML += '<img id="' + plid + '" class="WMETBtooltip" title="Permalink to ' + plname + '" src="' + document[plimg].src + '">'; $('#' + plid).css('cursor', 'pointer'); } } } }); tb.push(47); var WMETB_ToolBar_Obj = Class.extend({
        init: function () { WMETB_ToolBar_Obj.objects.push(this); var WMETB_NavBar = document.createElement('div'); WMETB_NavBar.id = "WMETB_NavBar"; WMETB_NavBar.style.position = 'fixed'; WMETB_NavBar.style.visibility = 'hidden'; WMETB_NavBar.style.zIndex = 1000; $('#map').append(WMETB_NavBar); $('#WMETB_NavBar').css('font-size', 'xx-small'); $('#WMETB_NavBar').css('line-height', '18px'); $('#WMETB_NavBar').css('border - radius', '5px'); $('#WMETB_NavBar').css(' - webkit - border - radius', '5px'); $('#WMETB_NavBar').css(' - moz - border - radius', '5px'); $('#WMETB_NavBar').css('color', '#111111'); $('#WMETB_NavBar').css('background-color', '#cccccc'); $('#WMETB_NavBar').css('margin', '1px'); $('#WMETB_NavBar').css('border', 'none'); $('#WMETB_NavBar').css('border - color', 'black'); $('#WMETB_NavBar').css('border - width', '1px'); $('#WMETB_NavBar').css('padding', '2px'); $('#WMETB_NavBar').css('text - align', 'center'); $('#WMETB_NavBar').css('opacity', '0.8'); $('#WMETB_NavBar').css('left', $('#sidebar').width() + $('.olControlScaleLineBottom').width() + 60 + 'px'); $('#WMETB_NavBar').css('top', (($(window).height() - $('.WazeMapFooter').height() - 30) + 'px')); $('#WMETB_NavBar').draggable({ cursor: 'move', delay: 100, distance: 10, scroll: false }); this.refresh(); }, refresh: function () {
            var obj = WMETB_ToSave.ToolbarFeatures, total_keys = 8; for (var key in obj) { if (obj[key] == true) { total_keys++; } }
            total_keys = total_keys + Object.keys(WMETB_ToSave.extpermalink).length; if (sec.WMETB_IsGC()) { total_keys = total_keys + 2; }
            if (Numrows == 0) { $('#WMETB_NavBar').css('width', '26px'); WMETB_NavBar.innerHTML = '<div id="WMETB_NavBarSpanVert">Toolbox'; } else { WMETB_NavBar.innerHTML = '<div id="WMETB_NavBarSpan">Toolbox'; $('#WMETB_NavBar').css('width', (Math.ceil(total_keys / Numrows) * 26) + 4 + 'px'); }
            WMETB_NavBar.innerHTML += '<img id="WMETB_ToggleSidebar" class="WMETBtooltip" title="Auto hide sidebar" src="' + document["sidebar_arrow_left.png"].src + '">'; var pic = WMETB_ToSave.EnableHighlights ? "power_green.png" : "power_red.png"; WMETB_NavBar.innerHTML += '<img id="WMETB_ToggleHighlights" class="WMETBtooltip" title="Toggle Toolbox highlights" src="' + document[pic].src + '">'; var pic = WMETB_ToSave.ToggleLockHighlights ? "lock_green.png" : "lock_red.png"; WMETB_NavBar.innerHTML += '<img id="WMETB_ToggleLockHighlights" class="WMETBtooltip" title="Toggle Toolbox lock highlights" src="' + document[pic].src + '">'; if (WMETB_LiveMapOverviewFeatureActive) { var overviewMapPic = WMETB_ToSave.LiveMapOverviewFeatures.EnableLiveMapOverview ? "search-icon-green.png" : "search-icon-red.png"; var overviewMapTitle = "Toggle mini-map"; } else { var overviewMapPic = "search-icon-grey.png"; var overviewMapTitle = "Mini-map feature is disabled"; }
            WMETB_NavBar.innerHTML += '<img id="WMETB_ToggleLiveMapOverview" class="WMETBtooltip" title="' + overviewMapTitle + '" src="' + document[overviewMapPic].src + '">'; WMETB_NavBar.innerHTML += '<img id="WMETB_ConfigurationPanel" class="WMETBtooltip" title="Toolbox configuration panel" src="' + document["cp.png"].src + '">'; total_keys = 8; if (WMETB_ToSave.ToolbarFeatures.KeyboardShortcutEditor) { WMETB_NavBar.innerHTML += '<img id="WMETB_KeyboardShortcutEditor" class="WMETBtooltip" title="Keyboard shortcuts editor" src="' + document["keyboard.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.SelectSegments && sec.WMETB_RightsCheck("SegLi")) { WMETB_NavBar.innerHTML += '<img id="WMETB_SelectSegmentsOpen" class="WMETBtooltip" title="Select segments" src="' + document["select.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.SelectVenues && sec.WMETB_RightsCheck("PlaLi")) { WMETB_NavBar.innerHTML += '<img id="WMETB_SelectVenuesOpen" class="WMETBtooltip" title="Select places" src="' + document["select_venue.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.MeasurementTool && sec.WMETB_RightsCheck("MeasT")) { WMETB_NavBar.innerHTML += '<img id="WMETB_MeasurementTool" class="WMETBtooltip" title="Measurement tool" src="' + document["WMETB_Ruler.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.PropertiesEditor && sec.WMETB_RightsCheck("PropEd")) { WMETB_NavBar.innerHTML += '<img id="WMETB_PropertiesEditor" class="WMETBtooltip" title="Properties editor" src="' + document["pe_off.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.CopySegmentAttributes && sec.WMETB_RightsCheck("CSA")) { WMETB_NavBar.innerHTML += '<img id="WMETB_CopySegmentAttributes" class="WMETBtooltip" title="Copy segment attributes" src="' + document["WMETB_CopySegmentAttributes_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.Clear_Road_Geometry && sec.WMETB_RightsCheck("ClearGeom")) { WMETB_NavBar.innerHTML += '<img id="WMETB_Clear_Road_Geometry" class="WMETBtooltip" title="Clear road geometry" src="' + document["Clear_Road_Geometry_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.Split_Road && sec.WMETB_RightsCheck("CutSeg")) { WMETB_NavBar.innerHTML += '<img id="WMETB_Split_Road" class="WMETBtooltip" title="Cut segment" src="' + document["Split_Road_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.CreateJunctions && sec.WMETB_RightsCheck("CreateJunc")) { WMETB_NavBar.innerHTML += '<img id="WMETB_CreateJunctions" class="WMETBtooltip" title="Create junctions" src="' + document["WMETB_CreateJunctions.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.SelectRDBTNavBar && sec.WMETB_RightsCheck("SelRB")) { WMETB_NavBar.innerHTML += '<img id="WMETB_SelectRDBTNavBar" class="WMETBtooltip" title="Select all roundabout segments" src="' + document["RDB_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.RedoRDBTNavBar && sec.WMETB_RightsCheck("RedoRB")) { WMETB_NavBar.innerHTML += '<img id="WMETB_RedoRDBTNavBar" class="WMETBtooltip" title="Redo roundabout" src="' + document["RDB_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.NotRDBTNavBar && sec.WMETB_RightsCheck("RBStan")) { WMETB_NavBar.innerHTML += '<img id="WMETB_NotRDBTNavBar" class="WMETBtooltip" title="Convert roundabout to standard road" src="' + document["RDB_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.DrawRDBTLandmarkNavBar && sec.WMETB_RightsCheck("RBArea")) { WMETB_NavBar.innerHTML += '<img id="WMETB_DrawRDBTLandmarkNavBar" class="WMETBtooltip" title="Draw roundabout area place" src="' + document["RDB_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.Select_In_Landmark && sec.WMETB_RightsCheck("SelArea")) { WMETB_NavBar.innerHTML += '<img id="WMETB_Select_In_Landmark" class="WMETBtooltip" title="Select in area place" src="' + document["Select_In_Landmark_Grey.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.SuppressUnneededJunctions && sec.WMETB_RightsCheck("FixSuppJunc")) { WMETB_NavBar.innerHTML += '<img id="WMETB_SuppressUnneededJunctions" class="WMETBtooltip" title="Suppress unneeded junctions" src="' + document["wipe.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.SuppressUnneededGeometry && sec.WMETB_RightsCheck("FixSuppGeoSel")) { WMETB_NavBar.innerHTML += '<img id="WMETB_SuppressUnneededGeometry" class="WMETBtooltip" title="Suppress unneeded geometry" src="' + document["WMETB_SuppressUnneededGeometry_Grey.png"].src + '">'; total_keys++; if (sec.WMETB_RightsCheck("FixSuppGeoAll")) { $('#WMETB_SuppressUnneededGeometry').attr('src', document["WMETB_SuppressUnneededGeometry.png"].src); } }
            if (WMETB_ToSave.ToolbarFeatures.DeletePastRestrictions && sec.WMETB_RightsCheck("FixExpRest")) { WMETB_NavBar.innerHTML += '<img id="WMETB_DeletePastRestrictions" class="WMETBtooltip" title="Delete expired restrictions" src="' + document["WMETB_DeletePastRestrictions.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.magicFixLoops && sec.WMETB_RightsCheck("FixLoops")) { WMETB_NavBar.innerHTML += '<img id="WMETB_magicFixLoops" class="WMETBtooltip" title="Auto add node to loops" src="' + document["WMETB_magicFixLoops.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.magicFixUnconfirmed && sec.WMETB_RightsCheck("FixUncTurn")) { WMETB_NavBar.innerHTML += '<img id="WMETB_magicFixUnconfirmed" class="WMETBtooltip" title="Auto fix unconfirmed turns" src="' + document["UnconfirmedNode.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.magicFixToll && sec.WMETB_RightsCheck("FixToll")) { WMETB_NavBar.innerHTML += '<img id="WMETB_magicFixToll" class="WMETBtooltip" title="Select non freeway/ramp segments with toll attribute" src="' + document["WMETB_magicFixToll.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.magicFixOthers && sec.WMETB_RightsCheck("FixOther")) { WMETB_NavBar.innerHTML += '<img id="WMETB_magicFixOthers" class="WMETBtooltip" title="Auto fix reverse connections, dead-end loops and unterminated roads" src="' + document["WMETB_magicFixOthers.png"].src + '">'; total_keys++; }
            if (WMETB_ToSave.ToolbarFeatures.magicFixUturns && sec.WMETB_RightsCheck("FixUTurnRed")) { WMETB_NavBar.innerHTML += '<img id="WMETB_magicFixUturns" class="WMETBtooltip" title="Auto fix u-turns" src="' + document["UTurnNode.png"].src + '">'; total_keys++; }
            if (sec.WMETB_IsGC()) { global.WMETB_NavBar = WMETB_NavBar; var sc2 = new Function('var sec=arguments[0]; var global=arguments[1];' + dc(sc[2])); sc2(sec, global); total_keys = total_keys + 2; }
            for (var k in WMETB_Permalinks) { if ($.inArray(k, WMETB_ToSave.extpermalink) >= 0) { new WMETB_ToolBar_Permalink_Obj(k); total_keys++; } }
            WMETB_Permalink_Register_Links(); if (Numrows == 0) { } else { $('#WMETB_NavBar').css('width', (Math.ceil(total_keys / Numrows) * 26) + 4 + 'px'); }
            $('#WMETB_ConfigurationPanel').css('cursor', 'pointer'); $('#WMETB_ConfigurationPanel').click(function () { WMETB_ConfigurationPanel(); }); $('#WMETB_KeyboardShortcutEditor').css('cursor', 'pointer'); $('#WMETB_KeyboardShortcutEditor').click(function () { var WMETB_KeyboardShortcutEditor = new KeyboardShortcutEditor; WMETB_KeyboardShortcutEditor.show(); }); $('#WMETB_SelectSegmentsOpen').css('cursor', 'pointer'); $('#WMETB_SelectSegmentsOpen').click(function () { WMETB_createSelectListsSegment(); }); $('#WMETB_SelectVenuesOpen').css('cursor', 'pointer'); $('#WMETB_SelectVenuesOpen').click(function () { WMETB_createSelectListsVenue(); }); $('#WMETB_MeasurementTool').css('cursor', 'pointer'); $('#WMETB_MeasurementTool').click(function () { WMETB_MeasurementToolRuler(); }); $('#WMETB_NavBar').css('cursor', 'move'); $('#WMETB_ToggleSidebar').css('cursor', 'pointer'); $('#WMETB_ToggleHighlights').css('cursor', 'pointer'); $('#WMETB_ToggleLockHighlights').css('cursor', 'pointer'); if (WMETB_LiveMapOverviewFeatureActive) { $('#WMETB_ToggleLiveMapOverview').css('cursor', 'pointer'); } else { $('#WMETB_ToggleLiveMapOverview').css('cursor', 'not-allowed'); }
            $('#WMETB_PropertiesEditor').css('cursor', 'not-allowed'); $('#WMETB_CopySegmentAttributes').css('cursor', 'not-allowed'); $('#WMETB_Clear_Road_Geometry').css('cursor', 'not-allowed'); $('#WMETB_Split_Road').css('cursor', 'not-allowed'); $('#WMETB_CreateJunctions').css('cursor', 'pointer'); $('#WMETB_SelectRDBTNavBar').css('cursor', 'not-allowed'); $('#WMETB_RedoRDBTNavBar').css('cursor', 'not-allowed'); $('#WMETB_NotRDBTNavBar').css('cursor', 'not-allowed'); $('#WMETB_DrawRDBTLandmarkNavBar').css('cursor', 'not-allowed'); $('#WMETB_Select_In_Landmark').css('cursor', 'not-allowed'); if (sec.WMETB_RightsCheck("FixSuppGeoSel")) {
                if (sec.WMETB_RightsCheck("FixSuppGeoAll")) { $('#WMETB_SuppressUnneededGeometry').css('cursor', 'pointer'); } else { $('#WMETB_SuppressUnneededGeometry').css('cursor', 'not-allowed'); }
                $('#WMETB_SuppressUnneededGeometry').click(function () { sec.WMETB_SuppressUnneededGeometry(); });
            }
            if (sec.WMETB_RightsCheck("FixSuppJunc")) { $('#WMETB_SuppressUnneededJunctions').css('cursor', 'pointer'); $('#WMETB_SuppressUnneededJunctions').click(function () { WMETB_SuppressUnneededJunctions(); }); }
            if (sec.WMETB_RightsCheck("FixExpRest")) { $('#WMETB_DeletePastRestrictions').css('cursor', 'pointer'); $('#WMETB_DeletePastRestrictions').click(function () { WMETB_DeletePastRestrictions(); }); }
            if (sec.WMETB_RightsCheck("FixLoops")) { $('#WMETB_magicFixLoops').css('cursor', 'pointer'); $("#WMETB_magicFixLoops").click(function () { sec.WMETB_magicFixLoops(); }); }
            if (sec.WMETB_RightsCheck("FixUncTurn")) { $('#WMETB_magicFixUnconfirmed').css('cursor', 'pointer'); $("#WMETB_magicFixUnconfirmed").click(function () { sec.WMETB_magicFixUnconfirmed(); }); }
            if (sec.WMETB_RightsCheck("FixToll")) { $('#WMETB_magicFixToll').css('cursor', 'pointer'); $("#WMETB_magicFixToll").click(function () { sec.WMETB_magicFixToll(); }); }
            if (sec.WMETB_RightsCheck("FixOther")) { $('#WMETB_magicFixOthers').css('cursor', 'pointer'); $("#WMETB_magicFixOthers").click(function () { sec.WMETB_magicFixOthers(); }); }
            if (sec.WMETB_RightsCheck("FixUTurnRed")) { $('#WMETB_magicFixUturns').css('cursor', 'pointer'); $("#WMETB_magicFixUturns").click(function () { sec.WMETB_magicFixUturns(); }); }
            if (sec.WMETB_IsGC()) { var sc3 = new Function('var sec=arguments[0];' + dc(sc[3])); sc3(sec); }
            $('.WMETBstandardMouseCursor').css('cursor', 'default'); $('#WMETB_ToggleSidebar').click(function () { WMETB_ToggleSidebar(); }); $('#WMETB_ToggleHighlights').click(function () { WMETB_ToggleHighlights(); }); $('#WMETB_ToggleLockHighlights').click(function () { WMETB_ToggleLockHighlights(); }); if (WMETB_LiveMapOverviewFeatureActive) { $('#WMETB_ToggleLiveMapOverview').click(function () { WMETB_ToggleLiveMapOverview(); }); }
            $('#WMETB_PropertiesEditor').click(function () { WMETB_PropertiesEditor(); }); $('#WMETB_CopySegmentAttributes').click(function () { WMETB_CopySegmentAttributes(); }); $('#WMETB_Clear_Road_Geometry').click(function () { WMETB_Clear_Road_Geometry(); }); $('#WMETB_Split_Road').click(function () { WMETB_Split_Road(); }); $('#WMETB_CreateJunctions').click(function () { WMETB_CreateJunctions(); }); $('#WMETB_SelectRDBTNavBar').click(function () { WMETB_Select_RoundAbout(); }); $('#WMETB_RedoRDBTNavBar').click(function () { WMETB_Redo_RoundAbout(); }); $('#WMETB_NotRDBTNavBar').click(function () { WMETB_RDBToStandardRoad(); }); $('#WMETB_DrawRDBTLandmarkNavBar').click(function () { WMETB_RDBLandmark(); }); $('#WMETB_Select_In_Landmark').click(function () { WMETB_Select_In_Landmark(); });
        }
    }); tc.push(1); var WMETB_Saved_Obj = Class.extend({ init: function (Switcher) { WMETB_Saved_Obj.objects.push(this); this.Switcher = Switcher; this.FullSwitcher = "WMETB_cb" + this.Switcher; } }), WMETB_Save_All = function () {
        'use strict'; if (WMETB_SaveOnExit) {
            console.log("WMETB: saving options"); for (var i = 0; i < WMETB_Highlight_Obj.objects.length; i++) { WMETB_ToSave[WMETB_Highlight_Obj.objects[i].ShortSwitcher] = WMETB_Highlight_Obj.objects[i].LineLayer.getVisibility(); }
            WMETB_ToSave.NavBarLeft = $('#WMETB_NavBar').position().left; WMETB_ToSave.NavBarTop = $('#WMETB_NavBar').position().top; if (localStorage.keyboardShortcuts) { var WME_Options = JSON.parse(localStorage.keyboardShortcuts); $.each(WMETB_ShortcutsMenu.RegistredFeatures, function (i) { WMETB_Shortcuts[WMETB_ShortcutsMenu.RegistredFeatures[i]] = WME_Options[WMETB_ShortcutsMenu.RegistredFeatures[i]]; }); }
            localStorage.WME_Toolbox_Options = JSON.stringify(WMETB_ToSave); localStorage.WME_Toolbox_Shortcuts = JSON.stringify(WMETB_Shortcuts);
        }
    }; tb.push(64); var WMETB_Shortcuts_Obj = Class.extend({ init: function (group, desc) { this.group = group; this.desc = desc; this.RegistredFeatures = []; Waze.accelerators.Groups[group] = {}; Waze.accelerators.Groups[group].members = []; I18n.translations[I18n.locale].keyboard_shortcuts.groups[group] = {}; I18n.translations[I18n.locale].keyboard_shortcuts.groups[group].description = desc; I18n.translations[I18n.locale].keyboard_shortcuts.groups[group].members = []; Waze.accelerators.SpecialKeys[96] = "[NumPad] 0"; Waze.accelerators.SpecialKeys[97] = "[NumPad] 1"; Waze.accelerators.SpecialKeys[98] = "[NumPad] 2"; Waze.accelerators.SpecialKeys[99] = "[NumPad] 3"; Waze.accelerators.SpecialKeys[100] = "[NumPad] 4"; Waze.accelerators.SpecialKeys[101] = "[NumPad] 5"; Waze.accelerators.SpecialKeys[102] = "[NumPad] 6"; Waze.accelerators.SpecialKeys[103] = "[NumPad] 7"; Waze.accelerators.SpecialKeys[104] = "[NumPad] 8"; Waze.accelerators.SpecialKeys[105] = "[NumPad] 9"; Waze.accelerators.SpecialKeys[45] = "Insert"; Waze.accelerators.SpecialKeys[36] = "Home"; Waze.accelerators.SpecialKeys[33] = "Page Up"; Waze.accelerators.SpecialKeys[35] = "End"; Waze.accelerators.SpecialKeys[34] = "Page Down"; }, AddItem: function (ref, title, func, defkey) { this.RegistredFeatures.push(ref); I18n.translations[I18n.locale].keyboard_shortcuts.groups.toolbox.members[ref] = title; Waze.accelerators.addAction(ref, { group: this.group }); Waze.accelerators.events.register(ref, null, func); }, GetItems: function () { var g = this.group; $.each(Waze.accelerators.shortcutToAction, function (index, value) { if (value.group == g) { var v = JSON.stringify(value); } }); }, RestoreItems: function () { Object.forEach(WMETB_Shortcuts, function (e, t) { Waze.accelerators.registerShortcut(t, e, true) }); } }); var WMETB_reloadShortcuts = function () {
        if (typeof WMETB_ShortcutsMenu === 'undefined' || WMETB_ShortcutsMenu === null)
        { WMETB_ShortcutsMenu = new WMETB_Shortcuts_Obj("toolbox", "Toolbox"); }
        else
        {
            for (var f = 0; f < WMETB_ShortcutsMenu.RegistredFeatures.length; f++)
            { Waze.accelerators.events.unregister(Waze.accelerators.Actions[WMETB_ShortcutsMenu.RegistredFeatures[f]], null, Waze.accelerators.events.listeners[WMETB_ShortcutsMenu.RegistredFeatures[f]]); delete Waze.accelerators.Actions[WMETB_ShortcutsMenu.RegistredFeatures[f]]; delete Waze.accelerators.events.listeners[WMETB_ShortcutsMenu.RegistredFeatures[f]]; }
            Waze.accelerators.Groups.toolbox = { members: [] }; WMETB_ShortcutsMenu.RegistredFeatures = [];
        }
        WMETB_ShortcutsMenu.AddItem("WMETBsc_MoveMapUp", "Pan up from screen size", function () { Waze.map.pan(0, -$("#WazeMap").height()); }); Waze.accelerators._registerShortcuts({ 104: "WMETBsc_MoveMapUp" }); WMETB_ShortcutsMenu.AddItem("WMETBsc_MoveMapDown", "Pan down from screen size", function () { Waze.map.pan(0, $("#WazeMap").height()); }); Waze.accelerators._registerShortcuts({ 98: "WMETBsc_MoveMapDown" }); WMETB_ShortcutsMenu.AddItem("WMETBsc_MoveMapLeft", "Pan left from screen size", function () { Waze.map.pan(-$("#WazeMap").width(), 0); }); Waze.accelerators._registerShortcuts({ 100: "WMETBsc_MoveMapLeft" }); WMETB_ShortcutsMenu.AddItem("WMETBsc_MoveMapRight", "Pan right from screen size", function () { Waze.map.pan($("#WazeMap").width(), 0); }); Waze.accelerators._registerShortcuts({ 102: "WMETBsc_MoveMapRight" }); WMETB_ShortcutsMenu.AddItem("WMETBsc_ToggleHighlights", "Toggle Toolbox highlights", WMETB_ToggleHighlights); WMETB_ShortcutsMenu.AddItem("WMETBsc_ToggleLockHighlights", "Toggle Toolbox lock highlights", WMETB_ToggleLockHighlights); if (WMETB_LiveMapOverviewFeatureActive)
            WMETB_ShortcutsMenu.AddItem("WMETBsc_ToggleLiveMapOverview", "Toggle mini-map", WMETB_ToggleLiveMapOverview); WMETB_ShortcutsMenu.AddItem("WMETBsc_EnterAddress", "Enter address (no prefill)", WMETB_EnterAddressNoClearCity); WMETB_ShortcutsMenu.AddItem("WMETBsc_EnterAddressPrefill", "Enter address (prefill city, state, country)", WMETB_EnterAddressPrefill); if (sec.WMETB_RightsCheck("SegLi")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SelectSegments", "Select segments", WMETB_createSelectListsSegment); }
        if (sec.WMETB_RightsCheck("PlaLi")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SelectVenues", "Select places", WMETB_createSelectListsVenue); }
        if (sec.WMETB_RightsCheck("MeasT")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_MeasurementTool", "Measurement tool", WMETB_MeasurementToolRuler); }
        if (sec.WMETB_RightsCheck("PropEd")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_PropertiesEditor", "Properties editor", WMETB_PropertiesEditor); }
        if (sec.WMETB_RightsCheck("CSA")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_CopySegmentAttributes", "Copy segment attributes", WMETB_CopySegmentAttributes); }
        if (sec.WMETB_RightsCheck("ClearGeom")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_ClearRoadGeometry", "Clear road geometry", WMETB_Clear_Road_Geometry); Waze.accelerators._registerShortcuts({ 1: "WMETBsc_ClearRoadGeometry" }); }
        if (sec.WMETB_RightsCheck("CutSeg")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SplitRoad", "Cut segment", WMETB_Split_Road); }
        if (sec.WMETB_RightsCheck("CreateJunc")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_CreateJunctions", "Create junctions", WMETB_CreateJunctions); }
        if (sec.WMETB_RightsCheck("EleGround")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_ResetElevation", "Reset elevation to ground", WMETB_ResetElevation); }
        if (sec.WMETB_RightsCheck("SelRB")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SelectRoundabout", "Select roundabout", WMETB_Select_RoundAbout); }
        if (sec.WMETB_RightsCheck("RedoRB")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_RedoRoundabout", "Redo roundabout", WMETB_Redo_RoundAbout); Waze.accelerators._registerShortcuts({ 2: "WMETBsc_RedoRoundabout" }); }
        if (sec.WMETB_RightsCheck("RBStan")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_RoundaboutToStandardRoad", "Roundabout to standard road", WMETB_RDBToStandardRoad); Waze.accelerators._registerShortcuts({ 3: "WMETBsc_RoundaboutToStandardRoad" }); }
        if (sec.WMETB_RightsCheck("RBArea")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_DrawRoundaboutLandmark", "Draw roundabout area place", WMETB_RDBLandmark); }
        if (sec.WMETB_RightsCheck("SelArea")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SelectInLandmark", "Select in area place", WMETB_Select_In_Landmark); }
        if (sec.WMETB_RightsCheck("FixSuppJunc")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SuppressUnneededJunctions", "Suppress unneeded junctions", WMETB_SuppressUnneededJunctions); }
        if (sec.WMETB_RightsCheck("FixSuppGeoSel") || sec.WMETB_RightsCheck("FixSuppGeoAll")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_SuppressUnneededGeometry", "Suppress unneeded geometry", sec.WMETB_SuppressUnneededGeometry); }
        if (sec.WMETB_RightsCheck("FixExpRest")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_DeletePastRestrictions", "Delete expired restrictions", WMETB_DeletePastRestrictions); }
        if (sec.WMETB_RightsCheck("FixLoops")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_magicFixLoops", "Auto add node to loops", sec.WMETB_magicFixLoops); }
        if (sec.WMETB_RightsCheck("FixUncTurn")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_magicFixUnconfirmed", "Auto fix unconfirmed turns", sec.WMETB_magicFixUnconfirmed); }
        if (sec.WMETB_RightsCheck("FixToll")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_magicFixToll", "Select non freeway/ramp segments with toll attribute", sec.WMETB_magicFixToll); }
        if (sec.WMETB_RightsCheck("FixOther")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_magicFixOthers", "Auto fix reverse connections, dead-end loops and unterminated roads", sec.WMETB_magicFixOthers); }
        if (sec.WMETB_RightsCheck("FixUTurnRed")) { WMETB_ShortcutsMenu.AddItem("WMETBsc_magicFixUturns", "Auto fix u-turns", sec.WMETB_magicFixUturns); }
        if (sec.WMETB_IsGC()) { global.WMETB_ShortcutsMenu = WMETB_ShortcutsMenu; var sc1 = new Function('var sec=arguments[0];\n var global=arguments[1];' + dc(sc[1])); sc1(sec, global); }
        WMETB_ShortcutsMenu.RestoreItems();
    }; tb.push(15); var WMETB_ConfigurationPanel = function () {
        'use strict'; if (typeof (WMETB_cfgpanel) === 'undefined') { WMETB_cfgpanel = new WMETB_cfgdialog(); }
        Waze.selectionManager.unselectAll(); WMETB_cfgpanel.popup.dialog("open");
    }, WMETB_cfgdialog = Class.extend({
        init: function () {
            this.popup = $(createElement(document.body, 'DIV', 'WMETB_ConfigurationPanel')).css('font-size', '70.5%'); this.plist = $('<div>'); this.popup.dialog({
                autoOpen: false, modal: true, show: "fast", width: 500, height: 500, dialogClass: "cfgedit", title: "Toolbox - Configuration panel", buttons: { Ok: function () { $(this).dialog("close"); } }, close: function () {
                    WMETB_ToSave.pointPlaceZoom = $("input[name='chooseFeature-PointPlaceZoom']").prop('checked'); WMETB_ToSave.highlightElevationMarkers = $("input[name='chooseFeature-ElevationMarkers']").prop('checked'); WMETB_ToSave.LiveMapOverviewFeatures.LiveMapOverviewFeatureActive = $("input[name='chooseFeature-LiveMapOverviewFeatureActive']").prop('checked'); WMETB_ToSave.LiveMapOverviewFeatures.RecenterWME = $("input[name='chooseFeature-PanLiveMapToWME']").prop('checked'); WMETB_ToSave.LiveMapOverviewFeatures.RecenterLiveMap = $("input[name='chooseFeature-PanWMEToLiveMap']").prop('checked'); WMETB_ToSave.ToolbarFeatures.KeyboardShortcutEditor = $("input[name='chooseFeature-KeyboardShortcutEditor']").prop('checked'); if (sec.WMETB_RightsCheck("SegLi")) { WMETB_ToSave.ToolbarFeatures.SelectSegments = $("input[name='chooseFeature-SelectSegments']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("PlaLi")) { WMETB_ToSave.ToolbarFeatures.SelectVenues = $("input[name='chooseFeature-SelectVenues']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("MeasT")) { WMETB_ToSave.ToolbarFeatures.MeasurementTool = $("input[name='chooseFeature-MeasurementTool']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("PropEd")) { WMETB_ToSave.ToolbarFeatures.PropertiesEditor = $("input[name='chooseFeature-PropertiesEditor']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("CSA")) { WMETB_ToSave.ToolbarFeatures.CopySegmentAttributes = $("input[name='chooseFeature-CopySegmentAttributes']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("ClearGeom")) { WMETB_ToSave.ToolbarFeatures.Clear_Road_Geometry = $("input[name='chooseFeature-Clear_Road_Geometry']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("CutSeg")) { WMETB_ToSave.ToolbarFeatures.Split_Road = $("input[name='chooseFeature-Split_Road']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("CreateJunc")) { WMETB_ToSave.ToolbarFeatures.CreateJunctions = $("input[name='chooseFeature-CreateJunctions']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("SelRB")) { WMETB_ToSave.ToolbarFeatures.SelectRDBTNavBar = $("input[name='chooseFeature-SelectRDBTNavBar']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("RedoRB")) { WMETB_ToSave.ToolbarFeatures.RedoRDBTNavBar = $("input[name='chooseFeature-RedoRDBTNavBar']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("RBStan")) { WMETB_ToSave.ToolbarFeatures.NotRDBTNavBar = $("input[name='chooseFeature-NotRDBTNavBar']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("RBArea")) { WMETB_ToSave.ToolbarFeatures.DrawRDBTLandmarkNavBar = $("input[name='chooseFeature-DrawRDBTLandmarkNavBar']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("SelArea")) { WMETB_ToSave.ToolbarFeatures.Select_In_Landmark = $("input[name='chooseFeature-Select_In_Landmark']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixSuppJunc")) { WMETB_ToSave.ToolbarFeatures.SuppressUnneededJunctions = $("input[name='chooseFeature-SuppressUnneededJunctions']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixSuppGeoSel") || (sec.WMETB_RightsCheck("FixSuppGeoAll"))) { WMETB_ToSave.ToolbarFeatures.SuppressUnneededGeometry = $("input[name='chooseFeature-SuppressUnneededGeometry']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixExpRest")) { WMETB_ToSave.ToolbarFeatures.DeletePastRestrictions = $("input[name='chooseFeature-DeletePastRestrictions']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixLoops")) { WMETB_ToSave.ToolbarFeatures.magicFixLoops = $("input[name='chooseFeature-magicFixLoops']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixUncTurn")) { WMETB_ToSave.ToolbarFeatures.magicFixUnconfirmed = $("input[name='chooseFeature-magicFixUnconfirmed']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixToll")) { WMETB_ToSave.ToolbarFeatures.magicFixToll = $("input[name='chooseFeature-magicFixToll']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixOther")) { WMETB_ToSave.ToolbarFeatures.magicFixOthers = $("input[name='chooseFeature-magicFixOthers']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("FixUTurnRed")) { WMETB_ToSave.ToolbarFeatures.magicFixUturns = $("input[name='chooseFeature-magicFixUturns']").prop('checked'); }
                    WMETB_ToSave.extpermalink.length = 0; $("input[name='choosepermalink[]']:checked").each(function (i) { WMETB_ToSave.extpermalink.push(this.value); }); WMETB_ToolBar.refresh(); WMETB_ToggleUserGreetings($("input[name='chooseUserGreetings']").prop('checked')); if (sec.WMETB_RightsCheck("PopUps")) { WMETB_ToSave.Popups = $("input[name='choosePopups']").prop('checked'); }
                    if (sec.WMETB_RightsCheck("ArrLoad")) { WMETB_ToSave.ForceArrows = $("input[name='chooseForceArrows']").prop('checked'); }
                    WMETB_ToggleZoomControlLeft($("input[name='chooseZoomControlLeft']").prop('checked')); WMETB_ToggleZoomLevelIndicator($("input[name='chooseZoomLevelIndicator']").prop('checked')); WMETB_ToSave.RepairLayerSettings = $("input[name='chooseRepairLayerSettings']").prop('checked');
                }
            }); this.popup.append(this.plist); $('div.cfgedit').attr('style', 'position: absolute; top: 0; left: 0; padding: .2em; width: 300px; overflow: hidden;background:rgba(255, 255, 255, ' + WMETB_ToSave.alpha / 100 + ')'); var option = '<input name="chooseUserGreetings" type="checkbox" ' + (WMETB_ToSave.HideUserGreetings ? 'checked ' : '') + '/> Hide user info<br>'; this.popup.append(option); if (sec.WMETB_RightsCheck("PopUps")) { var option = '<input name="choosePopups" type="checkbox" ' + (WMETB_ToSave.Popups ? 'checked ' : '') + '/> Activate popups<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("ArrLoad")) { var option = '<input name="chooseForceArrows" type="checkbox" ' + (WMETB_ToSave.ForceArrows ? 'checked ' : '') + '/> Force arrows to be selectable after loading<br>'; this.popup.append(option); }
            var option = '<br>Snapping control<br>'; this.popup.append(option); var option = ($("<span style='text-align:left'>").append("Snap distance: ")).append($("<input id='WMETB_snapDistSpinner' value=" + tolerance + ">")).append(" pixels")
            this.popup.append(option); var option = '<br>'; this.popup.append(option); $('#WMETB_snapDistSpinner').width(20).spinner({ min: 0, max: 30, step: 5, spin: function (event, ui) { tolerance = ui.value; WMETB_setSnapDistance(ui.value); }, change: function (event, ui) { WMETB_ToSave.snapdst = tolerance; } }); if (sec.WMETB_VerifiedUserRank >= 3) {
                var option = '<br>Check forum inbox<br>'; this.popup.append(option); var option = ($("<span style='text-align:left'>").append("Frequency: ")).append($("<input id='WMETB_forumCheckSpinner' value=" + forumCheckDuration + ">")).append(" minutes (Set to 0 to disable)")
                this.popup.append(option); var option = '<br>'; this.popup.append(option);
            }
            $('#WMETB_forumCheckSpinner').width(20).spinner({ min: 0, max: 60, step: 5, spin: function (event, ui) { forumCheckDuration = ui.value; }, change: function (event, ui) { WMETB_ToSave.forumCheck = forumCheckDuration; } }); var option = '<br>Toolbar rows<br>'; this.popup.append(option); var option = ($("<span style='text-align:left'>").append("Rows: ")).append($("<input id='WMETB_Numrows' value=" + Numrows + ">")).append(" (set to 0 for vertical)")
            this.popup.append(option); var option = '<br>'; this.popup.append(option); $('#WMETB_Numrows').width(6).spinner({ min: 0, max: 3, step: 1, spin: function (event, ui) { Numrows = ui.value; }, change: function (event, ui) { WMETB_ToSave.Numrows = Numrows; } }); var option = '<br>Places options<br>'; this.popup.append(option); var option = '<span style="text-align:left"><input name="chooseFeature-PointPlaceZoom" type="checkbox" ' + (WMETB_ToSave.pointPlaceZoom ? 'checked ' : '') + '" /> Show point places at zoom 3+ instead of 5+<br>'; this.popup.append(option); var option = '<br>Toolbox features to display in toolbar:<br>'; this.popup.append(option); var option = '<input name="chooseFeature-KeyboardShortcutEditor" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.KeyboardShortcutEditor ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["keyboard.png"].src + '"> Keyboard shortcuts editor<br>'; this.popup.append(option); if (sec.WMETB_RightsCheck("SegLi")) { var option = '<input name="chooseFeature-SelectSegments" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.SelectSegments ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["select.png"].src + '"> Select segments<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("PlaLi")) { var option = '<input name="chooseFeature-SelectVenues" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.SelectVenues ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["select_venue.png"].src + '"> Select places<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("MeasT")) { var option = '<input name="chooseFeature-MeasurementTool" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.MeasurementTool ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_Ruler.png"].src + '"> Measurement tool<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("PropEd")) { var option = '<input name="chooseFeature-PropertiesEditor" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.PropertiesEditor ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["pe_on.png"].src + '"> Properties editor<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("CSA")) { var option = '<input name="chooseFeature-CopySegmentAttributes" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.CopySegmentAttributes ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_CopySegmentAttributes.png"].src + '"> Copy segment attributes<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("ClearGeom")) { var option = '<input name="chooseFeature-Clear_Road_Geometry" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.Clear_Road_Geometry ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["Clear_Road_Geometry.png"].src + '"> Clear road geometry<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("CutSeg")) { var option = '<input name="chooseFeature-Split_Road" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.Split_Road ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["Split_Road.png"].src + '"> Cut segment<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("CreateJunc")) { var option = '<input name="chooseFeature-CreateJunctions" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.CreateJunctions ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_CreateJunctions.png"].src + '"> Create Junctions<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("SelRB")) { var option = '<input name="chooseFeature-SelectRDBTNavBar" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.SelectRDBTNavBar ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["RDB_Select.png"].src + '"> Select all roundabout segments<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("RedoRB")) { var option = '<input name="chooseFeature-RedoRDBTNavBar" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.RedoRDBTNavBar ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["RDB_Redo.png"].src + '"> Redo roundabout<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("RBStan")) { var option = '<input name="chooseFeature-NotRDBTNavBar" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.NotRDBTNavBar ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["RDB_StandardRoad.png"].src + '"> Convert roundabout to standard road<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("RBArea")) { var option = '<input name="chooseFeature-DrawRDBTLandmarkNavBar" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.DrawRDBTLandmarkNavBar ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["RDB_Landmark.png"].src + '"> Draw roundabout area place<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("SelArea")) { var option = '<input name="chooseFeature-Select_In_Landmark" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.Select_In_Landmark ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["Select_In_Landmark.png"].src + '"> Select in area place<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixSuppJunc")) { var option = '<input name="chooseFeature-SuppressUnneededJunctions" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.SuppressUnneededJunctions ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["wipe.png"].src + '"> Suppress unneeded junctions<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixSuppGeoSel") || sec.WMETB_RightsCheck("FixSuppGeoAll")) { var option = '<input name="chooseFeature-SuppressUnneededGeometry" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.SuppressUnneededGeometry ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_SuppressUnneededGeometry.png"].src + '"> Suppress unneeded geometry<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixExpRest")) { var option = '<input name="chooseFeature-DeletePastRestrictions" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.DeletePastRestrictions ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_DeletePastRestrictions.png"].src + '"> Delete expired restrictions<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixLoops")) { var option = '<input name="chooseFeature-magicFixLoops" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.magicFixLoops ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_magicFixLoops.png"].src + '"> Auto add node to loops<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixUncTurn")) { var option = '<input name="chooseFeature-magicFixUnconfirmed" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.magicFixUnconfirmed ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["UnconfirmedNode.png"].src + '"> Auto fix unconfirmed turns<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixToll")) { var option = '<input name="chooseFeature-magicFixToll" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.magicFixToll ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_magicFixToll.png"].src + '"> Select non freeway/ramp segments with toll attribute<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixOther")) { var option = '<input name="chooseFeature-magicFixOthers" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.magicFixOthers ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_magicFixOthers.png"].src + '"> Auto fix reverse connections, dead-end and unterminated roads<br>'; this.popup.append(option); }
            if (sec.WMETB_RightsCheck("FixUTurnRed")) { var option = '<input name="chooseFeature-magicFixUturns" type="checkbox" ' + (WMETB_ToSave.ToolbarFeatures.magicFixUturns ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["UTurnNode.png"].src + '"> Auto fix u-turns<br>'; this.popup.append(option); }
            var option = '<br>External permalinks to display in toolbar:<br>'; this.popup.append(option); for (var k in WMETB_Permalinks) {
                var e = false; if ($.inArray(k, WMETB_ToSave.extpermalink) >= 0) { e = true; }
                var plname = WMETB_Permalinks[k][0]; var plimg = WMETB_Permalinks[k][2] + ".png"; var option = '<input name="choosepermalink[]" type="checkbox" ' + (e ? 'checked ' : '') + 'value="' + k + '" /> <img width="20" height="20" src="' + document[plimg].src + '"> ' + plname + '<br>'; this.popup.append(option);
            }
            var option = '<br>Toolbox highlights options<br>'; this.popup.append(option); var option = '<span style="text-align:left"><input name="chooseFeature-ElevationMarkers" type="checkbox" ' + (WMETB_ToSave.highlightElevationMarkers ? 'checked ' : '') + '" /> <img width="20" height="20" src="' + document["WMETB_Red5.png"].src + '"><img width="20" height="20" src="' + document["WMETB_Green9.png"].src + '"> Display elevation values with < or > ground highlight<br>'; this.popup.append(option); var option = '<br>Mini-map options<br>'; this.popup.append(option); var option = '<span style="text-align:left"><input name="chooseFeature-LiveMapOverviewFeatureActive" type="checkbox" ' + (WMETB_ToSave.LiveMapOverviewFeatures.LiveMapOverviewFeatureActive ? 'checked ' : '') + '" /> Mini-map feature enabled (requires restart)<br>'; this.popup.append(option); var option = '<span style="text-align:left"><input name="chooseFeature-PanLiveMapToWME" type="checkbox" ' + (WMETB_ToSave.LiveMapOverviewFeatures.RecenterWME ? 'checked ' : '') + '" /> Re-center WME when panning mini-map<br>'; this.popup.append(option); var option = '<span style="text-align:left"><input name="chooseFeature-PanWMEToLiveMap" type="checkbox" ' + (WMETB_ToSave.LiveMapOverviewFeatures.RecenterLiveMap ? 'checked ' : '') + '" /> Re-center mini-map when panning WME<br>'; this.popup.append(option); var option = '<br>WME fixes options<br>'; this.popup.append(option); var option = '<input name="chooseZoomControlLeft" type="checkbox" ' + (WMETB_ToSave.ZoomControlLeft ? 'checked ' : '') + '/> Move zoom control to left<br>'; this.popup.append(option); var option = '<input name="chooseZoomLevelIndicator" type="checkbox" ' + (WMETB_ToSave.ZoomLevelIndicator ? 'checked ' : '') + '/> Show zoom level<br>'; this.popup.append(option); var option = '<input name="chooseRepairLayerSettings" type="checkbox" ' + (WMETB_ToSave.RepairLayerSettings ? 'checked ' : '') + '/> Auto-repair malformed WME layer settings in local storage<br>'; this.popup.append(option);
        }
    }); tc.push(0); var WMETB_NewVersionPanel = function () {
        'use strict'; if (typeof (WMETB_newversionpanel) === 'undefined') { WMETB_newversionpanel = new WMETB_newversionpaneldialog(); }
        WMETB_newversionpanel.popup.dialog("open");
    }, WMETB_newversionpaneldialog = Class.extend({ init: function () { this.popup = $(createElement(document.body, 'DIV', 'WMETB_NewVersionPanel')).css('font-size', '70.5%'); this.plist = $('<div>'); this.popup.dialog({ autoOpen: false, modal: true, draggable: false, resizable: false, show: "fast", width: 300, height: 200, dialogClass: "newversionpanel", title: "Toolbox - Plugin update", closeOnEscape: true, open: function (event, ui) { $('.ui-dialog').css('z-index', 1101); $('.ui-widget-overlay').css('z-index', 1100); }, buttons: { Ok: function () { $(this).dialog("close"); } }, close: function () { } }); this.popup.append(this.plist); $('div.newversionpanel').attr('style', 'position: absolute; top: 0; left: 0; padding: .2em; width: 300px; overflow: hidden;'); var option = '<br><b>Hello ' + sec.WMETB_VerifiedUserName + '! Toolbox has been updated.</b><br>'; this.popup.append(option); } }); tb.push(26); WMETB_Select_In_Landmark = function () { if (Enable_WMETB_Select_In_Landmark && sec.WMETB_RightsCheck("SelArea")) { var r = confirm("Do you want to select in large mode (including segments only partially in the area)?"); if (r) { WMETB_CSelectLandMark(false); } else { WMETB_CSelectLandMark(true); } } }, WMETB_CSelectLandMark = function (strictInclude) {
        'use strict'; var geoList = []; for (var i = 0; i < Waze.selectionManager.selectedItems.length; i++) {
            var m = Waze.selectionManager.selectedItems[i].model; if (m.type == "venue")
                geoList.push(m.geometry);
        }
        if (geoList.length == 0) { for (var id in Waze.model.venues.objects) { if (id < 0) { var curLm = Waze.model.venues.objects[id]; var curFid; if (geoList.length == 0 || id < curFid) { geoList[0] = curLm.geometry; curFid = id; } } } }
        if (geoList.length > 0) {
            var lSeg = new Array(); for (var id in Waze.model.segments.objects) { var seg = Waze.model.segments.objects[id]; if (WMETB_isSegmentInGeometries(geoList, seg, !strictInclude)) { lSeg.push(seg); } }
            Waze.selectionManager.select(lSeg);
        } else { WMETB_DispWarn("No area place selected"); }
    }, WMETB_isNodeInGeometries = function (geoList, node) {
        'use strict'; var found = false; for (var j = 0; j < geoList.length; j++) { var geo = geoList[j]; if (geo.containsPoint(node.geometry)) { return true; break; } }
        return false;
    }, WMETB_isSegmentInGeometries = function (geoList, seg, partialAllowed) {
        'use strict'; for (var i = 0; i < seg.geometry.components.length; i++) {
            var p = seg.geometry.components[i]; var found = false; for (var j = 0; j < geoList.length; j++) {
                var geo = geoList[j]; if (geo.containsPoint(p)) {
                    if (partialAllowed)
                        return true; found = true; break;
                }
            }
            if (!partialAllowed && !found)
                return false;
        }
        return !partialAllowed;
    }, WMETB_isInLanmarks = function (seg) {
        'use strict'; var val = null; for (var i = 0; i < seg.geometry.components.length; i++) {
            var p = seg.geometry.components[i]; var v = 0; var lnmLst = WMETB_getSelectedLandMark(); for (var j = 0; j < lnmLst.length; j++) { if (lnmLst[j].containsPoint(p)) { v = 1; break; } }
            if (val == null)
                val = v; else if (val != v)
                    return .5;
        }
        return val;
    }; tb.push(53); var WMETB_SuppressUnneededJunctions = function () {
        'use strict'; if (sec.WMETB_RightsCheck("FixSuppJunc")) {
            if (ToolboxPending) { WMETB_DispWarn("Waze Map is refreshing, please wait"); return; }
            var g = Waze.map.getExtent().toGeometry(); var z = Waze.map.getZoom(); if (z < 4) { WMETB_DispWarn('Inappropriate zoom level: ' + Waze.map.getZoom().toString()); WMETB_DispWarn("You must increase your zoom level to perform this action"); return; }
            if (WMETB_limitForSaveReach()) { WMETB_DispWarn("Please save before continuing to edit"); return true; }
            var somethingdone = false; var count = 0; WMETB_Debug("Suppress unneeded junctions called"); for (var nodeID in Waze.model.nodes.objects) {
                WMETB_Debug("analyzing: nodeID is " + nodeID); var node = Waze.model.nodes.objects[nodeID]; if (node.state == "Delete") { WMETB_Debug("skip because delete status"); continue; }
                if (node.attributes.segIDs.length != 2) { WMETB_Debug("skip because node does not have 2 connected segments"); continue; }
                if (!node.isAllowed(node.PERMISSIONS.DELETE)) { WMETB_Debug("skip because user is not allowed to edit"); continue; }
                if (!g.containsPoint(node.geometry)) { WMETB_Debug("skip because node is off screen"); continue; }
                var segs = node.attributes.segIDs.map(function (s) { return Waze.model.segments.objects[s]; }); WMETB_Debug("seg0 is " + segs[0].getID()); WMETB_Debug("seg1 is " + segs[1].getID()); var attr0 = segs[0].attributes; var attr1 = segs[1].attributes; if (attr0.hasClosures || attr1.hasClosures) { WMETB_Debug("skip because >= 1 seg has active closure"); continue; }
                if (node.isTurnAllowedBySegDirections(segs[0], segs[1]) && segs[0].isTurnAllowed(segs[1], node) == false)
                { WMETB_Debug("skip because node red turn"); continue; }
                if (node.isTurnAllowedBySegDirections(segs[1], segs[0]) && segs[1].isTurnAllowed(segs[0], node) == false)
                { WMETB_Debug("skip because node red turn"); continue; }
                if (node.isTurnAllowedBySegDirections(segs[0], segs[0]) && segs[0].isTurnAllowed(segs[0], node) == true)
                { WMETB_Debug("skip because green u-turn"); continue; }
                if (node.isTurnAllowedBySegDirections(segs[1], segs[1]) && segs[1].isTurnAllowed(segs[1], node) == true)
                { WMETB_Debug("skip because green u-turn"); continue; }
                var fwd0 = (attr0.fromNodeID == nodeID); var fwd1 = (attr1.fromNodeID == nodeID); if (attr0.junctionID != null) { WMETB_Debug("skip because seg 0 is rdbt"); continue; }
                if (attr1.junctionID != null) { WMETB_Debug("skip because seg 1 is rdbt"); continue; }
                if (attr0.primaryStreetID != attr1.primaryStreetID) { WMETB_Debug("skip because segs have different primaryStreetID"); continue; }
                if (attr0.streetIDs.length || attr1.streetIDs.length) { if ((attr0.streetIDs[0] != attr1.streetIDs[0]) || (attr0.streetIDs[1] != attr1.streetIDs[1]) || (attr0.streetIDs[2] != attr1.streetIDs[2]) || (attr0.streetIDs.length != attr1.streetIDs.length)) { WMETB_Debug("skip because segs have different alt names"); continue; } }
                if (attr0.level != attr1.level) { WMETB_Debug("skip because segs have different levels"); continue; }
                if (attr0.roadType != attr1.roadType) { WMETB_Debug("skip because segs have different road type"); continue; }
                if (WMETB_isSegUnknown(segs[0]) || WMETB_isSegUnknown(segs[1])) { WMETB_Debug("skip because >=1 seg has unknown direction"); continue; }
                if (attr0.lockRank != attr1.lockRank) { WMETB_Debug("skip because segs have different lock ranks"); continue; }
                if (attr0.flags != attr1.flags) { WMETB_Debug("skip because segs have different flags"); continue; }
                if (attr0.fwdToll != attr1.fwdToll || attr1.revToll != attr0.revToll || attr1.fwdToll != attr0.revToll) { WMETB_Debug("skip because segs have different toll"); continue; }
                if ((attr0.length + attr1.length) > 99999) { WMETB_Debug("skip because resulting seg would be > 100km long"); continue; }
                if (WMETB_xor(fwd0, fwd1)) { if (attr0.fwdDirection != attr1.fwdDirection || attr1.revDirection != attr0.revDirection) { WMETB_Debug("skip because segs have different directions (AB connected)"); continue; } } else { if (attr0.fwdDirection != attr1.revDirection || attr0.revDirection != attr1.fwdDirection) { WMETB_Debug("skip because segs have different directions (AA or BB connected)"); continue; } }
                if ((attr0.fwdMaxSpeed != attr0.revMaxSpeed || attr1.fwdMaxSpeed != attr1.revMaxSpeed) || attr0.fwdMaxSpeed != attr1.fwdMaxSpeed) { WMETB_Debug("skip because segs have different max speeds"); continue; }
                if (attr0.fwdRestrictions.length != 0 || attr0.revRestrictions.length != 0 || attr1.fwdRestrictions.length != 0 || attr1.revRestrictions.length != 0) { WMETB_Debug("skip because seg(s) contain(s) time based restriction(s)"); continue; }
                var hasTBTurnRestriction = false; for (var obj in attr0.toRestrictions) { hasTBTurnRestriction = true; break; }
                for (obj in attr1.toRestrictions) { hasTBTurnRestriction = true; break; }
                if (hasTBTurnRestriction) { WMETB_Debug("skip because seg(s) contain(s) time based turn restriction(s)"); continue; }
                var nodeID2 = attr0.fromNodeID == nodeID ? attr0.toNodeID : attr0.fromNodeID; if (nodeID2 != null) { WMETB_Debug("nodeID2 is " + nodeID2); if (attr1.fromNodeID == nodeID2 || attr1.toNodeID == nodeID2) { { WMETB_Debug("skip because segs loop between nodeID and nodeID2"); continue; } } }
                var nodeID3 = attr1.fromNodeID == nodeID ? attr1.toNodeID : attr1.fromNodeID; WMETB_Debug("nodeID3 is " + nodeID3); if (nodeID3 != nodeID2) {
                    var node2 = Waze.model.nodes.objects[nodeID2]; if (typeof node2 !== "undefined") {
                        if (node2.state == "Delete") { WMETB_Debug("skip because delete status"); continue; }
                        var node3 = Waze.model.nodes.objects[nodeID3]; if (typeof node3 !== "undefined") {
                            if (node3.state == "Delete") { WMETB_Debug("skip because delete status"); continue; }
                            var segs = node3.attributes.segIDs.map(function (s) { return Waze.model.segments.objects[s]; }); if (typeof (segs[0]) !== "undefined" && typeof (segs[1]) !== "undefined") {
                                var mustskip = false; for (var i = 0; i < segs.length; i++) { WMETB_Debug("seg" + i + " is " + segs[i].getID()); var attr = segs[i].attributes; if (attr.fromNodeID == nodeID2 || attr.toNodeID == nodeID2) { WMETB_Debug("skip because seg" + i + " is also connected to nodeID2"); mustskip = true; } }
                                if (mustskip) { continue; }
                            }
                        }
                    }
                }
                WMETB_Debug("suppress junction of node " + nodeID); var segsAreOneway = (attr0.fwdDirection != attr0.revDirection); var isFwdFromNodeID2 = WMETB_xor(attr0.fromNodeID == nodeID2, attr0.revDirection); Waze.model.actionManager.add(new ModifyAllConnections(node, true)); Waze.model.actionManager.add(new MergeSegments(null, node)); if (segsAreOneway) { var segsID2 = Waze.model.nodes.objects[nodeID2].attributes.segIDs.map(function (s) { return Waze.model.segments.objects[s]; }); var attrID2i; for (var i = 0; i < segsID2.length; i++) { attrID2i = segsID2[i].attributes; if (attrID2i.fromNodeID == nodeID2 || attrID2i.toNodeID == nodeID2) { if (attrID2i.fromNodeID == nodeID3 || attrID2i.toNodeID == nodeID3) { var isFwdFromNewSegment = WMETB_xor(attrID2i.fromNodeID == nodeID2, attrID2i.revDirection); if (isFwdFromNodeID2 != isFwdFromNewSegment) { Waze.model.actionManager.add(new UpdateObject(segsID2[i], { fwdDirection: !attrID2i.fwdDirection, revDirection: !attrID2i.revDirection })); WMETB_Debug("compensated WME oneway node removal bug"); } } } } }
                somethingdone = true; count++; if (count >= 35) { WMETB_DispLog("Node removal limit of 35 reached, save to continue"); return; }
            }
            if (somethingdone) { WMETB_DispLog(count + " unneeded junction" + (count > 1 ? "s" : "") + " suppressed"); } else { WMETB_DispLog("No unneeded junctions to suppress"); }
            WMETB_Debug("Suppress unneeded junctions ended");
        }
    }; tc.push(1); var WMETB_fillTable = function (theTable, themap, cols, issel) {
        'use strict'; if (themap instanceof Array) {
            if (themap.length > 0) {
                var seg = themap[0]; var trs = $('<tr border="1px solid #eee" padding=".6em 10px" text-align="left">'); for (var j = 0; j < cols.length; j++) { var col = cols[j]; trs.append('<td>' + WMETB_getAttr(col, seg, issel) + '</td>'); }
                trs.append($('<td align="center">').append('<button style="width:50px">' + themap.length.toString() + '</button>').click(function () { Waze.selectionManager.select(themap); })); trs.append($('<td align="center">').append('<button style="width:50px">' + themap.length.toString() + '</button>').click(function () {
                    if (themap.length == 1) {
                        Waze.map.zoomToExtent(seg.geometry.getBounds()); var currentZoom = Waze.map.getZoom(); if (currentZoom >= 7) { Waze.map.zoomTo(6); }
                        Waze.selectionManager.select(themap);
                    }
                    else {
                        var initBounds = seg.geometry.getBounds(); var WMETB_maxBoundLeft = initBounds.left; var WMETB_maxBoundTop = initBounds.top; var WMETB_maxBoundRight = initBounds.right; var WMETB_maxBoundBottom = initBounds.bottom; for (i = 0; i < themap.length; i++) { var segBounds = themap[i].geometry.getBounds(); if (segBounds.left < WMETB_maxBoundLeft) { WMETB_maxBoundLeft = segBounds.left }; if (segBounds.top > WMETB_maxBoundTop) { WMETB_maxBoundTop = segBounds.top }; if (segBounds.right > WMETB_maxBoundRight) { WMETB_maxBoundRight = segBounds.right }; if (segBounds.bottom < WMETB_maxBoundBottom) { WMETB_maxBoundBottom = segBounds.bottom }; }
                        var WMETB_calcBounds = new OpenLayers.Bounds(); WMETB_calcBounds.left = WMETB_maxBoundLeft; WMETB_calcBounds.top = WMETB_maxBoundTop; WMETB_calcBounds.right = WMETB_maxBoundRight; WMETB_calcBounds.bottom = WMETB_maxBoundBottom; Waze.map.zoomToExtent(WMETB_calcBounds); var currentZoom = Waze.map.getZoom(); if (currentZoom >= 7) { Waze.map.zoomTo(6); }
                        setTimeout(function () { Waze.selectionManager.select(themap) }, 2000);
                    }
                })); trs.append('</td></tr>'); theTable.append(trs);
            }
        } else { for (var colIdx in themap) { WMETB_fillTable(theTable, themap[colIdx], cols, issel); } }
    }, WMETB_setStreet = function (streetArray) {
        'use strict'; if ((streetArray[0] != "") && (streetArray[1] != "")) { return streetArray.join(" - "); } else if (streetArray[0] != "") { return streetArray[0]; } else if (streetArray[1] != "") { return streetArray[1]; } else
            return "";
    }, WMETB_setAddress = function (attrs, newAttrs, seg) {
        'use strict'; var cntid, stID; if (attrs['countryID']) { cntid = attrs['countryID']; } else if (attrs['cityID']) { cntid = Waze.model.cities.get(attrs['cityID']).attributes.countryID; } else if ((attrs['City']) && (Waze.model.cities.getByAttributes({ name: attrs['City'] }).length > 0)) { cntid = Waze.model.cities.getByAttributes({ name: attrs['City'] })[0].attributes.countryID; } else if (WMETB_getAttr('countryID', seg, 1)) { cntid = WMETB_getAttr('countryID', seg, 1); } else { cntid = Waze.model.cities.get(Waze.model.segments.topCityID).attributes.countryID; }
        if (attrs['stateID']) { stID = attrs['stateID']; } else if (attrs['cityID']) { stID = Waze.model.cities.get(attrs['cityID']).attributes.stateID; } else if ((attrs['City']) && (Waze.model.cities.getByAttributes({ name: attrs['City'] }).length > 0)) { stID = Waze.model.cities.getByAttributes({ name: attrs['City'] })[0].attributes.stateID; } else if (WMETB_getAttr('stateID', seg, 1)) { stID = WMETB_getAttr('stateID', seg, 1); } else { stID = Waze.model.cities.get(Waze.model.segments.topCityID).attributes.stateID; }
        var ctname = attrs['City'] ? attrs['City'] : WMETB_getAttr('City', seg.model, 1); var emptyct = (ctname === ""); if (ctname == "::todel::") { ctname = ""; emptyct = true; }
        var fattr = { countryID: cntid, stateID: stID, isEmpty: emptyct }; if (!emptyct) { fattr.name = ctname; }
        var ct = Waze.model.cities.getByAttributes(fattr); if (ct.length === 1) { newAttrs['cityID'] = ct[0].getID(); } else if (ct.length === 0) { var f = new CreateObject(ObjectType.CITY, { countryID: cntid, stateID: stID, isEmpty: emptyct, name: ctname }); Waze.model.actionManager.add(f); newAttrs['cityID'] = f.newObject.getID(); WMETB_DispLog('Created new ' + (emptyct ? 'empty ' : '') + 'city object ' + attrs['City']); } else { WMETB_DispWarn('Multiple cities with same name on same country! please check'); return false; }
        var st = WMETB_getStreetNameElt(WMETB_getAttr('Street', seg, 1)); if (attrs['StreetId']) { st[0] = attrs['StreetId']; }
        if (attrs['StreetName']) { st[1] = attrs['StreetName']; }
        if ((attrs['StreetId']) || (attrs['StreetName'])) { newAttrs['Street'] = WMETB_setStreet(st); }
        return true;
    }, WMETB_getOrCreateStreet = function (newAttrs, seg) {
        'use strict'; var stname = newAttrs['Street'] ? newAttrs['Street'] : WMETB_getAttr('Street', seg); var emptyst = ((stname == null) || (stname == "")) ? true : false; if (stname == "::todel::") { stname = ""; emptyst = true; }
        var fattr = { cityID: newAttrs['cityID'], isEmpty: emptyst }; if (emptyst == false) { fattr.name = stname; }
        var st = Waze.model.streets.getByAttributes(fattr); if (st.length === 1) { st = st[0]; } else if (st.length === 0) { WMETB_DispLog('Info : Creating new street object...'); var a = new AddOrGetStreet(stname, Waze.model.cities.objects[newAttrs['cityID']], emptyst); Waze.model.actionManager.add(a); st = a.street; } else { WMETB_DispWarn('Multiple streets with same name on same city, please check'); return false; }
        newAttrs.primaryStreetID = st.getID(); return true;
    }, WMETB_setAttrs = function (attrs, segs) {
        'use strict'; segs.forEach(function (seg) {
            if (WMETB_limitForSaveReach()) { WMETB_DispWarn("Please save before continuing to edit"); return; }
            var oldAttrs = WMETB_getAddress(seg.model); var newAttrs = jQuery.extend(true, {}, attrs); if ((seg.model.isLockedByHigherRank() === false) && (seg.model.type == "segment") && (seg.model.arePropertiesEditable()) && (WMETB_setAddress(oldAttrs, newAttrs, seg.model) === true) && (WMETB_getOrCreateStreet(newAttrs, seg.model) === true)) {
                if (newAttrs.countryID == undefined) { newAttrs.countryID = oldAttrs.country.id; }
                if (newAttrs.stateID == undefined) { newAttrs.stateID = oldAttrs.state.id; }
                if (newAttrs.City) { newAttrs.cityName = newAttrs.City; } else { newAttrs.cityName = oldAttrs.city.name; }
                if (newAttrs.cityName == undefined || newAttrs.cityName == "::todel::") { newAttrs.emptyCity = true; }
                if (newAttrs.Street) { newAttrs.streetName = newAttrs.Street; } else { newAttrs.streetName = oldAttrs.street.name; }
                if (newAttrs.streetName == undefined || newAttrs.streetName == "::todel::") { newAttrs.emptyStreet = true; }
                if (newAttrs.countryID) { var action = new UpdateFeatureAddress(seg.model, newAttrs, { streetIDField: "primaryStreetID" }); Waze.model.actionManager.add(action); } else { WMETB_DispWarn("Any country must be set"); }
            }
        });
    }; var WMETB_dlgedt, WMETB_propertyDialog = Class.extend({
        init: function () { this.rows = ["Country", "State", "City", "Street"]; this.popup = $(createElement(document.body, 'DIV', 'WMETB_propertyDialog')).css('font-size', '70.5%'); this.plist = $('<div>'); this.popup.dialog({ autoOpen: false, show: "fast", width: 400, height: 285, dialogClass: "propedit", title: "Toolbox - Properties editor", buttons: { Cancel: function () { $(this).dialog("close"); }, Apply: function () { var attrs = {}; $.each($('input', this).filter(':checked'), function (id, val) { if (typeof ($('select[id=' + val.name + ']')[0]) !== "undefined") { if (val.name == "Country") attrs["countryID"] = $('select[id=' + val.name + ']')[0].value; if (val.name == "State") attrs["stateID"] = $('select[id=' + val.name + ']')[0].value; } else if (typeof ($('input[id=' + val.name + ']')[0]) !== "undefined") { if ((val.name == "City" || val.name == "Street") && $('input[id=' + val.name + ']')[0].value == "") { attrs[val.name] = "::todel::"; } else { attrs[val.name] = $('input[id=' + val.name + ']')[0].value; } } }); WMETB_setAttrs(attrs, Waze.selectionManager.selectedItems); } } }); this.popup.append(this.plist); $('div.propedit').attr('style', 'position: absolute; top: 0; left: 0; padding: .2em; width: 300px; overflow: hidden;background:rgba(255, 255, 255, ' + WMETB_ToSave.alpha / 100 + ')'); $('div.ui-dialog-titlebar', $('div.propedit')).append($('<span height="10px">').button({ icons: { primary: 'ui-icon-refresh' } }).attr('title', 'Refresh properties').attr('style', 'position:absolute;right:50px;').click(function (e) { WMETB_refreshEdit(); })); $('div.ui-dialog-buttonpane').attr('style', 'height:25px;font-size:8px;line-height: 10px').last().append($('<div>').slider({ value: WMETB_ToSave.alpha, change: function (event, ui) { $('div.propedit').css('background', 'rgba(255, 255, 255,' + ui.value / 100 + ')'); WMETB_ToSave.alpha = ui.value; } }).attr('style', 'float:left;margin-top: 10px;width:50%')); }, refresh: function () {
            var cols = ["Edit", "Attribute", "Value"]; var available = []; available['Country'] = WMETB_mapObj(Waze.model.countries.objects, "name"); available['countryID'] = WMETB_mapObj(Waze.model.countries.objects, "id"); available['State'] = WMETB_mapObj(Waze.model.states.objects, "name"); available['stateID'] = WMETB_mapObj(Waze.model.states.objects, "id"); available['Street'] = WMETB_mapObj(Waze.model.streets.objects, "name"); available['City'] = WMETB_mapObj(Waze.model.cities.objects, "name"); var rows = this.rows; this.plist.empty(); var myTable = $('<table id="seg-list" border="1px solid #eee" margin="1em 0" padding=".6em 10px" border-collapse="collapse" width="100%" text-align="left">'); var myHead = $('<thead>'); var myRow = $('<tr class="ui-widget-header">'); $.each(cols, function (index, value) { myRow.append('<td>' + value); }); myHead.append(myRow); var myBody = $('<tbody>'); var attrs = {}; var segaddress = {}; Waze.selectionManager.selectedItems.forEach(function (seg) { if (seg.model.type == "segment") { $.each(rows, function (index, value) { var attr = WMETB_getAttr(value, seg, 1); attrs[value] = (value in attrs && attrs[value] != attr) ? "Multiple" : attr; segaddress[index] = WMETB_getAddress(seg.model); }); } }); $.each(rows, function (index, value) {
                var tr = $('<tr>'); if (value == "Country") { var inp = '<select class="chk' + value + '" id=' + value + ' enabled>'; $.each(available['Country'], function (index2, value2) { inp += '<option '; if (typeof (segaddress[index].country) !== "undefined" && available['countryID'][index2] == segaddress[index].country.id) inp += 'selected '; inp += 'value="' + available['countryID'][index2] + '" style="width:99%">' + value2 + '</option>'; }); inp += '</select>'; } else if (value == "State") { if (available['State'].length > 0 && available['stateID'][0] != 1) { var inp = '<select class="chk' + value + '" id=' + value + ' disabled>'; $.each(available['State'], function (index2, value2) { inp += '<option '; if (available['stateID'][index2] == segaddress[index].state.id) inp += 'selected '; inp += 'value="' + available['stateID'][index2] + '" style="width:99%">' + value2 + '</option>'; }); inp += '</select>'; } else { var inp = 'Not available in this country'; } } else { var inp = $('<input class="chk' + value + '" id=' + value + ' value="' + attrs[value] + '" style="width:99%"></input>').prop('disabled', true).autocomplete({ source: available[value] }); }
                var chk = $('<input name="' + value + '" type="checkbox"></input>').change(function () { $('.chk' + value).prop('disabled', !$(this).is(':checked')); }); $('<td width="10px">').append(chk).appendTo(tr); tr.append('<td width="70px">' + value + '</td>'); $('<td>').append(inp).appendTo(tr); myBody.append(tr);
            }); myTable.append(myHead); myTable.append(myBody); this.plist.append(myTable);
        }
    }), WMETB_refreshEdit = function () { 'use strict'; WMETB_dlgedt.refresh(); }, WMETB_PropertiesEditor = function () {
        'use strict'; if (Enable_WMETB_PropertiesEditor && sec.WMETB_RightsCheck("PropEd")) {
            if (typeof (WMETB_dlgedt) === 'undefined') { WMETB_dlgedt = new WMETB_propertyDialog(); }
            if (Waze.selectionManager.selectedItems.length == 0) { WMETB_DispWarn("No segment selected"); } else { WMETB_dlgedt.refresh(); WMETB_dlgedt.popup.dialog("open"); }
        } else { WMETB_DispWarn("No segment selected"); }
    }; tb.push(2); var WMETB_dlgcsa, WMETB_CopySegmentAttributesDialog = Class.extend({ init: function () { this.popup = $(createElement(document.body, 'DIV', 'WMETB_CopySegmentAttributesDialog')).css('font-size', '70.5%'); this.plist = $('<div>'); var setoptions = this.setoptions; this.popup.dialog({ autoOpen: false, show: "fast", width: 400, height: 400, dialogClass: "csaedit", title: "Toolbox - Copy segment attributes", buttons: { Cancel: function () { setoptions(this); $(this).dialog("close"); }, "Copy attributes": function () { setoptions(this); WMETB_csaCopy(); $(this).dialog("close"); } } }); this.popup.append(this.plist); var option = $('<input type="radio" name="copyFromSegment" id="CSA_cbCopyFromFirstSegment" value="first"' + (WMETB_ToSave.csaOptions.copyFromSegment == 'first' ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyFromFirstSegment" style="display:initial;min-height:20px;">Copy from first selected segment</label><br>' + '<input type="radio" name="copyFromSegment" id="CSA_cbCopyFromLastSegment" value="last"' + (WMETB_ToSave.csaOptions.copyFromSegment == 'last' ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyFromLastSegment" style="display:initial;min-height:20px;">Copy from the last selected segment</label><br>' + '<hr style="margin: 5px 0;">' + '<input type="checkbox" id="CSA_cbCountryID" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCountryID ? ' checked="checked"' : '') + '> <label for="CSA_cbCountryID" style="display:initial;min-height:20px;">Country / State</label><br>' + '<input type="checkbox" id="CSA_cbCityName" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCityName ? ' checked="checked"' : '') + '> <label for="CSA_cbCityName" style="display:initial;min-height:20px;">City</label><br>' + '<input type="checkbox" id="CSA_cbStreetName" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbStreetName ? ' checked="checked"' : '') + '> <label for="CSA_cbStreetName" style="display:initial;min-height:20px;">Street</label><br>' + '<hr style="margin: 5px 0;">' + '<input type="checkbox" id="CSA_cbCopyRoadType" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyRoadType ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyRoadType" style="display:initial;min-height:20px;">Road type</label><br>' + '<input type="checkbox" id="CSA_cbCopyMaxSpeed" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyMaxSpeed ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyMaxSpeed" style="display:initial;min-height:20px;">Max. Speed</label><br>' + '<input type="checkbox" id="CSA_cbCopyFlags" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyFlags ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyFlags" style="display:initial;min-height:20px;">Flags (tunnel, ..)</label><br>' + '<input type="checkbox" id="CSA_cbCopyLevel" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyLevel ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyLevel" style="display:initial;min-height:20px;">Elevation</label><br>' + '<input type="checkbox" id="CSA_cbCopyLock" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyLock ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyLock" style="display:initial;min-height:20px;">Lock</label><br>' + '<input type="checkbox" id="CSA_cbCopyDirection" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyDirection ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyDirection" style="display:initial;min-height:20px;">Direction</label><br>' + '<input type="checkbox" id="CSA_cbCopyTollRoad" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbCopyTollRoad ? ' checked="checked"' : '') + '> <label for="CSA_cbCopyTollRoad" style="display:initial;min-height:20px;">Toll Road</label><br>' + '<hr style="margin: 5px 0;">' + '<input type="checkbox" id="CSA_cbdeleteAltStreet" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbdeleteAltStreet ? ' checked="checked"' : '') + '> <label for="CSA_cbdeleteAltStreet" style="display:initial;min-height:20px;">Delete existing alternate street name</label><br>' + '<input type="checkbox" id="CSA_cbcopyAltStreet" value="1"' + (WMETB_ToSave.csaOptions.CSA_cbcopyAltStreet ? ' checked="checked"' : '') + '> <label for="CSA_cbcopyAltStreet" style="display:initial;min-height:20px;">Copy alternate street name</label><br>'); this.popup.append(option); $('div.csaedit').attr('style', 'position: absolute; top: 0; left: 0; padding: .2em; width: 300px; overflow: hidden;background:rgba(255, 255, 255, ' + WMETB_ToSave.alpha / 100 + ')'); $('div.ui-dialog-buttonpane').attr('style', 'height:25px;font-size:8px;line-height: 10px').last().append($('<div>').slider({ value: WMETB_ToSave.alpha, change: function (event, ui) { $('div.csaedit').css('background', 'rgba(255, 255, 255,' + ui.value / 100 + ')'); WMETB_ToSave.alpha = ui.value; } }).attr('style', 'float:left;margin-top: 10px;width:50%')); }, setoptions: function (that) { $.each($('input', that), function (id, val) { if (val.name == "copyFromSegment") { if (val.id == "CSA_cbCopyFromFirstSegment" && val.checked) { WMETB_ToSave.csaOptions.copyFromSegment = "first"; } else if (val.id == "CSA_cbCopyFromLastSegment" && val.checked) { WMETB_ToSave.csaOptions.copyFromSegment = "last"; } } else if (typeof ($('input[id=' + val.id + ']')[0]) !== "undefined") { WMETB_ToSave.csaOptions[val.id] = val.checked; } }); } }), WMETB_CopySegmentAttributes = function () {
        if (Enable_WMETB_CopySegmentAttributes && sec.WMETB_RightsCheck("CSA")) {
            if (typeof (WMETB_dlgcsa) === 'undefined') { WMETB_dlgcsa = new WMETB_CopySegmentAttributesDialog(); }
            if (Waze.selectionManager.selectedItems.length == 0) { WMETB_DispWarn("No segment selected"); } else if (WMETB_limitForSaveReach()) { WMETB_DispWarn("Please save before continuing to edit"); return true; } else { WMETB_dlgcsa.popup.dialog("open"); }
        } else { WMETB_DispWarn("At least 2 segments must be selected"); }
    }, WMETB_csaCopy = function () {
        var selsegments = null; var seg = null; var bOK = true; var csaSource = { "segment": null, "street": null, "city": null, "altCities": [] }; var csaTarget = { "segment": null, "street": null, "city": null, "altCities": [] }; var csaTargetAddress = {}; var targetAttributesToCopy = []; var csaTargetDetails = {}; var targetDetailsToCopy = []; var csaANOptions = { "copySourceAN": true, "deleteTargetAN": true }; var i = 0; var x = 0; var y = 0; var from = 0; if (Waze.selectionManager.selectedItems.length < 2) { WMETB_DispWarn('At least 2 segments must be selected'); return false; } else { for (i = 0; i < Waze.selectionManager.selectedItems.length; i++) { if (Waze.selectionManager.selectedItems[i].model.type != "segment") { WMETB_DispWarn("You must select only segments"); return false; } } }
        selsegments = Waze.selectionManager.selectedItems; WMETB_csaReadParams(targetAttributesToCopy, targetDetailsToCopy, csaANOptions); if (WMETB_ToSave.csaOptions.copyFromSegment == "first") { from = 0; } else if (WMETB_ToSave.csaOptions.copyFromSegment == "last") { from = selsegments.length - 1; }
        for (i = 0; i < Waze.selectionManager.selectedItems.length; i++) { if (i == from) continue; if (!Waze.selectionManager.selectedItems[i].model.arePropertiesEditable()) { WMETB_DispWarn("You're not allowed to edit at least one of these segments"); return false; } }
        seg = Waze.selectionManager.selectedItems[from]; csaTargetDetails = {}; csaSource = WMETB_wmeGetSegmentInfo(seg); if (WMETB_ToSave.csaOptions.CSA_cbCopyMaxSpeed) {
            if (csaSource['segment'].model.attributes.fwdMaxSpeedUnverified || (csaSource['segment'].model.attributes.fwdMaxSpeed !== csaSource['segment'].model.attributes.revMaxSpeed)) { targetDetailsToCopy.splice(targetDetailsToCopy.indexOf("fwdMaxSpeedUnverified"), 1); targetDetailsToCopy.splice(targetDetailsToCopy.indexOf("fwdMaxSpeed"), 1); }
            if (csaSource['segment'].model.attributes.revMaxSpeedUnverified || (csaSource['segment'].model.attributes.fwdMaxSpeed !== csaSource['segment'].model.attributes.revMaxSpeed)) { targetDetailsToCopy.splice(targetDetailsToCopy.indexOf("revMaxSpeedUnverified"), 1); targetDetailsToCopy.splice(targetDetailsToCopy.indexOf("revMaxSpeed"), 1); }
        }
        for (x = 0; x < targetDetailsToCopy.length; x++) { csaTargetDetails[targetDetailsToCopy[x]] = csaSource['segment'].model.attributes[targetDetailsToCopy[x]]; }
        for (i = 0; i < selsegments.length; i++) {
            seg = Waze.selectionManager.selectedItems[i]; if (i != from) {
                if (!seg.model.attributes.locked || (seg.model.attributes.locked && seg.model.attributes.lockRank <= loginManager.user.rank && seg.attributes.rank <= loginManager.user.rank)) {
                    csaTarget = WMETB_wmeGetSegmentInfo(seg); csaTargetAddress = WMETB_csaGetPrimaryAddress(WMETB_wmeGetSegmentInfo(seg), targetAttributesToCopy, csaSource); if (csaTargetAddress.countryID == undefined) { WMETB_DispWarn("Adress of segment " + seg.model.attributes.id + " is not set (no country)"); continue; }
                    Waze.model.actionManager.add(new UpdateFeatureAddress(seg.model, csaTargetAddress, { streetIDField: "primaryStreetID" })); while (csaANOptions["deleteTargetAN"] && seg.model.attributes.streetIDs.length) { Waze.model.actionManager.add(new UpdateObject(seg.model, { streetIDs: seg.model.attributes.streetIDs.remove(seg.model.attributes.streetIDs[0]) })); }
                    for (x = 0; csaANOptions["copySourceAN"] && x < csaSource['segment'].model.attributes.streetIDs.length; x++) { var street = Waze.model.streets.get(csaSource['segment'].model.attributes.streetIDs[x]); var city = csaSource['altCities'][x]; Waze.model.actionManager.add(new AddAlternateStreet(seg.model, { streetName: street.name, cityName: city.name, emptyCity: city.isEmpty })); }
                    Waze.model.actionManager.add(new UpdateObject(seg.model, csaTargetDetails));
                }
            }
        }
    }, WMETB_csaReadParams = function (targetAttributesToCopy, targetDetailsToCopy, csaANOptions) {
        if (WMETB_ToSave.csaOptions.CSA_cbCountryID) { targetAttributesToCopy.push('countryID'); targetAttributesToCopy.push('stateID'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCityName) { targetAttributesToCopy.push('cityName'); }
        if (WMETB_ToSave.csaOptions.CSA_cbStreetName) { targetAttributesToCopy.push('streetName'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyRoadType) { targetDetailsToCopy.push('roadType'); targetDetailsToCopy.push('routingRoadType'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyMaxSpeed) { targetDetailsToCopy.push('fwdMaxSpeed'); targetDetailsToCopy.push('fwdMaxSpeedUnverified'); targetDetailsToCopy.push('revMaxSpeed'); targetDetailsToCopy.push('revMaxSpeedUnverified'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyFlags) { targetDetailsToCopy.push('flags'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyLevel) { targetDetailsToCopy.push('level'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyLock) { targetDetailsToCopy.push('locked'); targetDetailsToCopy.push('lockRank'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyDirection) { targetDetailsToCopy.push('fwdDirection'); targetDetailsToCopy.push('revDirection'); }
        if (WMETB_ToSave.csaOptions.CSA_cbCopyTollRoad) { targetDetailsToCopy.push('fwdToll'); targetDetailsToCopy.push('revToll'); }
        if (!WMETB_ToSave.csaOptions.CSA_cbcopyAltStreet) { csaANOptions["copySourceAN"] = false; }
        if (!WMETB_ToSave.csaOptions.CSA_cbdeleteAltStreet) { csaANOptions["deleteTargetAN"] = false; }
    }, WMETB_wmeGetSegmentInfo = function (seg) {
        var oSeg = { "segment": null, "street": null, "city": null, "altCities": [] }; var altstreet = null; oSeg['segment'] = seg; oSeg['street'] = seg.model.getAddress().street; if (oSeg['street'] == undefined) { oSeg['city'] = undefined; } else { oSeg['city'] = Waze.model.cities.get(oSeg['street'].cityID).attributes; }
        for (x = 0; x < seg.model.attributes.streetIDs.length; x++) { if (Waze.model.streets.get(seg.model.attributes.streetIDs[x])) { altstreet = Waze.model.streets.get(seg.model.attributes.streetIDs[x]); oSeg['altCities'][x] = Waze.model.cities.get(altstreet.cityID).attributes; } }
        return oSeg;
    }
    WMETB_csaGetPrimaryAddress = function (csaTarget, targetAttributesToCopy, csaSource) {
        if (csaTarget['street'] == undefined) { csaTargetAddress = { countryID: undefined, stateID: undefined, streetName: undefined, cityName: undefined, emptyCity: true, emptyStreet: true }; } else { csaTargetAddress = { countryID: csaTarget['city'].countryID, stateID: csaTarget['city'].stateID, streetName: csaTarget['street'].name, cityName: csaTarget['city'].name, emptyCity: csaTarget['city'].isEmpty, emptyStreet: csaTarget['street'].isEmpty }; }
        for (x = 0; x < targetAttributesToCopy.length; x++) { switch (targetAttributesToCopy[x]) { case 'cityName': csaTargetAddress[targetAttributesToCopy[x]] = csaSource['city']['name']; csaTargetAddress['emptyCity'] = csaSource['city']['isEmpty']; break; case 'streetName': csaTargetAddress[targetAttributesToCopy[x]] = csaSource['street']['name']; csaTargetAddress['emptyStreet'] = csaSource['street']['isEmpty']; break; default: csaTargetAddress[targetAttributesToCopy[x]] = csaSource['city'][targetAttributesToCopy[x]]; break; } }
        return csaTargetAddress;
    }; tb.push(15); var WMETB_DeletePastRestrictions = function () {
        if (sec.WMETB_RightsCheck("FixExpRest")) {
            if (Waze.map.zoom <= 3) { WMETB_DispWarn('Inappropriate zoom level: ' + Waze.map.getZoom().toString()); WMETB_DispWarn("You must increase your zoom level to perform this action"); return true; }
            if (WMETB_limitForSaveReach()) { WMETB_DispWarn("Please save before continuing to edit"); return true; }
            var somethingdone = false; var countSeg = 0; var countTurn = 0; var DateNow = Date.now(); for (var segID in Waze.model.segments.objects) {
                var seg = Waze.model.segments.get(segID); var attributes = seg.attributes; var line = WMETB_getId(seg.geometry.id); if (seg.arePropertiesEditable() && line !== null) {
                    var newfwdRestrictions = new Array(), newrevRestrictions = new Array(); var mustupdate = false; for (var rest = 0; rest < attributes.fwdRestrictions.length; rest++) {
                        if (typeof attributes.fwdRestrictions[rest] !== 'undefined') {
                            if (attributes.fwdRestrictions[rest]._toDate === null) { newfwdRestrictions.push(attributes.fwdRestrictions[rest]); } else {
                                if (attributes.fwdRestrictions[rest]._toTime !== null) { var t = Date.parse(attributes.fwdRestrictions[rest]._toDate + " " + attributes.fwdRestrictions[rest]._toTime); } else { var t = Date.parse(attributes.fwdRestrictions[rest]._toDate + " 23:59:59"); }
                                if (t > DateNow) { newfwdRestrictions.push(attributes.fwdRestrictions[rest]); } else { mustupdate = true; countSeg++; }
                            }
                        }
                    }
                    for (var rest = 0; rest < attributes.revRestrictions.length; rest++) {
                        if (typeof attributes.revRestrictions[rest] !== 'undefined') {
                            if (attributes.revRestrictions[rest]._toDate === null) { newrevRestrictions.push(attributes.revRestrictions[rest]); } else {
                                if (attributes.revRestrictions[rest]._toTime !== null) { var t = Date.parse(attributes.revRestrictions[rest]._toDate + " " + attributes.revRestrictions[rest]._toTime); } else { var t = Date.parse(attributes.revRestrictions[rest]._toDate + " 23:59:59"); }
                                if (t > DateNow) { newrevRestrictions.push(attributes.revRestrictions[rest]); } else { mustupdate = true; countSeg++; }
                            }
                        }
                    }
                    if (mustupdate) { Waze.model.actionManager.add(new UpdateObject(seg, { fwdRestrictions: newfwdRestrictions || [], revRestrictions: newrevRestrictions || [] })); somethingdone = true; }
                    ["from", "to"].forEach(function (dir) {
                        seg.getConnectedSegmentsByDirection(dir).forEach(function (seg2) {
                            var node = seg.getNodeByDirection(dir); var turn = Waze.model.getTurnGraph().getTurnThroughNode(node, seg, seg2); var newRestr = []; var mustupdate = false; turn._turnData._restrictions.forEach(function (restr) { if (restr._toDate === null) { newRestr.push(restr); } else { if (Date.parse(restr._toDate + " " + restr._toTime) < DateNow) { mustupdate = true; countTurn++; } else { newRestr.push(restr); } } })
                            if (mustupdate) { Waze.model.actionManager.add(new SetTurn(Waze.model.getTurnGraph(), turn.withTurnData(turn.getTurnData().withRestrictions(newRestr)))); somethingdone = true; }
                        })
                    })
                }
            }
            if (somethingdone) { WMETB_DispLog(countSeg + " segment and " + countTurn + " turn restriction(s) deleted"); } else { WMETB_DispLog("No expired restriction to delete"); }
            return true;
        }
    }; tc.push(0); function WMETB_createSelectListsSegment() { if (sec.WMETB_RightsCheck("SegLi")) { WMETB_createSelectLists('segment'); } }
    function WMETB_createSelectListsVenue() {
        if (sec.WMETB_RightsCheck("PlaLi")) {
            if (Waze.map.landmarkLayer.visibility == false) { Waze.map.landmarkLayer.setVisibility(true); Waze.map.placeUpdatesLayer.setVisibility(true); WMETB_DispWarn('Place layer is disabled.  Enabling Places and Place Updates...'); setTimeout(function () { WMETB_createSelectLists('venue'); }, 2000); }
            else { WMETB_createSelectLists('venue'); }
        }
    }
    function WMETB_createSelectLists(type) {
        var dialogType = type; var dialogID = dialogType + '-dialog'; switch (type) {
            case 'venue': $('.segment-dialog').remove(); $('.waze-header').css('zIndex', 99); if ($('.venue-dialog')[0] == null) { WMETB_VenueSelectDialog = new WMETB_baseSelectDialog(dialogType, dialogID); WMETB_VenueSelectDialog.opts.accordion({ active: false }); }
                WMETB_VenueSelectDialog.refresh($.map(Waze.model.venues.objects, function (e, f) { return e; }), 0, dialogType); WMETB_VenueSelectDialog.popup.dialog("open"); WMETB_VenueSelectDialog.popup.dialog({ resizeStop: function (event, ui) { WMETB_ToSave.SelectVenueStyle.Position = ui.position; WMETB_ToSave.SelectVenueStyle.Height = ui.size.height; WMETB_ToSave.SelectVenueStyle.Width = ui.size.width; WMETB_Save_All(); }, dragStop: function (event, ui) { WMETB_ToSave.SelectVenueStyle.Position = ui.position; WMETB_Save_All(); } }); if (WMETB_ToSave.SelectVenueStyle.Position.left + ($('.WMETB_venue').width() / 2) > $(window).width()) { WMETB_DispWarn("Place List off screen! Resetting horizontal position."); $('.WMETB_venue').css({ 'left': 350 }); }
                else { $('.WMETB_venue').css({ 'left': WMETB_ToSave.SelectVenueStyle.Position.left }); }
                if (WMETB_ToSave.SelectVenueStyle.Position.top + ($('.WMETB_venue').height() / 2) > $(window).height()) { WMETB_DispWarn("Place List off screen! Resetting vertical position."); $('.WMETB_venue').css({ 'top': 200 }); }
                else { $('.WMETB_venue').css({ 'top': WMETB_ToSave.SelectVenueStyle.Position.top }); }
                $('.WMETB_venue').css({ 'height': WMETB_ToSave.SelectVenueStyle.Height, 'width': WMETB_ToSave.SelectVenueStyle.Width }); $('.venue-dialog').css({ 'height': $('.WMETB_venue').height() - 80 }); break; case 'segment': $('.venue-dialog').remove(); $('.waze-header').css('zIndex', 99); if ($('.segment-dialog')[0] == null) { WMETB_SegmentSelectDialog = new WMETB_baseSelectDialog(dialogType, dialogID); WMETB_SegmentSelectDialog.opts.accordion({ active: false }); }
                    WMETB_SegmentSelectDialog.refresh($.map(Waze.model.segments.objects, function (e, f) { return e; }), 0, dialogType); WMETB_SegmentSelectDialog.popup.dialog("open"); WMETB_SegmentSelectDialog.popup.dialog({ resizeStop: function (event, ui) { WMETB_ToSave.SelectSegmentStyle.Position = ui.position; WMETB_ToSave.SelectSegmentStyle.Height = ui.size.height; WMETB_ToSave.SelectSegmentStyle.Width = ui.size.width; WMETB_Save_All(); }, dragStop: function (event, ui) { WMETB_ToSave.SelectSegmentStyle.Position = ui.position; WMETB_Save_All(); } }); if (WMETB_ToSave.SelectSegmentStyle.Position.left + ($('.WMETB_segment').width() / 2) > $(window).width()) { WMETB_DispWarn("Segment List off screen! Resetting horizontal position."); $('.WMETB_segment').css({ 'left': 350 }); }
                    else { $('.WMETB_segment').css({ 'left': WMETB_ToSave.SelectSegmentStyle.Position.left }); }
                    if (WMETB_ToSave.SelectSegmentStyle.Position.top + ($('.WMETB_segment').height() / 2) > $(window).height()) { WMETB_DispWarn("Segment List off screen! Resetting vertical position."); $('.WMETB_segment').css({ 'top': 200 }); }
                    else { $('.WMETB_segment').css({ 'top': WMETB_ToSave.SelectSegmentStyle.Position.top }); }
                    $('.WMETB_segment').css({ 'height': WMETB_ToSave.SelectSegmentStyle.Height, 'width': WMETB_ToSave.SelectSegmentStyle.Width }); $('.segment-dialog').css({ 'height': $('.WMETB_segment').height() - 80 }); break;
        }
    }
    function WMETB_listPossibleColumns(columnSelectionType) {
        var colList = []; switch (columnSelectionType) { case 'segment': colList = ['Country', 'Lock Level', 'Lock > Traffic Lock', 'Road Type', 'Nb Ways', 'State', 'No Lock (auto)', 'Lock < Traffic Lock', 'Created By', 'Roundabout', 'City', 'Lock = Traffic Lock', 'Length (meters)', 'Updated By', 'SegmentID', 'Street', 'Toll', 'Elevation', 'In Screen', 'Editable', 'Speed Limit AB', 'Speed Limit BA', 'In Selected Area Place', 'Closure', 'TBR', 'StreetAlt']; break; case 'venue': colList = ['Primary Category', 'Brand', 'Image Count', 'State', 'House Number', 'Place Type', 'Lock Level', 'Image Preview', 'City', 'Created By', 'Place Name', 'Place Approved', 'Country', 'Street', 'Updated By', 'Public', 'Pending Updates', 'Editable']; break; default: colList = []; }
        return colList;
    }
    WMETB_baseSelectDialog = Class.extend({
        init: function (dialogType, dialogID) {
            var colSelectList = WMETB_listPossibleColumns(dialogType); var classDialogType = 'WMETB_' + dialogType; var divDialogType = 'div.' + classDialogType; var listTableID = dialogType + '-list'; var divContainerID = dialogType + '-contain'; var dialogSaveOptions = ''; var dialogTitle = ''; switch (dialogType) { case 'venue': dialogSaveOptions = 'SelectVenue'; dialogTitle = 'Toolbox - Place List'; break; case 'segment': dialogSaveOptions = 'SelectSegment'; dialogTitle = 'Toolbox - Segment List'; break; }
            this.popup = $(createElement(document.body, 'div', dialogID)).css('font-size', '70.5%'); this.opts = $('<div style="max-height:150px;overflow:auto;"><h5>Columns</h5>').accordion({ collapsible: true }).attr('title', 'Select columns to display'); var container = $('<div id="' + divContainerID + '" style="display:table">'); var col = []; col[0] = $('<div style="display:table-cell;width:20%">'); col[1] = $('<div style="display:table-cell;width:20%">'); col[2] = $('<div style="display:table-cell;width:20%">'); col[3] = $('<div style="display:table-cell;width:20%">'); col[4] = $('<div style="display:table-cell;width:20%">'); for (var i = 0; i < colSelectList.length;) {
                for (var j = 0; j < col.length; j += 1) {
                    if (i < colSelectList.length) { var chk = $('<input type="checkbox" name="options[]" value="' + colSelectList[i] + '"/>').attr('checked', $.inArray(colSelectList[i], WMETB_ToSave[dialogSaveOptions]) >= 0); col[j].append($('<label style="font-size: 1em;margin-bottom: 5px;line-height: 3px;"/>').append(chk).append(colSelectList[i])); col[j].append($('<br>')); }
                    i += 1;
                }
            }
            container.append(col); this.opts.append(container); this.slist = $('<div>'); this.columns = WMETB_ToSave[dialogSaveOptions]; this.popup.append(this.tb); this.popup.append(this.opts); this.popup.append(this.slist); this.popup.dialog({ title: dialogTitle, autoOpen: false, maxHeight: $('#map').height(), dialogClass: classDialogType, maxWidth: $('#map').width(), width: 700, modal: false, buttons: { Close: function () { $(this).dialog("close"); } }, close: function () { WMETB_ToSave[dialogSaveOptions].length = 0; $("input[name='options[]']:checked").each(function (i) { WMETB_ToSave[dialogSaveOptions].push(this.value); }); } }); $(divDialogType).attr('style', 'position: absolute; top: 300px; left: 300px; padding: .2em; width: 300px; overflow: hidden;background:rgba(255, 255, 255, ' + WMETB_ToSave.alpha / 100 + ')'); $('div.ui-dialog-titlebar', $(divDialogType)).append($('<span height="10px">').button({ icons: { primary: 'ui-icon-refresh' } }).attr('title', 'Refresh whole ' + dialogType + ' list in the map').attr('style', 'position:absolute;right:100px;').click(function (e) {
                if (dialogType == 'segment') { WMETB_SegmentSelectDialog.refresh($.map(Waze.model.segments.objects, function (e, f) { return e; }), 0, dialogType); }
                else if (dialogType == 'venue') { WMETB_VenueSelectDialog.refresh($.map(Waze.model.venues.objects, function (e, f) { return e; }), 0, dialogType); }
            })).append($('<span height="10px">').button({ icons: { primary: 'ui-icon-calculator' } }).attr('title', 'Refresh selected ' + dialogType + ' list').attr('style', 'position:absolute;right:50px;').click(function (e) {
                if (dialogType == 'segment') { WMETB_SegmentSelectDialog.refresh(Waze.selectionManager.selectedItems, 1, dialogType); }
                else if (dialogType == 'venue') { WMETB_VenueSelectDialog.refresh(Waze.selectionManager.selectedItems, 1, dialogType); }
            })); $('div.ui-dialog-buttonpane').attr('style', 'height:30px;font-size:10px;line-height: 12px').last().append($('<div>').slider({ value: WMETB_ToSave.alpha, change: function (event, ui) { $(divDialogType).css('background', 'rgba(255, 255, 255,' + ui.value / 100 + ')'); WMETB_ToSave.alpha = ui.value; $('#selection-object-list').find('tbody').children().attr('style', 'background:rgba(255,255,255,' + WMETB_ToSave.alpha / 100 + ')'); } }).attr('style', 'float:left;margin-top: 10px;width:50%').attr('title', 'Adjust background transparency'));
        }, add_ToolBt: function (label, callback) { this.tb.append($('<div>').append(label).button().click(function (e) { if (callback && typeof (callback) === "function") { callback(); } })); }, refresh: function (objectArray, issel, dialogType) {
            this.columns.length = 0; var cols = this.columns; $.each($("input[name='options[]']:checked"), function () { cols.push(this.value); }); this.slist.empty(); if (Waze.map.getZoom() <= 1 && dialogType == 'segment') { WMETB_DispWarn('Inappropriate zoom level: ' + Waze.map.getZoom().toString()); WMETB_DispWarn("You must increase your zoom level to perform this action"); return; }
            if (ToolboxPending) { WMETB_DispWarn("Waze Map is refreshing, please wait"); return; }
            var myTable = $('<table id="selection-object-list" border="1px solid #eee" margin="1em 0" padding="6em 10px" border-collapse="collapse" width="100%" text-align="left">'); var myHead = $('<thead>'); var myRow = $('<tr class="ui-widget-header" border="1px solid #eee" padding=".6em 10px" text-align="left">'); $.each(cols, function (index, value) { myRow.append('<th>' + value); }); myRow.append('<th width="50px" align="center">Select'); myRow.append('<th width="50px" align="center">Select + Zoom'); myHead.append(myRow); var myBody = $('<tbody>'); if (dialogType == 'segment') { var mymap = WMETB_mapModelGeneric(cols, objectArray, issel); WMETB_fillTable(myBody, mymap, cols, issel); }
            else if (dialogType == 'venue') { var mymap = WMETB_mapModelGeneric(cols, objectArray, issel); WMETB_fillTable(myBody, mymap, cols, issel); }
            myTable.append(myHead); myTable.append(myBody); this.slist.append(myTable); window.ts_makeSortable(myTable[0]);
        }
    })
    WMETB_mapModelGeneric = function (columns, objArray, issel) {
        'use strict'; var map = new Object(); for (var i = 0; i < objArray.length; i++) {
            var sel = objArray[i]; if (sel.type == "segment" || sel.model.type == "segment" || sel.type == "venue" || sel.model.type == "venue") {
                var maplvl = map; if (issel) { var seg = sel.model; } else { var seg = sel; }
                for (var j = 0, len = columns.length; j < len; j++) {
                    var key = WMETB_getAttr(columns[j], seg, issel); var m = maplvl[key]; if (m == null) { m = {}; maplvl[key] = m; }
                    maplvl = m;
                }
                var lSt = maplvl[null]; if (lSt == null) { lSt = new Array(); maplvl[null] = lSt; }
                lSt.push(seg);
            }
        }
        return map;
    }
    tb.push(17); function WMETB_ForumInboxCheck() {
        var forumCheckDurationMS = forumCheckDuration * 60000; var d = new Date(); var currentTime = d.getTime(); var previousCheckCount = 0; if (typeof WMETB_LastForumCheck != 'undefined') { previousCheckCount = previousCheckCount + 1; }
        if (forumCheckDuration == 0) { console.log('WMETB: Forum Inbox recurring check disabled'); }
        else if (typeof WMETB_LastForumCheck == 'undefined' || (currentTime - WMETB_LastForumCheck) > forumCheckDurationMS) {
            var WMETB_forumInbox = $.get('https://www.waze.com/forum/ucp.php?i=pm&folder=inbox', function (WMETB_forumInboxCheckResult) {
                var WMETB_availablePMText = 'Inbox ('; if (WMETB_forumInboxCheckResult.indexOf(WMETB_availablePMText) != -1) { WMETB_DispWarn('You have an unread <a href="https://www.waze.com/forum/ucp.php?i=pm&folder=inbox" style="color:#000080" target="_blank">Private Message</a> in the forum!', '', 10000); }
                else if (previousCheckCount == 0) { WMETB_DispLog('No unread Private Messages in the forum'); };
            }); var d = new Date(); WMETB_LastForumCheck = d.getTime(); console.log('WMETB: Setting last forum check value to ' + WMETB_LastForumCheck);
        }
    }
    tb.push(20); function WMETB_createOverviewMap() {
        console.log('WMETB: creating overview map'); var WMETB_MapCenter4326 = Waze.map.getCenter().transform(new OpenLayers.Projection("EPSG:900913"), new OpenLayers.Projection("EPSG:4326")); var WMETB_MiniMap = document.createElement('div'); WMETB_MiniMap.id = "WMETB_MiniMap"; WMETB_MiniMap.style.position = 'absolute'; WMETB_MiniMap.style.visibility = 'hidden'; WMETB_MiniMap.style.zIndex = 1000; var WMETB_MiniMapOffset = 6; $('#WazeMap').append(WMETB_MiniMap); $('#WMETB_MiniMap').css('left', WMETB_MiniMapOffset); $('#WMETB_MiniMap').css('height', 158); $('#WMETB_MiniMap').css('top', ($('#WazeMap').height() - $('.olControlAttribution').height() - WMETB_MiniMapOffset - $('#WMETB_MiniMap').height()) + 'px'); $('#WMETB_MiniMap').css('width', 308); $('#WMETB_MiniMap').css('min-height', 75); $('#WMETB_MiniMap').css('min-width', 100); $('#WMETB_MiniMap').prepend('<iframe id="WMETB_iframeMiniMap" class="ui-widget-content" src="https://www.waze.com/livemap?lat=' + WMETB_MapCenter4326.lat + '&lon=' + WMETB_MapCenter4326.lon + '&zoom=9">'); $('#WMETB_iframeMiniMap').css({ 'border-width': 4, 'border-style': 'outset', 'position': 'absolute' }); if (typeof WMETB_ToSave.LiveMapOverviewStyle.Position.top == 'number') { $('#WMETB_MiniMap').css({ 'top': WMETB_ToSave.LiveMapOverviewStyle.Position.top }); }
        if (typeof WMETB_ToSave.LiveMapOverviewStyle.Position.left == 'number') { $('#WMETB_MiniMap').css({ 'left': WMETB_ToSave.LiveMapOverviewStyle.Position.left }); }
        if (typeof WMETB_ToSave.LiveMapOverviewStyle.Height == 'number') { $('#WMETB_MiniMap').css({ 'height': WMETB_ToSave.LiveMapOverviewStyle.Height }); }
        if (typeof WMETB_ToSave.LiveMapOverviewStyle.Width == 'number') { $('#WMETB_MiniMap').css({ 'width': WMETB_ToSave.LiveMapOverviewStyle.Width }); }
        if ($('#WMETB_MiniMap').height() > ($('#WazeMap').height() - $('.olControlAttribution').height())) { $('#WMETB_MiniMap').css({ 'height': ($('#WazeMap').height() - $('.olControlAttribution').height()) + 'px' }); }
        if ($('#WMETB_MiniMap').width() > $('#WazeMap').width()) { $('#WMETB_MiniMap').css({ 'width': $('#WazeMap').width() + 'px' }); }
        if (($('#WMETB_MiniMap').position().top + $('#WMETB_MiniMap').height()) > ($('#WazeMap').height() - $('.olControlAttribution').height())) { $('#WMETB_MiniMap').css({ 'top': ($('#WazeMap').height() - $('#WMETB_MiniMap').height() - $('.olControlAttribution').height()) + 'px' }); }
        if (($('#WMETB_MiniMap').position().left + $('#WMETB_MiniMap').width()) > $('#WazeMap').width()) { $('#WMETB_MiniMap').css({ 'left': ($('#WazeMap').width() - $('#WMETB_MiniMap').width()) + 'px' }); }
        $('#WMETB_iframeMiniMap').css({ 'height': $('#WMETB_MiniMap').height(), 'width': $('#WMETB_MiniMap').width() }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_MiniMap").css({ '-webkit-transform': 'translate3d(0,0,0)', '-webkit-backface-visibility': 'hidden', '-webkit-perspective': 1000, '-webkit-transform-style': 'flat' }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".download-hover").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".waze-header").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".footer").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".leaflet-marker-pane").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".leaflet-shadow-pane").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".leaflet-control-permalink").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".leaflet-popup-pane").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".leaflet-left").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find("#server-switcher").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".fullscreen").each(function () { $(this).css('top', 0); }); }); setInterval(function () { $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".jam").each(function () { $(this).remove(); }); }); $('#WMETB_iframeMiniMap').load(function () { $("#WMETB_iframeMiniMap").contents().find(".jam-outline").each(function () { $(this).remove(); }); }); }, 10000); $('#WMETB_iframeMiniMap').load(function () { var LRefresh = document.getElementById("WMETB_iframeMiniMap").contentWindow.L.Util; var LMap = document.getElementById("WMETB_iframeMiniMap").contentWindow.W.controller._mapView.map; LMap.on('dragend', WMETB_checkOverviewMapCenter); LRefresh.requestAnimFrame(LMap.invalidateSize, LMap, false, LMap._container); }); $('#WMETB_iframeMiniMap').load(function () { Waze.map.events.register("moveend", Waze.map, WMETB_panOverviewMap); }); $('#WMETB_iframeMiniMap').load(WMETB_panOverviewMap); if (WMETB_ToSave.LiveMapOverviewFeatures.EnableLiveMapOverview == true) { $('#WMETB_iframeMiniMap').load(function () { WMETB_MiniMap.style.visibility = 'visible'; }); }
        $('#WMETB_MiniMap').draggable({ appendTo: 'map', containment: 'parent', iframeFix: true, cursor: 'move', cursorAt: { top: 6, left: 6 }, helper: 'original', handle: $('#WMETB_iframeMiniMap'), zIndex: 1000, opacity: 0.5, start: function (event, ui) { $(this).css('cursor', 'move'); $(this).css('border', '12px solid #333'); $(this).css('zIndex', 5000); }, stop: function (event, ui) { $(this).css('cursor', 'default'); $(this).css('border', '0px solid #333'); $(this).css('zIndex', 1000); WMETB_ToSave.LiveMapOverviewStyle.Position = ui.position; WMETB_Save_All(); } }); $('#WMETB_MiniMap').resizable({ alsoResize: '#WMETB_iframeMiniMap', containment: 'parent', handles: 's,e,se', minHeight: 75, minWidth: 100, stop: function (event, ui) { $('#WMETB_iframeMiniMap').css({ 'height': ui.size.height, 'width': ui.size.width }); WMETB_ToSave.LiveMapOverviewStyle.Position = ui.position; WMETB_ToSave.LiveMapOverviewStyle.Height = ui.size.height; WMETB_ToSave.LiveMapOverviewStyle.Width = ui.size.width; WMETB_Save_All(); } }); setTimeout(function () { localStorage.setItem('livemap_user_state', JSON.stringify(WMETB_LiveMapInitialLocation)) }, 1000);
    }
    function WMETB_panOverviewMap() {
        var recenterLiveMapCheck = WMETB_ToSave.LiveMapOverviewFeatures.RecenterLiveMap; if (recenterLiveMapCheck == true) { var WMETB_Bounds4326 = Waze.map.getExtent().transform(new OpenLayers.Projection("EPSG:900913"), new OpenLayers.Projection("EPSG:4326")); var WMETB_Center4326 = Waze.map.getCenter().transform(new OpenLayers.Projection("EPSG:900913"), new OpenLayers.Projection("EPSG:4326")); var LMap = document.getElementById("WMETB_iframeMiniMap").contentWindow.W.controller._mapView.map; document.getElementById("WMETB_iframeMiniMap").contentWindow.W.controller._mapView.map.panTo({ lon: WMETB_Center4326.lon, lat: WMETB_Center4326.lat }); WMETB_overviewMapImages(LMap, WMETB_Center4326, WMETB_Bounds4326); }
        setTimeout(function () { localStorage.setItem('livemap_user_state', JSON.stringify(WMETB_LiveMapInitialLocation)) }, 1000);
    }
    function WMETB_overviewMapImages(map, center, bounds) { $("#WMETB_iframeMiniMap").contents().find(".leaflet-image-layer").each(function () { $(this).remove(); }); $("#WMETB_iframeMiniMap").contents().find('.leaflet-clickable').each(function () { $(this).remove(); }); var WMETB_OverviewCenterMarker = document.getElementById("WMETB_iframeMiniMap").contentWindow.L.circleMarker([center.lat, center.lon], 5, { color: 'blue', fillColor: 'steelblue', fillOpacity: 0.5 }); WMETB_OverviewCenterMarker.setRadius(5); var extent = [[bounds.bottom, bounds.left], [bounds.top, bounds.right]]; var WMETB_OverviewRectangle = document.getElementById("WMETB_iframeMiniMap").contentWindow.L.rectangle(extent, { color: 'red', weight: 1 }); var MinimapLayerGroup = document.getElementById("WMETB_iframeMiniMap").contentWindow.L.layerGroup([WMETB_OverviewRectangle, WMETB_OverviewCenterMarker]); MinimapLayerGroup.addTo(map); }
    function WMETB_checkOverviewMapCenter() {
        var recenterWMECheck = WMETB_ToSave.LiveMapOverviewFeatures.RecenterWME; if (recenterWMECheck == true) { var WMETB_LeafletCenter = document.getElementById("WMETB_iframeMiniMap").contentWindow.W.controller._mapView.map.getCenter(); var WMETB_LeafletLat = WMETB_LeafletCenter.lat; var WMETB_LeafletLon = WMETB_LeafletCenter.lng; var WMETB_TransformedOLCenter = new OpenLayers.LonLat(WMETB_LeafletLon, WMETB_LeafletLat).transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913")); Waze.map.panTo(WMETB_TransformedOLCenter); }
        setTimeout(function () { localStorage.setItem('livemap_user_state', JSON.stringify(WMETB_LiveMapInitialLocation)) }, 1000);
    }
    tc.push(1); function WMETB_setSnapDistance(tolerance) {
        var WMETB_modifyModelFeatureControl = null; for (i = 0; i < Waze.map.controls.length; i++) {
            if (typeof Waze.map.controls[i].snapControl == 'object') {
                if (Waze.map.controls[i].snapControl) {
                    var WMETB_snapControl = Waze.map.controls[i].snapControl.targets; for (j = 0; j < WMETB_snapControl.length; j++)
                    { WMETB_snapControl[j].edgeTolerance = tolerance; WMETB_snapControl[j].nodeTolerance = tolerance; WMETB_snapControl[j].tolerance = tolerance; WMETB_snapControl[j].vertexTolerance = tolerance; }
                }
            }
        }
    }
    function WMETB_setPointPlaceZoomToSize() {
        var pointPlaceZoomCheck = WMETB_ToSave.pointPlaceZoom; if (pointPlaceZoomCheck == true) { Waze.Config.venues.zoomToSize[3] = 4; Waze.Config.venues.zoomToSize[4] = 4; }
        else { Waze.Config.venues.zoomToSize[3] = 3; Waze.Config.venues.zoomToSize[4] = 3; }
    }
    tb.push(43); function WMETB_MeasurementToolRuler() {
        if (sec.WMETB_RightsCheck("MeasT")) {
            $('<div class="ToolboxMeasurementTool">').appendTo($('#map')); if ($('.ToolboxMeasurementTool').css('visibility') === 'hidden') {
                $('.ToolboxMeasurementTool').css('visibility', 'visible'); $('.ToolboxMeasurementTool').append('<div id="WMETB_MeasurementToolTitle" class="header"></div>').append('<div id="WMETB_MeasurementSelectionRadio">').append('<input type="radio" id="WMETB_MeasurementSelectionOption2" name="WMETB_MeasurementRadio" checked="checked" value="segment"><label for="WMETB_MeasurementSelectionOption2">Segment distance </label><br>').append('<input type="radio" id="WMETB_MeasurementSelectionOption3" name="WMETB_MeasurementRadio" value="venue"><label for="WMETB_MeasurementSelectionOption3">Place surface area </label><br>').append('<p id="WMETB_MeasurementToolBodyText">Select a segment to see distances between geometry nodes and cumulative distance from A and B.</p>').append('</div>'); $("#WMETB_MeasurementRadio").buttonset(); $("#WMETB_MeasurementToolTitle").text('Toolbox Measurements'); $("#WMETB_MeasurementToolTitle").append($('<span id="WMETB_MeasurementClose" height="10px">').button({ icons: { primary: 'ui-icon-close' } }).attr('title', 'Close measurement tool').attr('style', 'position:absolute;width:40px;right:10px;')); $("#WMETB_MeasurementClose").click(function () { WMETB_MeasurementToolClose(); }); function WMETB_InitializeRulerLayer() { Ruler_Layer = new OpenLayers.Layer.Vector("WMETB Measurement Tool", { displayInLayerSwitcher: false, rendererOptions: { zIndexing: true }, uniqueName: '__toolboxMeasurement' }); I18n.translations[I18n.locale].layers.name["__toolboxMeasurement"] = "WMETB Measurement Tool"; Ruler_Layer.setZIndex(9999); Waze.map.addLayer(Ruler_Layer); Waze.map.addControl(new OpenLayers.Control.DrawFeature(Ruler_Layer, OpenLayers.Handler.Path)); Ruler_Layer.setVisibility(true); }
                WMETB_InitializeRulerLayer(); setTimeout(SegmentStart, 100); if (Waze.selectionManager.selectedItems.length == 1 && Waze.selectionManager.selectedItems[0].model.type == 'segment') { $('#WMETB_MeasurementSelectionOption2').attr('checked', 'checked'); setTimeout(SegmentStart, 100); }
                $('#WMETB_MeasurementSelectionOption1').click(function () { Waze.map.removeLayer(Ruler_Layer); WMETB_InitializeRulerLayer(); setTimeout(RulerStart, 100); $('#WMETB_MeasurementToolBodyText').text('Click on the map to start measuring.\nClick again to stop.'); }); $('#WMETB_MeasurementSelectionOption2').click(function () { $('#map').off('click'); Waze.map.removeLayer(Ruler_Layer); WMETB_InitializeRulerLayer(); setTimeout(SegmentStart, 100); $('#WMETB_MeasurementToolBodyText').text('Select a segment to see distances between geometry nodes and cumulative distance from A and B.'); }); $('#WMETB_MeasurementSelectionOption3').click(function () { $('#map').off('click'); Waze.map.removeLayer(Ruler_Layer); WMETB_InitializeRulerLayer(); setTimeout(VenueStart, 100); $('#WMETB_MeasurementToolBodyText').text('Select an area place to see the surface area.'); }); function RulerStart() {
                    var WMETB_rulerClickCounter = 0; $('#map').on('click', function (event, attributes, style) {
                        var positionTest = $('.WazeControlMousePosition').text(); var emptyPosition = '00.00000, 00.00000'; if (WMETB_rulerClickCounter == 0 && positionTest != emptyPosition) { WMETB_rulerClickCounter++; var mousePositionIndex = $('.WazeControlMousePosition').text().indexOf(","); var mousePositionLength = $('.WazeControlMousePosition').text().length; var WMETB_rulerPointALon = $('.WazeControlMousePosition').text().substr(0, mousePositionIndex); var WMETB_rulerPointALat = $('.WazeControlMousePosition').text().substr(mousePositionIndex + 2, mousePositionLength); var WMETB_rulerPointA = new OpenLayers.Geometry.Point(WMETB_rulerPointALon, WMETB_rulerPointALat).transform(new OpenLayers.Projection("EPSG:4326"), Waze.map.getProjectionObject()); var measureStart = setInterval(function () { RulerMeasure(WMETB_rulerPointA, measureStart) }, 100); }
                        else if (WMETB_rulerClickCounter > 0) { Ruler_Layer.destroyFeatures(); WMETB_rulerClickCounter = 0; }
                    });
                }
                function RulerMeasure(WMETB_rulerPointA, measureStart) {
                    var WMETB_prefUnitsImperial = Waze.prefs.attributes.isImperial; var pointAAttributes = {}; var pointAStyle = { externalGraphic: document["WMETB_Ruler.png"].src, graphicWidth: 32, graphicHeight: 32, fillOpacity: .85, title: 'Ruler' }; Ruler_Layer.destroyFeatures(); var imageFeature = new OpenLayers.Feature.Vector(WMETB_rulerPointA, pointAAttributes, pointAStyle); Ruler_Layer.addFeatures([imageFeature]); var mousePositionIndex = $('.WazeControlMousePosition').text().indexOf(","); var mousePositionLength = $('.WazeControlMousePosition').text().length; var WMETB_rulerPointBLon = $('.WazeControlMousePosition').text().substr(0, mousePositionIndex); var WMETB_rulerPointBLat = $('.WazeControlMousePosition').text().substr(mousePositionIndex + 2, mousePositionLength); var positionTest = $('.WazeControlMousePosition').text(); var emptyPosition = '00.00000, 00.00000'; if (positionTest != emptyPosition) { var WMETB_rulerPointB = new OpenLayers.Geometry.Point(WMETB_rulerPointBLon, WMETB_rulerPointBLat).transform(new OpenLayers.Projection("EPSG:4326"), Waze.map.getProjectionObject()); }
                    else { return false; }
                    var pnt = []; pnt[0] = WMETB_rulerPointA; pnt[1] = WMETB_rulerPointB; var ring = new OpenLayers.Geometry.LinearRing(pnt); var line = new OpenLayers.Geometry.LineString(pnt); var measureDistance = line.getGeodesicLength(Waze.map.getProjectionObject()); var measureDistanceDisplay = (WMETB_prefUnitsImperial === true ? (measureDistance * 3.28084).toFixed(2) + 'ft' : measureDistance.toFixed(2) + 'm'); var polygon = new OpenLayers.Geometry.Polygon([ring]); var style = { strokeColor: 'AliceBlue', strokeOpacity: 1, strokeWidth: 2, label: measureDistanceDisplay, labelOutlineColor: "#18453B", labelOutlineWidth: 3, fontSize: 14, fontColor: "#FFFFFF", fontOpacity: .85, fontWeight: "bold" }; var feature = new OpenLayers.Feature.Vector(polygon, null, style); Ruler_Layer.addFeatures([feature]); $('#map').on('click', function (event) { clearInterval(measureStart); $('#map').off('click'); RulerStart(); });
                }
                function SegmentStart() {
                    var measureStart = setInterval(function () { SelectionCheck(measureStart) }, 500); function SelectionCheck(measureStart) {
                        var WMETB_prefUnitsImperial = Waze.prefs.attributes.isImperial; if (Waze.selectionManager.selectedItems.length == 1 && Waze.selectionManager.selectedItems[0].model.type == 'segment') {
                            $('#WMETB_MeasurementSelectionOption2').attr('checked', 'checked'); Ruler_Layer.destroyFeatures(); var currentSeg = Waze.selectionManager.selectedItems[0].clone(); var measureDistanceTotalA = 0; var measureDistanceTotalB = 0; for (i = 0; i < currentSeg.geometry.components.length - 1; i++) { var pnt = []; pnt[0] = currentSeg.geometry.components[i]; pnt[1] = currentSeg.geometry.components[i + 1]; var line = new OpenLayers.Geometry.LineString(pnt); var measureDistance = line.getGeodesicLength(Waze.map.getProjectionObject()); measureDistanceTotalA = measureDistanceTotalA + measureDistance; }
                            measureDistanceTotalB = measureDistanceTotalA; var segmentLength = measureDistanceTotalA; measureDistanceTotalA = 0; for (i = 0; i < currentSeg.geometry.components.length - 1; i++) {
                                var pnt = []; pnt[0] = currentSeg.geometry.components[i]; pnt[1] = currentSeg.geometry.components[i + 1]; var pntTotalA = []; pntTotalA[0] = currentSeg.geometry.components[0]; pntTotalA[1] = currentSeg.geometry.components[i + 1]; var line = new OpenLayers.Geometry.LineString(pnt); var lineTotalA = new OpenLayers.Geometry.LineString(pntTotalA); var measureDistance = line.getGeodesicLength(Waze.map.getProjectionObject()); var measureDistanceTotalA = measureDistanceTotalA + measureDistance; var measureDistanceTotalB = measureDistanceTotalB - measureDistance; var measureDistanceDisplay = (WMETB_prefUnitsImperial === true ? (measureDistance * 3.28084).toFixed(1) + 'ft' : measureDistance.toFixed(1) + 'm'); var measureDistanceDisplayTotalA = (WMETB_prefUnitsImperial === true ? (measureDistanceTotalA * 3.28084).toFixed(1) + 'ft' : measureDistanceTotalA.toFixed(1) + 'm'); var measureDistanceDisplayTotalB = (WMETB_prefUnitsImperial === true ? (Math.abs(measureDistanceTotalB) * 3.28084).toFixed(1) + 'ft' : Math.abs(measureDistanceTotalB).toFixed(1) + 'm'); var measureDistanceDisplaySegmentLength = (WMETB_prefUnitsImperial === true ? (segmentLength * 3.28084).toFixed(1) + 'ft' : segmentLength.toFixed(1) + 'm'); var measureDistanceDisplayFinal = measureDistanceDisplay; var measureDistanceDisplayFinalTotal = 'A:' + measureDistanceDisplayTotalA + '\nB:' + measureDistanceDisplayTotalB; var measureDistanceDisplayOrigin = (WMETB_prefUnitsImperial === true ? '0.00ft' : '0.00m'); var measureDistanceDisplayFinalOrigin = 'A:' + measureDistanceDisplayOrigin + '\nB:' + measureDistanceDisplaySegmentLength; var style = { label: measureDistanceDisplayFinal, labelOutlineColor: "#18453B", labelOutlineWidth: 3, labelXOffset: 30, labelYOffset: 10, fontSize: 12, fontColor: "#FFFFFF", fontOpacity: 1, fontWeight: "bold", zIndex: 1 }; var styleCumulative = { label: measureDistanceDisplayFinalTotal, labelOutlineColor: "#00274c", labelOutlineWidth: 3, labelXOffset: 40, labelYOffset: 10, fontSize: 12, fontColor: "#ffcb05", fontOpacity: 1, fontWeight: "bold", zIndex: 1 }; var styleOrigin = { label: measureDistanceDisplayFinalOrigin, labelOutlineColor: "#00274c", labelOutlineWidth: 3, labelXOffset: 40, labelYOffset: 10, fontSize: 12, fontColor: "#ffcb05", fontOpacity: 1, fontWeight: "bold", zIndex: 1 }; if (i == 0) { var featureCumulativeOrigin = new OpenLayers.Feature.Vector(pnt[0], null, styleOrigin); Ruler_Layer.addFeatures([featureCumulativeOrigin]); }
                                var featureCumulative = new OpenLayers.Feature.Vector(pnt[1], null, styleCumulative); Ruler_Layer.addFeatures([featureCumulative]); var ring = new OpenLayers.Geometry.LinearRing(pnt); var polygon = new OpenLayers.Geometry.Polygon([ring]); var feature = new OpenLayers.Feature.Vector(polygon, null, style); Ruler_Layer.addFeatures([feature]);
                            };
                        }
                        $('#WMETB_MeasurementSelectionOption1').on('click', function (event) { clearInterval(measureStart); Ruler_Layer.destroyFeatures(); }); $('#WMETB_MeasurementSelectionOption3').on('click', function (event) { clearInterval(measureStart); Ruler_Layer.destroyFeatures(); });
                    }
                }
                function VenueStart() {
                    var measureStart = setInterval(function () { SelectionCheck(measureStart) }, 500); function SelectionCheck(measureStart) {
                        var WMETB_prefUnitsImperial = Waze.prefs.attributes.isImperial; if (Waze.selectionManager.selectedItems.length == 1 && Waze.selectionManager.selectedItems[0].geometry.CLASS_NAME != 'OpenLayers.Geometry.Point' && Waze.selectionManager.selectedItems[0].model.type == 'venue') { $('#WMETB_MeasurementSelectionOption3').attr('checked', 'checked'); Ruler_Layer.destroyFeatures(); var currentVenue = Waze.selectionManager.selectedItems[0].clone(); var venueArea = currentVenue.geometry.getGeodesicArea(Waze.map.getProjectionObject()); var venueAreaDisplay = (WMETB_prefUnitsImperial === true ? (venueArea * 10.7639104).toFixed(0) + 'ft2' : venueArea.toFixed(0) + 'm2'); var style = { label: venueAreaDisplay, labelOutlineColor: "#00274c", labelOutlineWidth: 3, labelYOffset: 30, fontSize: 12, fontColor: "#ffcb05", fontOpacity: 1, fontWeight: "bold", graphicZIndex: 999 }; var pnt = []; pnt[0] = currentVenue.geometry.getCentroid(); var ring = new OpenLayers.Geometry.LinearRing(pnt); var polygon = new OpenLayers.Geometry.Polygon([ring]); var feature = new OpenLayers.Feature.Vector(polygon, null, style); Ruler_Layer.addFeatures([feature]); }
                        $('#WMETB_MeasurementSelectionOption1').on('click', function (event) { clearInterval(measureStart); Ruler_Layer.destroyFeatures(); }); $('#WMETB_MeasurementSelectionOption2').on('click', function (event) { clearInterval(measureStart); Ruler_Layer.destroyFeatures(); });
                    }
                }
            }
            else { WMETB_MeasurementToolClose(); }
            function WMETB_MeasurementToolClose() { $('.ToolboxMeasurementTool').remove(); $('#map').off('click'); Ruler_Layer.destroyFeatures(); Waze.map.removeLayer(Ruler_Layer); }
        }
    }
    tb.push(70); !function () {
        'use strict'; var europeandate = true; var alternate_row_colors = true; var SORT_COLUMN_INDEX; var thead = false; function sortables_init() {
            if (!document.getElementsByTagName)
                return; var tbls = document.getElementsByTagName("table"); for (ti = 0; ti < tbls.length; ti++) { thisTbl = tbls[ti]; if (((' ' + thisTbl.className + ' ').indexOf("sortable") != -1) && (thisTbl.id)) { ts_makeSortable(thisTbl); } }
        }
        function ts_makeSortable(t) {
            function createElement(p, type) { var e = document.createElement(type); if (p) p.appendChild(e); return e; }
            function createTextNode(p, txt) { p.appendChild(document.createTextNode(txt)); return p; }
            if (t.rows && t.rows.length > 0) { if (t.tHead && t.tHead.rows.length > 0) { var firstRow = t.tHead.rows[t.tHead.rows.length - 1]; thead = true; } else { var firstRow = t.rows[0]; } }
            if (!firstRow) return; for (var i = 0; i < firstRow.cells.length; i++) { var cell = firstRow.cells[i]; var txt = ts_getInnerText(cell); if (cell.className != "unsortable" && cell.className.indexOf("unsortable") == -1) { cell.innerHTML = ""; var elt = createElement(cell, "A"); elt.href = "#"; elt.className = "sortheader"; elt.onclick = function (cell, i) { return function () { ts_resortTable(cell, i); return false; }; }(cell, i); createTextNode(elt, txt); var span = createElement(cell, "span"); span.className = "sortarrow"; } }
            if (alternate_row_colors) { alternate(t); }
        }
        function ts_getInnerText(el) {
            if (typeof el == "string") return el; if (typeof el == "undefined") { return el }; if (el.innerText) return el.innerText; var str = ""; var cs = el.childNodes; var l = cs.length; for (var i = 0; i < l; i++) { switch (cs[i].nodeType) { case 1: str += ts_getInnerText(cs[i]); break; case 3: str += cs[i].nodeValue; break; } }
            return str;
        }
        function ts_resortTable(lnk, clid) {
            var span; for (var ci = 0; ci < lnk.childNodes.length; ci++) { if (lnk.childNodes[ci].tagName && lnk.childNodes[ci].tagName.toLowerCase() == 'span') span = lnk.childNodes[ci]; }
            var td = lnk.parentNode; var column = clid; var t = getParent(td, 'TABLE'); if (t.rows.length <= 1) return; var itm = ""; var i = 0; while (itm == "" && i < t.tBodies[0].rows.length) {
                var itm = ts_getInnerText(t.tBodies[0].rows[i].cells[column]); itm = trim(itm); if (itm.substr(0, 4) == "<!--" || itm.length == 0) { itm = ""; }
                i++;
            }
            if (itm == "") return; var sortfn = ts_sort_caseinsensitive; if (itm.match(/^\d\d[\/\.-][a-zA-z][a-zA-Z][a-zA-Z][\/\.-]\d\d\d\d$/))
                sortfn = ts_sort_date; if (itm.match(/^\d\d[\/\.-]\d\d[\/\.-]\d\d\d{2}?$/))
                    sortfn = ts_sort_date; if (itm.match(/^-?[£$€Û¢´]\d/))
                        sortfn = ts_sort_numeric; if (itm.match(/^-?(\d+[,\.]?)+(E[-+][\d]+)?%?$/))
                            sortfn = ts_sort_numeric; SORT_COLUMN_INDEX = column; var firstRow = new Array(); var newRows = new Array(); for (var k = 0; k < t.tBodies.length; k++) { for (var i = 0; i < t.tBodies[k].rows[0].length; i++) { firstRow[i] = t.tBodies[k].rows[0][i]; } }
            for (var k = 0; k < t.tBodies.length; k++) { if (!thead) { for (var j = 1; j < t.tBodies[k].rows.length; j++) { newRows[j - 1] = t.tBodies[k].rows[j]; } } else { for (var j = 0; j < t.tBodies[k].rows.length; j++) { newRows[j] = t.tBodies[k].rows[j]; } } }
            newRows.sort(sortfn); if (span.getAttribute("sortdir") == 'down') { var ARROW = '<img src="' + document["10arrowdown.gif"].src + '" alt="&darr;"/>'; newRows.reverse(); span.setAttribute('sortdir', 'up'); } else { var ARROW = '<img src="' + document["10arrowup.gif"].src + '" alt="&uarr;"/>'; span.setAttribute('sortdir', 'down'); }
            for (var i = 0; i < newRows.length; i++) { if (!newRows[i].className || (newRows[i].className && (newRows[i].className.indexOf('sortbottom') == -1))) { t.tBodies[0].appendChild(newRows[i]); } }
            for (var i = 0; i < newRows.length; i++) {
                if (newRows[i].className && (newRows[i].className.indexOf('sortbottom') != -1))
                    t.tBodies[0].appendChild(newRows[i]);
            }
            var allspans = document.getElementsByTagName("span"); for (var ci = 0; ci < allspans.length; ci++) { if (allspans[ci].className == 'sortarrow') { if (getParent(allspans[ci], "table") == getParent(lnk, "table")) { allspans[ci].innerHTML = ''; } } }
            span.innerHTML = ARROW; alternate(t);
        }
        function getParent(el, pTagName) { if (el == null) { return null; } else if (el.nodeType == 1 && el.tagName.toLowerCase() == pTagName.toLowerCase()) { return el; } else { return getParent(el.parentNode, pTagName); } }
        function sort_date(date) {
            var dt = "00000000"; if (date.length == 11) {
                var mtstr = date.substr(3, 3); mtstr = mtstr.toLowerCase(); switch (mtstr) { case "jan": var mt = "01"; break; case "feb": var mt = "02"; break; case "mar": var mt = "03"; break; case "apr": var mt = "04"; break; case "may": var mt = "05"; break; case "jun": var mt = "06"; break; case "jul": var mt = "07"; break; case "aug": var mt = "08"; break; case "sep": var mt = "09"; break; case "oct": var mt = "10"; break; case "nov": var mt = "11"; break; case "dec": var mt = "12"; break; }
                dt = date.substr(7, 4) + mt + date.substr(0, 2); return dt;
            } else if (date.length == 10) { if (europeandate == false) { dt = date.substr(6, 4) + date.substr(0, 2) + date.substr(3, 2); return dt; } else { dt = date.substr(6, 4) + date.substr(3, 2) + date.substr(0, 2); return dt; } } else if (date.length == 8) {
                var yr = date.substr(6, 2); if (parseInt(yr) < 50) { yr = '20' + yr; } else { yr = '19' + yr; }
                if (europeandate == true) { dt = yr + date.substr(3, 2) + date.substr(0, 2); return dt; } else { dt = yr + date.substr(0, 2) + date.substr(3, 2); return dt; }
            }
            return dt;
        }
        function ts_sort_date(a, b) {
            var dt1 = sort_date(ts_getInnerText(a.cells[SORT_COLUMN_INDEX])); var dt2 = sort_date(ts_getInnerText(b.cells[SORT_COLUMN_INDEX])); if (dt1 == dt2) { return 0; }
            if (dt1 < dt2) { return -1; }
            return 1;
        }
        function ts_sort_numeric(a, b) { var aa = ts_getInnerText(a.cells[SORT_COLUMN_INDEX]); aa = clean_num(aa); var bb = ts_getInnerText(b.cells[SORT_COLUMN_INDEX]); bb = clean_num(bb); return compare_numeric(aa, bb); }
        function compare_numeric(a, b) { var a = parseFloat(a); a = (isNaN(a) ? 0 : a); var b = parseFloat(b); b = (isNaN(b) ? 0 : b); return a - b; }
        function ts_sort_caseinsensitive(a, b) {
            var aa = ts_getInnerText(a.cells[SORT_COLUMN_INDEX]).toLowerCase(); var bb = ts_getInnerText(b.cells[SORT_COLUMN_INDEX]).toLowerCase(); if (aa == bb) { return 0; }
            if (aa < bb) { return -1; }
            return 1;
        }
        function ts_sort_default(a, b) {
            var aa = ts_getInnerText(a.cells[SORT_COLUMN_INDEX]); var bb = ts_getInnerText(b.cells[SORT_COLUMN_INDEX]); if (aa == bb) { return 0; }
            if (aa < bb) { return -1; }
            return 1;
        }
        function addEvent(elm, evType, fn, useCapture)
        { if (elm.addEventListener) { elm.addEventListener(evType, fn, useCapture); return true; } else if (elm.attachEvent) { var r = elm.attachEvent("on" + evType, fn); return r; } else { alert("Handler could not be removed"); } }
        function clean_num(str) { str = str.replace(new RegExp(/[^-?0-9.]/g), ""); return str; }
        function trim(s) { return s.replace(/^\s+|\s+$/g, ""); }
        function alternate(table) { var tableBodies = table.getElementsByTagName("tbody"); for (var i = 0; i < tableBodies.length; i++) { var tableRows = tableBodies[i].getElementsByTagName("tr"); for (var j = 0; j < tableRows.length; j++) { if ((j % 2) == 0) { if (!(tableRows[j].className.indexOf('odd') == -1)) { tableRows[j].className = tableRows[j].className.replace('odd', 'even'); } else { if (tableRows[j].className.indexOf('even') == -1) { tableRows[j].className += "even"; } } } else { if (!(tableRows[j].className.indexOf('even') == -1)) { tableRows[j].className = tableRows[j].className.replace('even', 'odd'); } else { if (tableRows[j].className.indexOf('odd') == -1) { tableRows[j].className += "odd"; } } } } } }
        window.ts_makeSortable = ts_makeSortable;
    }(); tc.push(0); var LayerSwitcherToolbox = OpenLayers.Class(OpenLayers.Control, { allowSelection: true, destroy: function () { this.map.events.un({ addlayer: this.onAddLayer, changelayer: this.redraw, removelayer: this.redraw, changebaselayer: this.redraw, scope: this }), OpenLayers.Control.prototype.destroy.apply(this, arguments) }, setMap: function () { OpenLayers.Control.prototype.setMap.apply(this, arguments), this.map.events.on({ addlayer: this.onAddLayer, changelayer: this.redraw, removelayer: this.redraw, changebaselayer: this.redraw, scope: this }), Waze.app.on("change:user", this.redraw, this), this.problemLayer = this.map.getLayersBy("uniqueName", "problems").first(), this.updateRequestLayer = this.map.getLayersBy("uniqueName", "update_requests").first() }, draw: function () { var e = this; return OpenLayers.Control.prototype.draw.apply(this), $(this.div).delegate("input.toggle", "change", function () { return e.onVisibiltyChanged.call(e, this.dataset.id, this.checked), false }).delegate("input.problem-filter", "change", function () { return e.setProblemFilter.call(e, this.checked), false }).on("click mousedown dragstart", function (e) { e.stopPropagation() }), this.map.layers.forEach(function (t) { e.registerLayerAccelerator(t) }), this.redraw(), this.div }, registerLayerAccelerator: function (e) { }, onAddLayer: function (e) { this.registerLayerAccelerator(e.layer), this.redraw() }, redraw: function () { var e = $(this.div), t = Waze.loginManager.user && Waze.loginManager.user.debugUser, i = this; return e.stacheComb("layer-switcher-toolbox", { layers: this.map.layers, problemLayer: this.problemLayer, isDebugUser: t }).then(function () { var t = e.find(".layerTogglers"); t.sortable({ handle: ".handle", items: ".draggable" }).bind("sortupdate", function (e, n) { var s = t.find(".toggler").index(n.item) - n.item.data("position") + 1; i.map.raiseLayer(i.map.getLayer(n.item.find("input").data("id")), s) }) }), e.toggleClass("debug-user", t), e.off("mouseover.layer-switcher").off("mouseout.layer-switcher"); var n = e.get(0).scrollHeight, s = e.get(0).scrollWidth; return e.on("mouseover.layer-switcher", function () { e.css("height", n).css("width", s).addClass("open") }).on("mouseout", function () { e.css("height", "").css("width", "").removeClass("open") }), this.div }, onVisibiltyChanged: function (e, t) { var i = this.map.getLayer(e); i.setVisibility(t); }, setProblemFilter: function (e) { var t = this.problemLayer.showClosed, i = !t && e, n = this.problemLayer.repo.concat(this.updateRequestLayer.repo); this.problemLayer.showClosed = e, this.problemLayer.$div.toggleClass("show-closed", e), this.updateRequestLayer.$div.toggleClass("show-closed", e), n.forEach(function (t) { e ? t.filter |= 1 : t.filter ^= 1, i && t.clear() }), i && this.controller.updateModel(true) }, CLASS_NAME: "Control.LayerSwitcherToolbox" }); tc.push(1); (function () {
        var proxied = window.XMLHttpRequest.prototype.send; window.XMLHttpRequest.prototype.send = function () {
            var pointer = this
            var intervalId = window.setInterval(function () {
                if (pointer.readyState != 4) { return; }
                if (pointer.responseText.indexOf('"login":true') >= 0) { }
                clearInterval(intervalId);
            }, 1); return proxied.apply(this, [].slice.call(arguments));
        };
    })(); tc.push(1); if (typeof google !== 'undefined' && typeof google.maps !== 'undefined' && typeof google.maps.StreetViewService !== 'undefined') {
        google.maps.StreetViewService.prototype.getPanoramaByLocationOrig = google.maps.StreetViewService.prototype.getPanoramaByLocation; google.maps.StreetViewService.prototype.getPanoramaByLocation = function (a, b, c) {
            this.getPanoramaByLocationOrig(a, b, function (d, e) {
                if (d && typeof d.imageDate !== 'undefined')
                { WMETB_StreetViewImageDate = d.imageDate; }
                else
                    WMETB_StreetViewImageDate = null; if ($('#street-view-date').length == 1)
                        $('#street-view-date')[0].innerHTML = (WMETB_StreetViewImageDate === null ? "-" : WMETB_StreetViewImageDate); c(d, e);
            });
        }; google.maps.StreetViewService.prototype.getPanoramaByIdOrig = google.maps.StreetViewService.prototype.getPanoramaById; google.maps.StreetViewService.prototype.getPanoramaById = function (a, b) {
            this.getPanoramaByIdOrig(a, function () {
                try {
                    if (arguments.length > 0 && arguments[0].hasOwnProperty('imageDate') == true && typeof arguments[0].imageDate !== 'undefined')
                        WMETB_StreetViewImageDate = arguments[0].imageDate; else
                        WMETB_StreetViewImageDate = null; if ($('#street-view-date').length == 1)
                            $('#street-view-date')[0].innerHTML = (WMETB_StreetViewImageDate === null ? "-" : WMETB_StreetViewImageDate);
                }
                catch (e)
                { WMETB_StreetViewImageDate = null; $('#street-view-date')[0].innerHTML = "Error 1 :("; }
                b.apply(this, arguments);
            });
        }
        google.maps.StreetViewService.prototype.getPanoramaOrig = google.maps.StreetViewService.prototype.getPanorama; google.maps.StreetViewService.prototype.getPanorama = function (a, b) {
            this.getPanoramaOrig(a, function () {
                try {
                    if (arguments.length > 0 && arguments[0].hasOwnProperty('imageDate') == true && typeof arguments[0].imageDate !== 'undefined')
                        WMETB_StreetViewImageDate = arguments[0].imageDate; else
                        WMETB_StreetViewImageDate = null; if ($('#street-view-date').length == 1)
                            $('#street-view-date')[0].innerHTML = (WMETB_StreetViewImageDate === null ? "-" : WMETB_StreetViewImageDate);
                }
                catch (e)
                { WMETB_StreetViewImageDate = null; $('#street-view-date')[0].innerHTML = "Error 2 :("; }
                b.apply(this, arguments);
            });
        }
    }
    var WMETB_createStreetViewDate = function () {
        if ($('#street-view-container').length == 1 && $('#street-view-date').length == 0)
        { var WMETB_SVDate = document.createElement('div'); WMETB_SVDate.id = 'street-view-date'; WMETB_SVDate.style.backgroundColor = "black"; WMETB_SVDate.style.color = "white"; WMETB_SVDate.innerHTML = "test"; WMETB_SVDate.style.position = 'absolute'; WMETB_SVDate.style.cssFloat = "left"; WMETB_SVDate.style.marginLeft = "35px"; WMETB_SVDate.style.top = "0px"; WMETB_SVDate.style.width = "75px"; WMETB_SVDate.style.textAlign = "center"; WMETB_SVDate.style.zIndex = 99999; WMETB_SVDate.title = "StreetView date (by Toolbox)"; $('#street-view-container')[0].appendChild(WMETB_SVDate); return; }
        setTimeout(WMETB_createStreetViewDate, 1000);
    }
    tc.push(0); var WMETB_Init = function (callback) { prompt("WME Toolbox: please report this error (use Ctrl-C to copy):", "Error 500"); return false; }; var WMETB_IsCM = function () { return false; }
    var WMETB_magicFixOthers = function () { WMETB_DispWarn("You're not allowed to use this feature."); return false; }; var WMETB_magicFixUturns = function () { WMETB_DispWarn("You're not allowed to use this feature."); return false; }; var WMETB_magicFixLoops = function () { WMETB_DispWarn("You're not allowed to use this feature."); return false; }; var WMETB_magicFixToll = function () { WMETB_DispWarn("You're not allowed to use this feature."); return false; }; tc.push(0); tc.push(1); var WMETB_MainInitialise = function () {
        console.log("WMETB: Initializing main features"); WMETB_ClearCache(); var WMETB_Default_Options = { alpha: 75, snapdst: 15, forumCheck: 30, pointPlaceZoom: false, highlightElevationMarkers: false, columns: ['Country', 'State', 'City', 'Street'], SelectSegment: ['Country', 'State', 'City', 'Street'], SelectVenue: ['Primary Category', 'Place Type', 'Place Name', 'Public', 'Brand', 'Lock Level', 'Place Approved', 'Pending Updates', 'Image Count', 'Image Preview', 'Country', 'State', 'City', 'Street', 'House Number', 'Created By', 'Updated By'], SelectSegmentStyle: { Position: '', Height: '', Width: '' }, SelectVenueStyle: { Position: '', Height: '', Width: '' }, extpermalink: ['livemap', 'beta'], ForceArrows: true, ZoomControlLeft: false, ZoomLevelIndicator: false, EnableHighlights: true, ToggleLockHighlights: true, LiveMapOverviewFeatures: { LiveMapOverviewFeatureActive: true, EnableLiveMapOverview: false, RecenterWME: true, RecenterLiveMap: true, EnableOverviewMap: true }, LiveMapOverviewStyle: { Position: '', Height: '', Width: '' }, ToolbarFeatures: { KeyboardShortcutEditor: true, SelectSegments: true, PropertiesEditor: true, CopySegmentAttributes: true, Clear_Road_Geometry: true, Split_Road: true, CreateJunctions: true, SelectRDBTNavBar: true, RedoRDBTNavBar: true, NotRDBTNavBar: true, DrawRDBTLandmarkNavBar: true, Select_In_Landmark: true, SuppressUnneededJunctions: true, SuppressUnneededGeometry: true, DeletePastRestrictions: true, magicFixLoops: true, magicFixToll: true, magicFixOthers: true, magicFixUturns: false, magicFixUnconfirmed: true, MeasurementTool: true }, csaOptions: { "copyFromSegment": "first", "CSA_cbCountryID": true, "CSA_cbCityName": true, "CSA_cbStreetName": true, "CSA_cbCopyRoadType": true, "CSA_cbCopyMaxSpeed": false, "CSA_cbCopyFlags": false, "CSA_cbCopyLevel": true, "CSA_cbCopyLock": true, "CSA_cbCopyDirection": false, "CSA_cbCopyTollRoad": true, "CSA_cbdeleteAltStreet": true, "CSA_cbcopyAltStreet": true }, Numrows: 1, RepairLayerSettings: true }; if (localStorage.WME_Toolbox_Options) { WMETB_ToSave = JSON.parse(localStorage.WME_Toolbox_Options); }
        if (localStorage.WME_Toolbox_Shortcuts) { WMETB_Shortcuts = JSON.parse(localStorage.WME_Toolbox_Shortcuts); }
        console.log("WMETB: loading saved options"); for (var k in WMETB_Default_Options) { WMETB_ToSave[k] = (typeof WMETB_ToSave[k] === 'undefined') ? WMETB_Default_Options[k] : WMETB_ToSave[k]; }
        if (typeof WMETB_ToSave.LiveMapOverviewFeatures.LiveMapOverviewFeatureActive === 'undefined')
            WMETB_ToSave.LiveMapOverviewFeatures.LiveMapOverviewFeatureActive = true; if (typeof WMETB_ToSave.ToolbarFeatures.CreateJunctions === 'undefined')
                WMETB_ToSave.ToolbarFeatures.CreateJunctions = true; var WMETB_New_Version = false; if (localStorage.WME_Toolbox) { var WMETB_previous_version = JSON.parse(localStorage.getItem('WME_Toolbox'))['version']; if (WMETB_previous_version != WMETBversion) { WMETB_New_Version = true; } } else if (localStorage.WME_Toolbox_Options) { WMETB_New_Version = true; }
        localStorage.setItem('WME_Toolbox', JSON.stringify({ 'version': WMETBversion })); if (WMETB_ToSave.snapdst == 0) { tolerance = 1; }
        else { tolerance = WMETB_ToSave.snapdst; }
        WMETB_setSnapDistance(tolerance); forumCheckDuration = WMETB_ToSave.forumCheck; forumCheckDurationField = ""; Numrows = WMETB_ToSave.Numrows; WMETB_setPointPlaceZoomToSize(); var beta = location.href.indexOf('beta.waze.com'); WMETB_LiveMapOverviewFeatureActive = WMETB_ToSave.LiveMapOverviewFeatures.LiveMapOverviewFeatureActive; if (WMETB_LiveMapOverviewFeatureActive) {
            if (beta == -1) { setTimeout(function () { WMETB_createOverviewMap() }, 100); }
            if (localStorage.livemap_user_state) { WMETB_LiveMapInitialLocation = JSON.parse(localStorage.getItem('livemap_user_state')); }
        }
        WMETB_createStreetViewDate(); var WMETB_logger_xpos = Math.max($('#WazeMap').width() / 2 - 250, 90); $('<div id="WMETB_logger">').css('position', 'absolute').css('zIndex', '1000').css('top', '15px').css('height', '0px').css('width', '500').css('left', WMETB_logger_xpos).css('color', 'white').css('font-size', '15px').css('font-weight', 'bold').css('margin-left', 'auto').css('margin-right', 'auto').appendTo($('#WazeMap')); $('<div id="WMETB_logger_warn">').css('position', 'absolute').css('zIndex', '1000').css('width', '500').css('top', '15px').css('height', '0px').css('left', WMETB_logger_xpos).css('color', 'white').css('font-size', '15px').css('font-weight', 'bold').css('margin-left', 'auto').css('margin-right', 'auto').appendTo($('#WazeMap')); WMETB_DispLog("Initializing plugin for " + sec.WMETB_VerifiedUserName + " (" + sec.WMETB_VerifiedUserRank + ")"); WMETB_ToolBar_Obj.objects = []; WMETB_ToolBar = new WMETB_ToolBar_Obj; var WMETB_tab = WMETBsetupTab(); WMETB_tab.innerHTML = '<b>WME Toolbox Plugin</b> &nbsp; &nbsp; &nbsp; v' + WMETBversion; WMETB_tab.innerHTML += '<br><br><a href="javascript:void(0);" id="WMETB_HelpOpen">WME Toolbox Quick help</a><br><br>'; WMETB_tab.innerHTML += '<a href="https://gitlab.com/doctorkb/wme-toolbox-public/raw/master/FEATURES" target="_blank">WME Toolbox Features List</a><br>'; WMETB_tab.innerHTML += '<a href="https://gitlab.com/doctorkb/wme-toolbox-public/raw/master/CHANGELOG" target="_blank">WME Toolbox History</a><br>'; WMETB_tab.innerHTML += '<a href="https://gitlab.com/doctorkb/wme-toolbox-public/raw/master/ACKNOWLEDGEMENTS" target="_blank">WME Toolbox Acknowledgements</a><br><br>'; WMETB_tab.innerHTML += '<font size=-1><a href="javascript:void(0);" id="WMETB_Reset">Reset WME Toolbox Settings</a></font><br><br>'; var WMETB_MaskDiv = document.createElement('div'); WMETB_MaskDiv.id = "WMETB_MaskDiv"; WMETB_MaskDiv.style.position = 'absolute'; WMETB_MaskDiv.style.display = 'none'; WMETB_MaskDiv.style.top = '0'; WMETB_MaskDiv.style.left = '0'; WMETB_MaskDiv.style.zIndex = 2500; WMETB_MaskDiv.style.backgroundColor = '#000000'; document.body.appendChild(WMETB_MaskDiv); $('#WMETB_MaskDiv').css('opacity', '0.7'); $('#WMETB_MaskDiv').css('width', '100%'); $('#WMETB_MaskDiv').css('height', '100%'); var WMETB_HelpDiv = document.createElement('div'); WMETB_HelpDiv.id = 'WMETB_HelpDiv'; WMETB_HelpDiv.style.position = 'absolute'; WMETB_HelpDiv.style.display = 'none'; WMETB_HelpDiv.style.top = '0'; WMETB_HelpDiv.style.left = '0'; WMETB_HelpDiv.style.zIndex = 3000; WMETB_HelpDiv.style.backgroundColor = 'LemonChiffon'; WMETB_HelpDiv.style.border = '1px solid red'; WMETB_HelpDiv.style.boxShadow = '5px 5px 10px Silver'; WMETB_HelpDiv.style.padding = '4px'; $(document.body).append(WMETB_HelpDiv); $('#WMETB_HelpDiv').css('height', '80%'); $('#WMETB_HelpDiv').css('width', '80%'); $('#WMETB_HelpDiv').css('top', '10%'); $('#WMETB_HelpDiv').css('left', '10%'); $('#WMETB_HelpDiv').css('overflow', 'auto'); var WMETB_HelpHtml = '<b><table width="100%"><tr><td width="100%" align="center">WME Toolbox - Help</td><td align="right"><span class="WMETB_HelpClose">[X]</span></td></tr></table></b><br>'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<b>=== Toolbox layers ===</b><br>'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<img src=' + document["layer_help.png"].src + '>'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<b>=== Toolbox bar ===</b><br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["sidebar_arrow_left.png"].src + '"> / <img width="20" height="20" src="' + document["sidebar_arrow_right.png"].src + '"> : Toggle the auto-hide left sidebar feature.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["power_green.png"].src + '"> : Toggle Toolbox highlights.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["lock_green.png"].src + '"> : Toggle Toolbox lock highlights.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["search-icon-green.png"].src + '"> : Toggle mini-map.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["cp.png"].src + '"> : Configure Toolbox options.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["keyboard.png"].src + '"> : Configure WME shortcuts (including Toolbox shortcuts).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["select.png"].src + '"> : Open the select segments panel.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["select_venue.png"].src + '"> : Open the places panel.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_Ruler.png"].src + '"> : Use the measurement tool.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["pe_on.png"].src + '"> : Open the properties editor panel.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_CopySegmentAttributes.png"].src + '"> : Open the copy segment attributes panel (select at least 2 segments first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["Clear_Road_Geometry.png"].src + '"> : Clear road geometry (only keep starting and ending node - select 1 segment first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["Split_Road.png"].src + '"> : Cut segment (add node to cut segment in two - select 1 segment first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_CreateJunctions.png"].src + '"> : Create junctions on all selected segments that overlap at same elevation (at the overlapping points).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["RDB_Select.png"].src + '"> : Select all Roundabout segments (select 1 roundabout segment first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["RDB_Redo.png"].src + '"> : Redo Roundabout. Use it to recreate a roundabout automatically (select 1 roundabout segment first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["RDB_StandardRoad.png"].src + '"> : Convert a roundabout to a standard circular road (select 1 roundabout segment first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["RDB_Landmark.png"].src + '"> : Draw a roundabout area place (select 1 roundabout segment first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["Select_In_Landmark.png"].src + '"> : Select segments within the selected area place (select 1 area place first).'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["wipe.png"].src + '"> : Suppress unneeded junctions on screen.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_SuppressUnneededGeometry.png"].src + '"> : Remove unneeded geometry nodes within segments.  Segments that will be changed are identified by Simplifiable Segments highlight'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_DeletePastRestrictions.png"].src + '"> : Delete expired restrictions (expired ending date) on screen.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_magicFixLoops.png"].src + '"> : Add node to loop segments on screen.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_magicFixToll.png"].src + '"> : Select non freeway/ramp segments with toll attribute.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["WMETB_magicFixOthers.png"].src + '"> : Fix reverse connections, dead-end loops and unterminated roads on screen.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<br><img width="20" height="20" src="' + document["UTurnNode.png"].src + '"> Fix u-turns on screen.'; WMETB_HelpHtml += '<br>'; WMETB_HelpHtml += '<span class="WMETB_HelpClose"><b>[Close]</b></span>'; WMETB_HelpDiv.innerHTML = WMETB_HelpHtml; $('.WMETB_HelpClose').css('cursor', 'pointer'); $(".WMETB_HelpClose").click(function () { $('#WMETB_HelpDiv').css('display', 'none'); $('#WMETB_MaskDiv').css('display', 'none'); }); $('#WMETB_HelpOpen').css('cursor', 'pointer'); $("#WMETB_HelpOpen").click(function () { $('#WMETB_HelpDiv').css('display', 'block'); $('#WMETB_MaskDiv').css('display', 'block'); }); $('#WMETB_Reset').css('cursor', 'pointer'); $("#WMETB_Reset").click(function () {
            if (window.confirm("Do you want to reload the editor with DEFAULT Toolbox options ?")) {
                if (localStorage.keyboardShortcuts) { var WME_Options = JSON.parse(localStorage.keyboardShortcuts); $.each(WMETB_ShortcutsMenu.RegistredFeatures, function (i) { delete WME_Options[WMETB_ShortcutsMenu.RegistredFeatures[i]]; }); localStorage.keyboardShortcuts = JSON.stringify(WME_Options); }
                localStorage.removeItem('WME_Toolbox_Options'); localStorage.removeItem('WME_Toolbox_Shortcuts'); WMETB_SaveOnExit = false; location.reload();
            }
        }); var WMETB_ExternalCheck = ""; if ($('a[href="http://userscripts.org/scripts/show/155465"]').length > 0) { WMETB_ExternalCheck += '<br>Please uninstall WME Colour Highlights [enhanced] (which is deprecated) to use WME Toolbox'; }
        if ($("#slider").length > 0) { WMETB_ExternalCheck += '<br>Please uninstall WME Addons (which is not maintained anymore) to use WME Toolbox. All main features of WME Addons are now available in WME Toolbox.'; }
        if (WMETB_ExternalCheck !== "") { alert('<b><font color="red">These actions are required to enable WME Toolbox</font></b><br>' + WMETB_ExternalCheck); return; } else { $('#WMETB_NavBar').css('visibility', 'visible'); }
        WMETB_sidebarvisible = true; WMETB_sidebarOriginalWidth = $("#sidebar").width(); WMETB_CurrentMousePosX = 0; WMETB_CurrentMousePosY = 0; $(".container-fluid").on('mousemove', function (e) { WMETB_CurrentMousePosX = e.pageX; WMETB_CurrentMousePosY = e.pageY; if (WMETB_AutoHideSideBar && (e.pageX < 20) && (WMETB_sidebarvisible === false)) { WMETB_slideSideBar("show"); } }); $("#map").on('mousemove', function (e) { WMETB_CurrentMousePosX = e.pageX; WMETB_CurrentMousePosY = e.pageY; if (WMETB_AutoHideSideBar && (e.pageX >= 20) && (WMETB_sidebarvisible === true)) { WMETB_slideSideBar("hide"); } }); Waze.vent.on("operationPending", function () { ToolboxPending = true }); Waze.vent.on("operationDone", function () { ToolboxPending = false }); if (!WMETB_ToSave.LiveMapOverviewFeatures.EnableLiveMapOverview) { $("#WMETB_iframeMiniMap").css('visibility', 'hidden'); }
        WMETBsetupLayerSwitcher(); if (localStorage.WMETB) { localStorage.removeItem('WMETB'); }
        if (localStorage.WMETB_NavBar) { localStorage.removeItem('WMETB_NavBar'); }
        WMETB_Saved_Obj.objects = []; new WMETB_Saved_Obj("HighlightLocked_L2"); new WMETB_Saved_Obj("HighlightLocked_L3"); new WMETB_Saved_Obj("HighlightLocked_L4"); new WMETB_Saved_Obj("HighlightLocked_L5"); new WMETB_Saved_Obj("HighlightLocked_L6"); new WMETB_Saved_Obj("HideUserGreetings"); new WMETB_Saved_Obj("HighlightSameConnection"); new WMETB_Saved_Obj("HighlightHouseNumbers"); new WMETB_Saved_Obj("HighlightStreetNamesWithoutHouseNumbers"); new WMETB_Saved_Obj("Tunnels"); new WMETB_Saved_Obj("SpeedLimit"); if (sec.WMETB_RightsCheck("HiLiUTurn")) { new WMETB_Saved_Obj("HighlightUTurns"); }
        if (sec.WMETB_RightsCheck("HiLiRevC")) { new WMETB_Saved_Obj("HighlightRevConns"); }
        if (sec.WMETB_RightsCheck("HiLiDELp")) { new WMETB_Saved_Obj("HighlightDeadEndRDB"); }
        if (sec.WMETB_RightsCheck("HiLiSoftT")) { new WMETB_Saved_Obj("HighlightSoftTurns"); }
        if (sec.WMETB_RightsCheck("HiLiRB")) { new WMETB_Saved_Obj("HighlightRB"); }
        if (sec.WMETB_RightsCheck("PopUps")) { new WMETB_Saved_Obj("Popups"); }
        if (sec.WMETB_RightsCheck("HiLiSi")) { new WMETB_Saved_Obj("HighlightSimpleSegment"); }
        if (WMETB_ToSave.NavBarLeft && WMETB_ToSave.NavBarTop) {
            if (WMETB_ToSave.NavBarLeft < ($(window).width() - $('#WMETB_NavBar').width()) && WMETB_ToSave.NavBarLeft > $('#sidebar').width()) { $('#WMETB_NavBar').css('left', WMETB_ToSave.NavBarLeft + 'px'); }
            if (WMETB_ToSave.NavBarTop < ($(window).height() - $('#WMETB_NavBar').height())) { $('#WMETB_NavBar').css('top', WMETB_ToSave.NavBarTop + 'px'); }
        }
        WMETB_SaveOnExit = false; var WMETB_saveOptions = function () { 'use strict'; if (localStorage) { if (typeof WMETB_ToSave !== "undefined") { WMETB_Save_All(); } } }; window.addEventListener("beforeunload", WMETB_saveOptions); if (Waze.app.modeController) { Waze.app.modeController.model.bind('change:mode', function (model, modeId) { if (modeId == 0) { WMETBsetupTab(WMETB_tab); WMETBsetupLayerSwitcher(); WMETB_Highlight_Init(); } }); }
        WMETB_NewSave = false; window.setInterval(WMETB_Save_All, 60000); WMETB_reloadShortcuts(); WMETB_ShortcutsMenu.RestoreItems(); $("#edit-buttons").css('width', ($("#edit-buttons").width()) + 20 + 'px'); $("#toolbar").css('width', 'auto'); Waze.map.updateSize(); if (WMETB_ToSave.ForceArrows || !sec.WMETB_RightsCheck("ArrLoad")) { W.geometryEditing.editNodeConsControl.showArrows = false; W.geometryEditing.editNodeConsControl.toggleArrows(); }
        WMETB_ToggleUserGreetings(); sec.WMETB_TopCountry = sec.WMETB_topCountryID(); WMETB_Highlight_Init(); setTimeout(WMETB_LayersInitialise, 100); var roleList = ""; if (sec.WMETB_VerifiedIsAreaManager) roleList += " AM"; if (sec.WMETB_IsCM()) roleList += " CM"; if (sec.WMETB_IsGC()) roleList += " GC"; if (roleList) WMETB_DispLog("User roles:" + roleList); var WMETB_ZoomLevelIndicator = document.createElement('div'); WMETB_ZoomLevelIndicator.id = "WMETB_ZoomLevelIndicator"; WMETB_ZoomLevelIndicator.style.position = 'absolute'; WMETB_ZoomLevelIndicator.style.zIndex = 999; WMETB_ZoomLevelIndicator.style.backgroundColor = 'white'; WMETB_ZoomLevelIndicator.style.color = '#9a9a9a'; WMETB_ZoomLevelIndicator.innerHTML = Waze.map.getZoom(); WMETB_ZoomLevelIndicator.title = "Zoom level (by Toolbox)"; WMETB_ZoomLevelIndicator.border = '1px solid black'; $('#WazeMap').append(WMETB_ZoomLevelIndicator); $('#WMETB_ZoomLevelIndicator').css({ 'right': 50, 'top': 12, 'height': 25, 'width': 25, 'box-shadow': '0px 2px 0px 0px #9a9a9a', 'border-radius': '25px 25px 25px 25px', 'text-align': 'center', 'vertical-align': 'center', 'line-height': '25px' }); if (!WMETB_ToSave.ZoomLevelIndicator)
            $('#WMETB_ZoomLevelIndicator').hide(); Waze.map.events.register("zoomend", this, WMETB_UpdateZoomLevelIndicator); WMETB_ToggleZoomControlLeft(); WMETB_SaveOnExit = true; if (WMETB_New_Version) { WMETB_NewVersionPanel(); }
        if (typeof uroWazeBits !== "undefined") { console.log("WMETB: URO+ detected. Reloading it to avoid layer issues."); uroWazeBits(); }
        var beta = location.href.indexOf('beta.waze.com'); if (beta == -1) { setTimeout(function () { WMETB_ForumInboxCheck(); Waze.map.events.register("zoomend", this, WMETB_ForumInboxCheck); Waze.map.events.register("moveend", this, WMETB_ForumInboxCheck); }, 100) }
        setTimeout(function () { console.log("WMETB: Enjoy!") }, 1000);
    }; function WMETBsetupTab(recoveredTab) {
        var addon = document.createElement('WMETB_section'); var userTabs = WMETB_getId('user-info'), navTabs = WMETB_getElementsByClassName('nav-tabs', userTabs)[0], tabContent = WMETB_getElementsByClassName('tab-content', userTabs)[0]; var WMETB_newtab = document.createElement('li'); WMETB_newtab.innerHTML = '<a href="#WMETB_sidepanel" data-toggle="tab"><i class="fa fa-briefcase" title="Toolbox"></i></a>'; navTabs.appendChild(WMETB_newtab); if (recoveredTab) { addon = recoveredTab; } else { addon.id = "WMETB_sidepanel"; addon.className = "tab-pane"; }
        tabContent.appendChild(addon); return addon;
    }
    function WMETBsetupLayerSwitcher() { var tbHandle = document.createElement('div'); tbHandle.id = 'toolbox-switcher'; tbHandle.className = 'waze-icon-toolbox toolbar-submenu toolbar-group toolbar-group-toolbox'; var tbDock = WMETB_getElementsByClassName("waze-icon-place", WMETB_getId('edit-buttons'))[0]; tbHandle.onmouseover = (function () { WMETB_getId("WMETB_NavBar").style.pointerEvents = "none"; WMETB_getId("WMETB_NavBar").style.opacity = "0"; }); tbHandle.onmouseout = (function () { WMETB_getId("WMETB_NavBar").style.pointerEvents = "auto"; WMETB_getId("WMETB_NavBar").style.opacity = "1"; }); tbDock.parentNode.insertBefore(tbHandle, tbDock); var tbIconMenu = document.createElement('div'); tbIconMenu.className = 'toolbar-button'; tbIconMenu.innerHTML = '<i class="fa fa-briefcase"></i>'; tbIconMenu.onmouseover = (function () { tbContainerMenu.style.display = 'block'; }); tbIconMenu.onmouseout = (function () { tbContainerMenu.style.display = 'none'; }); tbHandle.appendChild(tbIconMenu); var tbContainerMenu = document.createElement('menu'); tbContainerMenu.className = 'controls-container toolbox-dropdown-menu'; var tbUl = document.createElement('ul'); tbUl.id = 'toolboxUl'; tbUl.className = 'list-unstyled togglers'; tbContainerMenu.appendChild(tbUl); tbIconMenu.appendChild(tbContainerMenu); if (!WMETB_ToSave.EnableHighlights) { tbHandle.style.visibility = 'hidden'; } }
    tc.push(0); var dc = function (f) {
        'use strict'; for (var g = function (a) { a = a.split(" "); a = a.join(""); a = a.split("\n"); a = a.join(""); a = a.split("%"); a = a.join(""); for (var b = a.length / 2, d = "", c = "", e = 0; e < b; ++e) d = a.substr(2 * e, 1), d += a.substr(2 * e + 1, 1), d = "0x" + d, d = Number(d), c = 0 == d ? c + " " : c + String.fromCharCode(d); return c }, c = [], b = 0; b < tb.length; b++) c[b] = 0 == b ? tb[b] : 1 == tc[b] ? c[b - 1] - tb[b] : c[b - 1] + tb[b]; for (b = 0; b < c.length; b++) c[b] = g(c[b].toString(16)); c = function (a) {
            function b(a, c, e) { return 0 === c ? e : b(a, --c, e + a[c]) }
            return b(a, a.length, "")
        }(c.join("")); return dcc(f, c)
    }; tc.push(1); var sc6 = new Function('var sec=arguments[0];' + dc(sc[6])); sc6(sec); var tzf = new Function('var sec=arguments[0];' + dc(tz)); tzf(sec); var WMETB_RoadTypes = I18n.translations[I18n.locale].segment.road_types; var WMETB_PopupX, WMETB_PopupY, WMETB_PopupShown, WMETB_PopupTimer, WMETB_MouseInPopup, WMETB_NullOpenLayers, WMETB_NullRootContainer, WMETB_MaskLayer, WMETB_StreetViewImageDate = null, WMETB_LiveMapOverviewFeatureActive, Enable_WMETB_PropertiesEditor = false, Enable_WMETB_CopySegmentAttributes = false, Enable_WMETB_Clear_Road_Geometry = false, Enable_WMETB_Split_Road = false, Enable_WMETB_Select_RoundAbout = false, Enable_WMETB_Redo_RoundAbout = false, Enable_WMETB_RDBToStandardRoad = false, Enable_WMETB_DrawRDBTLandmark = false, Enable_WMETB_Select_In_Landmark = false, Enable_WMETB_SuppressUnneededGeometry = false, WMETB_newversionpanel, WMETB_dlg, WMETB_ToSave = {}, WMETB_Shortcuts = {}, tolerance, toleranceField, forumCheckDuration, forumCheckDurationField, Numrows, WMETB_LastForumCheck, WMETB_LiveMapInitialLocation = {}, L2LockColor = "#11f247", L3LockColor = "#71f211", L4LockColor = "#e2f211", L5LockColor = "#f29011", L6LockColor = "#f22011", ElevationColor = "#707070", SameConnectionsColor = "#EDA01C", BadRdbtColor = "#3030FF", HouseNumbersColor = "#00A8FF", StreenNamesWithoutHouseNumbersColor = "#008506", RestrictionColor = "#F7B020", RestrictionColorOld = "#FF4D3D", SimpleSegmentsColor = "#FF30FF", UTurnsColor = "#75BD26", RevConnsColor = "#FF00FF", DeadEndRDBColor = "#F7D117", SoftTurnsColor = "#FFFF00", TTSOverrideColor = "#F68F23", SpeedLimitColor = "#7F7F00", TunnelColor = "#0F0F0F", WMETB_OkToRun = false, WMETB_AutoHideSideBar = false, WMETB_cfgpanel, WMETB_sidebarvisible, WMETB_sidebarOriginalWidth, WMETB_CurrentMousePosX, WMETB_CurrentMousePosY, WMETB_SaveOnExit, WMETB_NewSave, WMETB_ShortcutsMenu, WMETB_ToolBar, WMETB_HighlightSegments_HouseNumbers_doneseg = [], WMETB_HighlightSegments_StreetNamesWithoutHouseNumber_doneseg = [], WMETB_RegularLoopSegIds = [], ToolboxPending = false, UpdateObject, SplitSegments, MergeSegments, UpdateFeatureAddress, DisconnectSegment, AddSegment, DeleteSegment, MultiAction, UpdateSegmentGeometry, ConnectSegment, AddNode, ModifyAllConnections, ModifyConnection, SetTurn, CreateRoundabout, AddAlternateStreet, CreateObject, ModifyConnectionRestrictions, AddLandmark, FeatureVectorSegment, AddIntersection, Control, WMETB_nonDividableRoadTypes = [5, 10, 16, 18]; sec.WMETB_TopCountry = 0; sec.WMETB_VerifiedUserName = null; sec.WMETB_VerifiedUserRank = null; sec.WMETB_VerifiedIsAreaManager = false; sec.WMETB_VerifiedEditableCountryIDs = null; var WMETB_RoadTypePriority = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 0, 5: 0, 6: 5, 7: 4, 8: .5, 10: 0, 16: 0, 17: .7, 18: 0, 19: 0, 20: .8, 21: .6 }; var WMETB_getSelectedLandMark = function () {
        'use strict'; var lmList = []; for (var i = 0; i < Waze.selectionManager.selectedItems.length; i++) { var m = Waze.selectionManager.selectedItems[i]; if (m.model.type == 'venue' && m.model.attributes.geometry.CLASS_NAME != 'OpenLayers.Geometry.Point') lmList.push(m.geometry); }
        if (lmList.length == 0) { for (var id in Waze.model.venues.objects) { if (id < 0) { var curLm = Waze.model.venues.objects[id]; var curFid; if (lmList.length == 0 || id < curFid) { lmList[0] = curLm.geometry; curFid = id; } } } }
        return lmList;
    }, WMETB_getAddress = function (seg) {
        'use strict'; if (seg.type == 'segment') { var f = seg.model.streets.get(seg.attributes.primaryStreetID); }
        else if (seg.type == 'venue') { var g = seg.model.streets.get(seg.attributes.streetID); }
        var e, c, d, a; var b = seg; if (f) {
            e = seg.model.cities.get(f.cityID).attributes; if (e) { c = seg.model.states.get(e.stateID); d = seg.model.countries.get(e.countryID); }
            a = seg.attributes.streetIDs.map(function (g) { b.model.streets.get(g); }); return { street: f, city: e, state: c, country: d, altStreets: a };
        }
        else if (g) {
            e = seg.model.cities.get(g.cityID).attributes; if (e) { c = seg.model.states.get(e.stateID); d = seg.model.countries.get(e.countryID); }
            return { street: g, city: e, state: c, country: d };
        }
        else { return { street: "Error", city: "Error", state: "Error", country: "Error" }; }
    }, WMETB_getStreetNameElt = function (streetName) {
        'use strict'; var r; if (!streetName) { return ['', '']; }
        if (streetName.match(/^[ACDMN]\d{1,5}(?:(?:\w?\d?)|(?:[IXVLCDM]*))\b(?! ?:)/)) { r = [streetName.match(/^[ACDMN]\d{1,5}(?:(?:\w?\d?)|(?:[IXVLCDM]*))\b(?! ?:)/)[0], streetName.split(/-[!\s.]+/)[1] || '']; } else { r = ['', streetName]; }
        return r;
    }; var global = { wazeinit: wazeinit, WMETBversion: WMETBversion, WMETB_DispLog: WMETB_DispLog, WMETB_DispWarn: WMETB_DispWarn, WMETB_DispErr: WMETB_DispErr, WMETB_Debug: WMETB_Debug, WMETB_CountryChanged: WMETB_CountryChanged, WMETB_isNodeInGeometries: WMETB_isNodeInGeometries, WMETB_onScreen: WMETB_onScreen, WMETB_limitForSaveReach: WMETB_limitForSaveReach, WMETB_isSegUnknown: WMETB_isSegUnknown, WMETB_getId: WMETB_getId, WMETB_JNF_source: function () { return WMETB_JNF_source; }, WMETB_CheckSameSegmentsWithSameNodes: WMETB_CheckSameSegmentsWithSameNodes, WMETB_returnPriority: WMETB_returnPriority, WMETB_SplitRoad: WMETB_SplitRoad, WMETB_JNF_FixNode: function (node, wtf) { WMETB_JNF_FixNode(node, wtf); }, WME_JNF_FixNode: function (node, wtf) { WME_JNF_FixNode(node, wtf); }, UpdateObject: UpdateObject, SplitSegments: SplitSegments, MergeSegments: MergeSegments, UpdateFeatureAddress: UpdateFeatureAddress, DisconnectSegment: DisconnectSegment, AddSegment: AddSegment, DeleteSegment: DeleteSegment, MultiAction: MultiAction, UpdateSegmentGeometry: UpdateSegmentGeometry, ConnectSegment: ConnectSegment, AddNode: AddNode, ModifyAllConnections: ModifyAllConnections, ModifyConnection: ModifyConnection, SetTurn: SetTurn, CreateRoundabout: CreateRoundabout, AddAlternateStreet: AddAlternateStreet, CreateObject: CreateObject, ModifyConnectionRestrictions: ModifyConnectionRestrictions, AddLandmark: AddLandmark, FeatureVectorSegment: FeatureVectorSegment, AddIntersection: AddIntersection, Control: Control }; var sc0 = new Function('var sec=arguments[0];\n var global=arguments[1];' + dc(sc[0])); sc0(sec, global); var sc4 = new Function('var sec=arguments[0];\n var global=arguments[1];' + dc(sc[4])); sc4(sec, global); var sc5 = new Function('var sec=arguments[0];\n var global=arguments[1];' + dc(sc[5])); sc5(sec, global); var initGlobals = function () {
        var that = this; if (typeof sec.require === 'undefined' || typeof sec.require.define === 'undefined' || typeof sec.require.define.modules === 'undefined' || Object.keys(sec.require.define.modules).length == 0)
        { setTimeout(function () { initGlobals.call(that); }, 100); return; }
        AddOrGetStreet = sec.require("Waze/Action/AddOrGetStreet"); global.AddOrGetStreet = AddOrGetStreet; UpdateObject = sec.require("Waze/Action/UpdateObject"); global.UpdateObject = UpdateObject; SplitSegments = sec.require("Waze/Action/SplitSegments"); global.SplitSegments = SplitSegments; MergeSegments = sec.require("Waze/Action/MergeSegments"); global.MergeSegments = MergeSegments; UpdateFeatureAddress = sec.require("Waze/Action/UpdateFeatureAddress"); global.UpdateFeatureAddress = UpdateFeatureAddress; DisconnectSegment = sec.require("Waze/Action/DisconnectSegment"); global.DisconnectSegment = DisconnectSegment; AddSegment = sec.require("Waze/Action/AddSegment"); global.AddSegment = AddSegment; DeleteSegment = sec.require("Waze/Action/DeleteSegment"); global.DeleteSegment = DeleteSegment; MultiAction = sec.require("Waze/Action/MultiAction"); global.MultiAction = MultiAction; UpdateSegmentGeometry = sec.require("Waze/Action/UpdateSegmentGeometry"); global.UpdateSegmentGeometry = UpdateSegmentGeometry; ConnectSegment = sec.require("Waze/Action/ConnectSegment"); global.ConnectSegment = ConnectSegment; AddNode = sec.require("Waze/Action/AddNode"); global.AddNode = AddNode; ModifyConnection = sec.require("Waze/Action/ModifyConnection"); global.ModifyConnection = ModifyConnection; SetTurn = sec.require("Waze/Action/SetTurn"); global.SetTurn = SetTurn; CreateRoundabout = sec.require("Waze/Action/CreateRoundabout"); global.CreateRoundabout = CreateRoundabout; AddAlternateStreet = sec.require("Waze/Model/AddAlternateStreet"); global.AddAlternateStreet = AddAlternateStreet; CreateObject = sec.require("Waze/Action/CreateObject"); global.CreateObject = CreateObject; ModifyConnectionRestrictions = sec.require("Waze/Action/ModifyConnectionRestriction"); global.ModifyConnectionRestrictions = ModifyConnectionRestrictions; AddLandmark = sec.require("Waze/Action/AddLandmark"); global.AddLandmark = AddLandmark; FeatureVectorSegment = sec.require("Waze/Feature/Vector/Segment"); global.FeatureVectorSegment = FeatureVectorSegment; FeatureVectorLandmark = sec.require("Waze/Feature/Vector/Landmark"); global.FeatureVectorLandmark = FeatureVectorLandmark; AddIntersection = sec.require("Waze/Action/AddIntersection"); global.AddIntersection = AddIntersection; Control = sec.require("Waze/Control"); global.Control = Control; Control.LayerSwitcherToolbox = LayerSwitcherToolbox; Util = { defined: function (e) { return "undefined" != typeof e && null !== e } }; ObjectType = sec.require("Waze/Model/ObjectType"); global.ObjectType = ObjectType; KeyboardShortcutEditor = sec.require("Waze/View/KeyboardShortcutEditor"); global.KeyboardShortcutEditor = KeyboardShortcutEditor; console.log("WMETB: all requires loaded"); var exp = {}; var module = {}; var wrapperModifyAllConnections = function (e, t, i) {
            var s = sec.require("Waze/Action/CompositeAction"); var a = sec.require("Waze/Action/SetTurn"); r = OL.Class(s, {
                initialize: function (e, t, r) { return this.node = e, this.allow = t, s.prototype.initialize.apply(this, [r]) }, doAction: function () {
                    var e, t, i; this.node.attributes.segIDs.forEach(function (segID1) {
                        this.node.attributes.segIDs.forEach(function (segID2) {
                            if (segID1 != segID2) {
                                var seg1 = Waze.model.segments.get(segID1); var seg2 = Waze.model.segments.get(segID2); if (this.node.isTurnAllowedBySegDirections(seg1, seg2) && !seg1.isTurnAllowed(this.node, seg2))
                                { var turn = Waze.model.getTurnGraph().getTurnThroughNode(this.node, seg1, seg2); this.doSubAction(new a(Waze.model.getTurnGraph(), turn.withTurnData(turn.getTurnData().withState(1)))); }
                            }
                        }, this);
                    }, this);
                }, CLASS_NAME: "Waze.Action.ModifyAllConnections"
            }), e.exports = r
        }; exp = { exports: {}, id: -1, loaded: !1 }; wrapperModifyAllConnections.call(exp.exports, exp, exp.exports, null); exp.loaded = !0; module = { "Waze/Action/ModifyAllConnections": exp.exports }; sec.require.define(module); var wrapperCreateRoundaboutNoCross = function (e, t, i) {
            var n, s = (sec.require("Waze/Action"), sec.require("Waze/Action/CompositeAction")), r = sec.require("Waze/Action/UpdateSegmentGeometry"), o = sec.require("Waze/Action/SplitSegments"), a = sec.require("Waze/Action/AddNode"), l = sec.require("Waze/Action/AddSegment"), u = sec.require("Waze/Action/SetTurn"), h = sec.require("Waze/Action/ConnectSegment"), c = sec.require("Waze/Action/DeleteSegment"), d = sec.require("Waze/Action/CreateObject"), p = sec.require("Waze/Action/UpdateObject"), g = sec.require("Waze/Model/ObjectType"), m = sec.require("Waze/Feature/Vector/Segment"); n = OpenLayers.Class(s, {
                ELLIPSE_PRECISION: .17453292519943295, ellipse: null, containedSegments: null, roundaboutSegments: null, isLeftHand: !1, initialize: function (e, t) { s.prototype.initialize.apply(this, [t]), this.ellipse = e }, destroy: function () { this.ellipse = null, s.prototype.destroy.apply(this) }, doAction: function () { var e = this.getIntersections(); return e.isEmpty() ? !1 : (this.determineDrivingDirection(e), this.deleteContainedSegments(), this.modifyIntersectingSegments(e), this.addRoundaboutSegments(e), void this.addRoundabout()) }, determineDrivingDirection: function (e) { var t = e[0][0].segments[0], i = t.getAddress(); this.isLeftHand = null === i.street ? this.model.isLeftHand : i.country.leftHandTraffic }, addRoundabout: function () { var e = _(this.roundaboutSegments).invoke("getID"), t = new d(null, this.model.junctions, { segIDs: e, type: "RA" }); this.doSubAction(t); var i = t.object; this.roundaboutSegments.forEach(function (e) { this.doSubAction(new p(e, { junctionID: i.getID() })) }, this) }, deleteContainedSegments: function () { this.containedSegments.forEach(function (e) { this.doSubAction(new c(e)) }, this) }, addRoundaboutSegments: function (e) {
                    var t, i, n, s, r, o, a, u; this.roundaboutSegments = []; e = e.reduce(function (e, t) { return e.concat(t) }); e.sort(function (e, t) { return e.angle - t.angle })
                    if (e.length == 2 && this.ellipse.addExtranode == true) {
                        var angle = (e[0].angle + e[1].angle) / 2.0; if (e[1].angle - e[0].angle < Math.PI)
                            angle = (angle + Math.PI) % (Math.PI * 2); e.splice(0, 0, { angle: angle, point: new OpenLayers.Geometry.Point(this.ellipse.center.x + this.ellipse.rx * Math.cos(angle), this.ellipse.center.y + this.ellipse.ry * Math.sin(angle)), segments: [] }); e.sort(function (e, t) { return e.angle - t.angle })
                    }
                    e.push({ angle: e.first().angle, point: e.first().point, segments: [] })
                    for (t = 0; t < e.length - 1; t++) { for (n = e[t].point, s = e[t + 1].point, a = new OpenLayers.Geometry.LineString, u = new m({ geometry: a }), r = e[t].angle, o = e[t + 1].angle, t === e.length - 2 && (o += 2 * Math.PI), a.addPoint(n.clone()), i = r + this.ELLIPSE_PRECISION; o > i; i += this.ELLIPSE_PRECISION) a.addPoint(new OpenLayers.Geometry.Point(this.ellipse.center.x + this.ellipse.rx * Math.cos(i), this.ellipse.center.y + this.ellipse.ry * Math.sin(i))); i > o && a.addPoint(s.clone()), this.isLeftHand && (u.attributes.fwdDirection = !1, u.attributes.revDirection = !0), this.doSubAction(new l(u)), this.roundaboutSegments.push(u) }
                    e.pop(), this.addNodes(e, this.roundaboutSegments)
                }, addNodes: function (e, t) { var i, n; e.forEach(function (e, s) { i = e.segments.clone(), i.push(t[s]), i.push(t[(t.length + s - 1) % t.length]), e.node ? i.forEach(function (t) { t.isConnectedToNode(e.node) || this.doSubAction(new h(e.node, t)) }, this) : (n = new a(e.point, i), this.doSubAction(n), e.node = n.node), this.isLeftHand ? (this.openConnection(i.first(), e.node, i.last()), this.openConnection(i[1], e.node, i.first()), this.openConnection(i[1], e.node, i.last())) : (this.openConnection(i.first(), e.node, i[1]), this.openConnection(i.last(), e.node, i.first()), this.openConnection(i.last(), e.node, i[1])) }, this) }, openConnection: function (e, t, i) { t.isTurnAllowedBySegDirections(e, i) && this.doSubAction(new u(Waze.model.getTurnGraph(), Waze.model.getTurnGraph().getTurnThroughNode(t, e, i).withTurnData(Waze.model.getTurnGraph().getTurnThroughNode(t, e, i).getTurnData().withState(1)))) }, modifyIntersectingSegments: function (e) { e.forEach(function (e) { 1 === e.length ? this.shortenSegment(e.first()) : this.splitSegment(e) }, this) }, splitSegment: function (e) { var t = e.first().segments.first(), i = new o(t, { splitAtPoint: e.first().point, splittingPointIndex: e.first().index }); this.doSubAction(i), e.first().node = i.splitNode, e.last().segments = [i.splits.last()], e.last().index = e.last().index - e.first().index, e.first().segments = [i.splits.first()], this.shortenSegment(e.last()) }, shortenSegment: function (e) { var t = e.segments.first(), i = t.geometry.clone(); e.goingOut ? (t.geometry.components.splice(0, e.index + 1), t.geometry.addComponent(e.point.clone(), 0)) : (t.geometry.components.splice(e.index + 1), t.geometry.addComponent(e.point.clone())), this.doSubAction(new r(t, i, t.geometry)) }, getIntersections: function () { var e, t, i = this; return this.containedSegments = [], e = this.model.segments.getObjectArray(function (e) { return e.state !== OpenLayers.State.DELETE && e.geometry.bounds.intersectsBounds(i.ellipse.bounds) && i.ellipse.segIdList.indexOf(e.attributes.id) != -1; }), e.reduce(function (e, n) { return t = n.intersectionWithEllipse(i.ellipse.center, i.ellipse.rx, i.ellipse.ry), t instanceof Array ? 1 !== t.length && t.first().goingOut || (t.forEach(function (e) { e.segments = [n] }), e.push(t)) : t && i.containedSegments.push(n), e }, []) }, CLASS_NAME: "Waze.Action.CreateRoundaboutNoCross"
            }), e.exports = n
        }; exp = { exports: {}, id: -1, loaded: !1 }; wrapperCreateRoundaboutNoCross.call(exp.exports, exp, exp.exports, null); exp.loaded = !0; module = { "Waze/Action/CreateRoundaboutNoCross": exp.exports }; sec.require.define(module); ModifyAllConnections = sec.require("Waze/Action/ModifyAllConnections"); global.ModifyAllConnections = ModifyAllConnections; CreateRoundaboutNoCross = sec.require("Waze/Action/CreateRoundaboutNoCross"); global.CreateRoundaboutNoCross = CreateRoundaboutNoCross;
    }; var that = this; setTimeout(function () { initGlobals.call(that); }, 100); setTimeout(sec.WMETB_Init(WMETB_load_JqueryUI), 100);
}.call(this);